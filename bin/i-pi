#!/usr/bin/env python

"""Main script from which the simulation is run.

Deals with creation of the simulation object, reading the input file and
initialising the system.

Run using:
      i-pi input_file.xml

Where 'input_file.xml' should be replaced by the name of the xml input file
from which the system data will be read. For a description of how the input
file should be formatted, see the reference manual.
"""

# This file is part of i-PI.
# i-PI Copyright (C) 2014-2015 i-PI developers
# See the "licenses" directory for full license information.


import sys
import os

# Check that we have the import path for this i-PI set and if not, add it.
dir_root = os.path.realpath(
               os.path.join(os.path.dirname(os.path.realpath(__file__)), '..'))
if not dir_root in sys.path:
    sys.path.insert(0, dir_root)

from ipi.utils.softexit import softexit
from ipi.utils.messages import banner
from ipi.engine.simulation import Simulation


def main(fn_input, do_yappi, print_banner):
    """Loads and runs the simulation stored in `fn_input`."""

     # print the banner if requested
    if print_banner:
        banner()

    # optionally profile this run - set up
    if do_yappi:
        try:
            import yappi
            yappi.start(builtins=True, profile_threads=True)
        except ImportError:
            print 'Profiling with yappi was enabled but could not be imported.'
            sys.exit(1)

    # construct simulation based on input file
    simulation = Simulation.load_from_xml(fn_input)

    # run the simulation
    simulation.run()

    # optionally profile this run - wrap up
    # TODO
    # We do not get to this if the run is ctrl interrupted and exits cleanly.
    # Maybe the profiler should be global and cleaned up on exit?
    if do_yappi:
        yappi.stop()
        yappi.get_thread_stats().print_all()
        yfs = yappi.get_func_stats()
        yfs.save("profile.kgrind", type="callgrind")
        ypo = open("profile.yappi", "w")
        yfs.print_all(out=ypo)
        ypo.close()

    # It seems that checkpoints are written by the following.
    # TODO
    # Do this differently, so they are written when simulation.run() finishes.
    softexit.trigger(" @ SIMULATION: Exiting cleanly.")


if __name__ == '__main__':

    # TODO
    # Read yappi and banner preference from arguments.
    # Use optparse, as argparse requires >=2.7.

    if (len(sys.argv) != 2):
        print """usage: %s <input file>""" % sys.argv[0]
    else:
        do_yappi = False
        #do_yappi = True
        print_banner = True
        main(sys.argv[1], do_yappi, print_banner)
