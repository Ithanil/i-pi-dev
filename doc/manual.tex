\documentclass[11pt,english,fleqn]{report}
\IfFileExists{t1futs.fd}{\usepackage{fourier, helvet}}{\usepackage{lmodern}}
\usepackage[T1]{fontenc}
\usepackage[latin9]{inputenc}
\setcounter{secnumdepth}{3}
\setcounter{tocdepth}{3}
\usepackage{babel}
\usepackage{verbatim}
\usepackage{graphicx}
\usepackage{url}
\usepackage{amsmath}
\usepackage{amssymb}

% MC STYLE
\usepackage[a4paper]{geometry}
\geometry{verbose,tmargin=3cm,bmargin=3cm,lmargin=3.5cm,rmargin=3.0cm}
\usepackage[pagestyles]{titlesec}
\usepackage[unicode,colorlinks,breaklinks]{hyperref}
\usepackage{float}
\usepackage{caption}
\usepackage[sort&compress,numbers]{natbib}
\usepackage{microtype}
\usepackage{etoolbox}
\setlength{\emergencystretch}{2em}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% page layout
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\widowpenalty=200
\clubpenalty=200
\setlength{\parskip}{0.0ex plus 0.5ex minus 0.0ex}
% headings
\renewpagestyle{headings}[\small]{
\headrule \sethead{ %
{\ifnumgreater{\value{chapter}}{0}{Chapter \thechapter}{\bf \chaptertitle}} %
}{ %
{   \ifnumgreater{\value{chapter}}{0}{\bf \chaptertitle}{}} %
} %
{ \usepage}
}
\pagestyle{headings}

%empty page to pad chapters
\makeatletter
\def\cleardoublepage{\clearpage\if@twoside \ifodd\c@page\else
\hbox{}
\vspace*{\fill}
\begin{center}
\ 
\end{center}
\vspace{\fill}
\thispagestyle{empty}
\newpage
\if@twocolumn\hbox{}\newpage\fi\fi\fi}
\makeatother
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% spacings (use a lot of rubber lenghts)
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\setlength{\floatsep}{2ex plus 5ex minus 1ex }
\setlength{\textfloatsep}{3ex plus 3ex minus 1ex }

%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% floats setup
%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% positioning
\renewcommand{\topfraction}{0.85}
\renewcommand{\bottomfraction}{0.85}
\renewcommand{\textfraction}{0.15}
\renewcommand{\floatpagefraction}{0.65}
\setcounter{topnumber}{2}
\setcounter{bottomnumber}{2}
%default placement
\floatplacement{figure}{btp}
% caption
\captionsetup{margin=10pt,font=small,labelfont=bf}

%%%%%%%%%%%%%%%%%%%%%%%%%%%
% chapter headings
%%%%%%%%%%%%%%%%%%%%%%%%%%%
\titleformat{\chapter}[display]{\normalfont\huge\bfseries}%
{\vspace{1.5em}\raggedleft\large\chaptertitlename ~\thechapter\hrule\vspace{-0.5ex}}
{-0.25ex}{\begin{minipage}{0.75\textwidth}\raggedright}[\end{minipage}]
\makeatletter


%%%%%%%%%%%%%%%%%%%%%%%%%%%
% properties and fields formatting
%%%%%%%%%%%%%%%%%%%%%%%%%%%
% old version using ifthenelse
%\newcommand{\ipiitem}[3]{%   
%  \ifthenelse{ \equal{#1}{} } %
%             {} %
%             { \ifthenelse{ \equal{#1}{\underline{\smash{}}} } %
%                          {} %
%                          {  %
%      {\noindent\textbf{#1}:\rule{0.0pt}{1.05\baselineskip}\quad} % uses a strut to add a bit of vertical space
%                          } %
%             } %
%   {#2}\parskip=0pt\par
%   \ifthenelse{ \equal{#3}{} } %
%              {} %
%              { {\hfill\raggedleft\textit{\small #3}\par} }
%}

\newcommand{\ipiitem}[3]{%
   \ifblank{#1} % if no name is specified just output nothing
           {} %  
           { \ifstrequal{#1}{\underline{\smash{}}} % also in this case
             {} %
             { % print out beautifully
               {\noindent\textbf{#1}:\rule{0.0pt}{1.05\baselineskip}\quad} % uses a strut to add a bit of vertical space
             } %
           } %
    {#2}\parskip=0pt\par % prints the help text
   \ifblank{#3}{} %
          { {\hfill\raggedleft\textit{\small #3}\par} } % details string
}

\makeatletter
\newenvironment{ipifield}[4]{ %
   \ifblank{#1} {} {\vspace{0.5em}}  % some spacing between fields
   \noindent\parskip=0pt\begin{tabular}[t]{|p{1.0\linewidth}}   % table filling the whole line -- fields cannot break
      %cell without border
      \multicolumn{1}{@{}p{1.0\linewidth}}{
         \ipiitem{\underline{\smash{#1}}}{#2}{}  % name and help string
         \ifblank{#4} % if there are no attributes, write here the details
                 {  \ifblank{#3} {} % if there are any....
                            {{\hfill\raggedleft\textit{\small #3}}\par}}
                 {} %else do nothing here
         } \vspace{-1em}\\ % close multicol, go down and back up
      % cell with border (only if attributes are present)
      \ifblank{#4} {} % do nothing if there are no attributes (the details may just have been printed above
              { \ifblank{#3} {} { \vspace{-1em}{\hfill\raggedleft\textit{\small #3}}\par } % print the details
                {#4} \vspace{-1em} \\\hline } % negative vspace to undo the line break
   \end{tabular}
   \parskip=0pt\list{}{\listparindent 1.5em % indent the body of the environment 
         \leftmargin    \listparindent
         \rightmargin   0pt
         \parsep        0pt
         \itemsep       0pt
         \topsep        0pt
          }%
    \item\relax
 }
 {\endlist}
\makeatother

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% User specified LaTeX commands.
\usepackage{color}
\usepackage{multicol}\makeindex
\usepackage{xspace}
\usepackage[numbers]{natbib}

\newenvironment{code}{%
\footnotesize 
\verbatim
}{
\endverbatim
\normalsize
}

\makeatother

\begin{document}
\newcommand{\dd}{\; \mathrm{d}} 
\newcommand{\Tr}{\mathrm{Tr}} 
\newcommand{\bra}{< \! \!} 
\newcommand{\ket}{\! \! >} 
\newcommand{\betan}{\beta_N} 
\newcommand{\logn}{\mathrm{ln}} 
\newcommand{\expon}{\mathrm{exp}} 
\newcommand{\Imag}{\mathrm{Im}}
\newcommand{\ipi}{{i-PI}\xspace}
\newcommand{\DFT}{Quantum Espresso, CP2K, CPMD and FHI-AIMS }
\newcommand{\empirical}{LAMMPS}

\begin{titlepage} 

\begin{center}
\vspace*{2.5cm}

\par\end{center}

\begin{center}
\includegraphics[width=0.6\textwidth]{ipi-logo.pdf}
\par\end{center}

\begin{center}
{\Large\bf A Python wrapper for \\Path Integral Molecular Dynamics}
\par\end{center}

\begin{center}
{\large v. 1.0}
\par\end{center}

\end{titlepage}

\pagenumbering{roman}

\tableofcontents{}


\newpage{}\pagenumbering{arabic}


\chapter{About \ipi}

\label{intro}

\ipi is a Path Integral Molecular Dynamics (PIMD) wrapper code written
in Python, designed to be used together with an \emph{ab initio} evaluation
of the interactions between the atoms. The main goal is to decouple
the problem of evolving the ionic positions to sample the appropriate
thermodynamic ensemble and the problem of computing the inter-atomic
forces. 

\begin{figure}[hb]
\centering\includegraphics[width=0.9\textwidth]{ipi-scheme.pdf}
\caption{\label{fig:scheme} Schematic representation of the functioning of \ipi{}.} 
\end{figure}

The implementation is based on a client-server paradigm, where \ipi
acts as the server and deals with the propagation of the nuclear dynamics,
whereas the calculation of the potential energy, forces and the potential
energy part of the pressure virial is delegated to one or more instances
of an external code, acting as clients. Since the main focus is on
performing \emph{ab initio} PIMD -- where the cost of the force evaluation
is overwhelming relative to the ionic dynamics -- clarity has been
privileged over speed. Still, the implementation of \ipi is efficient
enough that it can be used with empirical forcefields to perform simple
benchmarks and preparatory simulations. 


\section{Manual structure}

This manual will be structured as follows: 
\begin{itemize}
\item In chapter \ref{intro} we briefly discuss the basis for PIMD and
some of the specialized techniques used in \ipi. 
\item In chapter \ref{getstarted} we will discuss how to install the code
and test that it is working, and give a brief tutorial on running
simulations with \ipi.
\item In chapter \ref{user} we explain in more detail the form of the input
and output files and how the communication between the client and
server codes is done.
\item In chapter \ref{hierarchy} a full list of the major classes used
in the code is given, along with the appropriate tag names and a brief
description of all the fields that can be specified in the xml input
file.
\item In chapter \ref{trouble} we list some of the more commonly encountered
problems, and their solutions.
\end{itemize}

\section{Path Integral Molecular Dynamics}

Molecular dynamics (MD) is a technique used to study the properties
of a system of interacting particles by applying Newton's equations
of motion to produce trajectories which can be used to efficiently
explore the phase space. This can be used to calculate many equilibrium
and dynamical properties, study systems from isolated gas molecules
to condensed phase bulk materials, and can be applied to systems from
the atomistic scale to mesoscopic colloidal particles.

However, while this technique has been very successful, in most MD
implementations the assumption is made that the nuclei behave as classical
particles, which for light nuclei such as hydrogen is often a very
poor approximation as the effect of zero-point energy (ZPE) and quantum
tunnelling can be large. For example, even at room temperature the
vibrational frequency of an OH stretch in water is over 15 times larger
than the available thermal energy, and so this motion will be highly
quantized. The current state-of-the-art method to include nuclear
quantum effects (NQE) in the calculation of static properties of condensed
phase systems is path integral molecular dynamics (PIMD).

PIMD generates the quantum-mechanical ensemble of a system of interacting
particles by using MD in an extended phase space. This is derived
from the path integral formalism \cite{feyn-hibb65book}, which
relates the statistics of a collection of quantum particles to those
of a set of classical ring polymers, a ring polymer being a number
of replicas of a particle coupled by harmonic springs. This so-called
classical isomorphism is exact in the limit as the number of replicas
goes to infinity, but in practice is converged numerically with only
a finite number.

This then allows quantum phase space averages to be calculated from
classical trajectories, with only about an order of magnitude more
computing time than would be required for standard MD. Also, since
PIMD is simply classical MD in an extended phase space, many of the
techniques developed to improve the scope and efficiency of MD simulations
can be applied straightforwardly to the equivalent PIMD calculations
\cite{ceri+10jcp,mart+99jcp}. Finally, several techniques designed
specifically for PIMD simulations are now available to increase the
rate of convergence with respect to the number of replicas used \cite{mark-mano08jcp,ceri+11jcp},
further reducing the computational overhead of the method. All
of these facts mean that it is now feasible to do PIMD simulations
with thousands of molecules, or even to use \emph{ab initio} electronic
structure calculations to propagate the dynamics for small systems.

Furthermore, the framework used to run PIMD simulations can be adapted
to generate approximate quantum dynamical information 
\cite{cao-voth93jcp,cao-voth94jcp,crai-mano04jcp,braa-mano06jcp},
and so can also be used to calculate correlation functions. While
real-time quantum coherences cannot be captured, the inclusion 
of quantum statistical information
and the rapid decoherence observed in condensed phase systems mean
that in many cases very accurate results can be obtained from such
approximate treatments of quantum dynamics \cite{habe+13arpc}.


\section{Implementation}


\subsection{Automated evaluation (depend objects)}

\ipi uses a caching mechanism with automatic value updating to make
the code used to propagate the dynamics as simple and clear as possible.
Every physical quantity that is referenced in the code is created
using a {}``depend'' object class, which is given the parameters
on which it depends and a function used to calculate its value. 

{}``Depend'' objects can be called to get the physical quantity
they represent. However, they have further functionality. Firstly,
once the value of a {}``depend'' object has been calculated, its
value is cached, so further references to that quantity will not need
to evaluate the function that calculates it. Furthermore, the code
keeps track of when any of the dependencies of the variable are updated,
and makes sure that the quantity is automatically recomputed when
it is needed. 

This choice makes implementation slightly more complex when the physical
observables are first introduced as variables, as one has to take
care of stating their dependencies as well as the function that computes
them. However, the advantage is that when the physical quantities
are used, in the integrator of the dynamics or in the evaluation of
physical properties, one does not need to take care of book-keeping
and the code can be clean, transparent and readable.


\subsection{Communication protocol}

Since \ipi is designed to be used with a wide range of codes and
platforms, it has to rely on a simple and robust method for communicating
between the server and client. Even though other choices are possible,
and it should be relatively simple to implement other means of communication,
the preferred approach relies on sockets as the underlying infrastructure.
Both Internet and Unix domain sockets can be used: the latter allow
for fast communication on a single node, whereas the former make
it possible to realise a distributed computing paradigm, with clients
running on different nodes or even on different HPC facilities. In
order to facilitate implementation of the socket communication in
client codes, a simple set of C wrappers to the standard libraries
socket implementation is provided as part of the \ipi distribution,
that can be used in any programming language that can be linked with
C code.

As far as the communication protocol is concerned, the guiding principle
has been keeping it to the lowest common denominator, and avoiding
any feature that may be code-specific. Only a minimal amount of information
is transferred between the client and the server; the position of
the atoms and cell parameters in one direction, and the forces, virial
and potential in the other.

For more details about sockets and communication, see \ref{distrib}. 


\subsection{Internal units}

\label{units}

All the units used internally by \ipi are atomic units, as given
below. By default, both input and output data are given in atomic
units, but in most cases the default units can be overridden if one
wishes so. For details on how to do this, see \ref{inputunits} and
\ref{propertyfile}.

\begin{center}
\begin{tabular}{lll}
\hline\hline
Unit & Name & S.I. Value\\
\hline 
Length & Bohr radius & 5.2917721e-11 m\\
Time & N.A. & 2.4188843e-17 s\\
Mass & Electron mass & 9.1093819e-31 kg\\
Temperature & Hartree & 315774.66 K\\
Energy & Hartree & 4.3597438e-18 J\\
Pressure & N.A. & 2.9421912e13 Pa\\
\hline\hline
\end{tabular}
\par\end{center}


\section{Core features}

The functionality of \ipi includes:
\begin{itemize}
\item Thermostats for constant temperature ensembles, including: \begin{itemize}
\item Local and global stochastic thermostats \cite{plangevin1908cras,buss-parr08cpc}, with optional optimized sampling of the ring polymer normal mode coordinates \cite{ceri+10jcp}.
\item Optimal sampling generalized Langevin equation (GLE) thermostats \cite{ceri+09jctc}.
\item Path integral + GLE (PI+GLE) thermostats \cite{ceri+11jcp} for accelerating the
convergence of the potential energy with respect to the number of replicas, 
as well as the more recent PIGLET method \cite{ceri-mano12prl}, which also
accelerates the convergence of the kinetic energy.
\end{itemize}
\item Barostats for constant pressure ensembles \cite{mart+99jcp,buss+09jpc}.
\item Ring polymer contraction \cite{mark-mano08jcp}.
\item Scaled path finite difference energy and heat capacity estimators
\cite{tyamamoto05jcp}.
\item Displaced path momentum distribution estimator \cite{linlin+10prl}.
\item Dynamical property calculation modes:\begin{itemize}
\item Ring polymer molecular dynamics \cite{crai-mano04jcp}.
\item Partially-adiabatic centroid molecular dynamics \cite{habe+08jcp,hone+06jcp}.
\end{itemize}
\end{itemize}

\section{Licence and credits}

This code is distributed under the GPL licence. For more details see
\url{www.gnu.org/licences/gpl.html}. If you use this code in any
future publications, please cite this using {[}cpc paper citation{]}.


\section{On-line resources}


\subsection{Python resources}

For help with Python programming, see \url{www.python.org}. For information
about the NumPy mathematical library, see \url{www.numpy.org}, and
for worked examples of its capabilities see \url{www.scipy.org/Tentative_NumPy_Tutorial}.
Finally, see \url{http://hgomersall.github.io/pyFFTW/} for documentation
on the Python FFTW library that is currently implemented with the
wrapper.


\subsection{Client code resources}

\label{librarywebsites}

There are currently client patches available for Quantum Espresso version
4.3.2 and CP2K version 2.2. It should be possible to adapt these patches
to other versions of the codes with minor modifications. For more
information about Quantum Espresso and CP2K, go to \url{www.quantum-espresso.org}
and \url{cp2k.org} respectively.

There are several Fortran and C libraries that most client codes will
probably need to run, such as FFTW, BLAS and LAPACK. These can be
found at \url{www.fftw.org}, \url{www.netlib.org/blas} and \url{www.netlib.org/lapack}
respectively.

These codes do not come as part of the \ipi package, and must be
downloaded separately. See chapter~\ref{install} for more details
of how to do this. 


\subsection{\ipi resources}

For more information about \ipi{} and to download the source code
go to \url{gle4md.berlios.de }, where one can also obtain colored-noise
parameters to run Path Integral with Generalized Langevin Equation
thermostat (PI+GLE/PIGLET) calculations.

%Mano's note: Allowed by CPC?

\chapter{Getting started}

\label{getstarted}


\section{Installing \ipi}

\label{install}


\subsection{Requirements}

To install and run \ipi, you will need to have:
\begin{itemize}
\item Python version 2.4 or greater
\item The Python numerical library NumPy
\end{itemize}
Note that \ipi does not need to be compiled, it can be run as a script
as long as the appropriate libraries have been installed.

Additionally, most client codes will have their own requirements.
Many of them, including the test client codes given in the {}``forces''
directory, will need a suitable Fortran compiler. A C compiler is
required for the sockets.c wrapper to the sockets standard library.
Most electronic structure codes will also need to be linked with some
mathematical libraries, such as BLAS, FFTW and LAPACK. Installation
instructions for these codes should be provided as part of the code
distribution and on the appropriate website, as given in \ref{librarywebsites}.
Patching for use with \ipi{} should not introduce further dependencies.


\subsection{\ipi download}

A tar file can be downloaded from the website \url{gle4md.berlios.de}.
To install this you need to input the following command:

%Mano's note: Again, is this allowed?

\begin{code}
> tar xf [wrapper\_tar\_file.tar]
\end{code}

%Mano's note: Perhaps remove claim of Windows from prog. description?

You can also obtain a local clone of the git repository on \url{bitbucket.org}
using:

\begin{code}
> git clone [github repository name]
\end{code}


\subsection{Installing NumPy}

NumPy is the standard Python mathematics library, and is used for
most of the array manipulation and linear algebra in \ipi. It should
be installed alongside most standard Python environments on HPC facilities.
Otherwise, it is generally relatively straightforward to install it. 

In any case you must first obtain the NumPy code, which can be downloaded
as a tar file from \url{http://www.numpy.org}. If the version of
NumPy being installed is given by {}``np\_vers'', this can be extracted
using:

\begin{code}
> tar czf np_vers.tar.gz
\end{code}

Before installing this code it first needs to be configured correctly.
Note that this requires the distutils package that comes with the
python-dev package. Assuming that the required software is installed,
the NumPy package is built using:

\begin{code}
> python setup.py build
\end{code}

The next step is to install NumPy. By default the download is to the
directory /usr/local. If you have root access, and so can write to
/usr, then all that needs to be done to finish the install is:

\begin{code}
> python setup.py install
\end{code}

If you do not have root access, then the next step depends on which
version of Python is beind used. With versions 2.6 or later there
is a simple command to automatically download into the directory \$HOME/local:

\begin{code}
> python setup.py install --user
\end{code}

With Python 2.4/2.5 the process is a little more involved. First you
must explicitly install the package in the directory of choice, {}``np\_dir''
say, with the following command:

\begin{code}
> python setup.py install --prefix=np_dir
\end{code}

Next, you must tell python where to find this library, by appending
to the Linux environment variable PYTHONPATH. If you are
using Python version {}``py\_vers'', then the NumPy libraries will
have been installed in the directory {}``np\_dir/lib/py\_vers/site-packages'',
or a close analogue of this. In the above case the following command
will allow the Python interpreter to find the NumPy libraries:

\begin{code}
> export PYTHONPATH=$PYTHONPATH:np_dir/lib/py_vers/site-packages
\end{code}
%$

Now Python scripts can import the NumPy libraries using:

\begin{code}
import numpy
\end{code}


\subsection{PyFFTW}

Some of the steps in the dynamics algorithm involve a change of variables
from the bead coordinates to the normal modes of the ring polymers.
Currently, this transformation is, at least by default, computed using
a fast-Fourier transform (FFT) library within the NumPy distribution.
This however is not the only distribution that could be used, and
indeed faster stand-alone versions exist. The gold-standard FFT library
is the FFTW library, which is a set of C libraries that have been
heavily optimized for a wide range of applications. There have been
a number of Python wrappers built around the FFTW library, one of which
is currently interfaced with \ipi. This code can be found at \url{https://github.com/hgomersall/pyFFTW},
and has documentation at \url{http://hgomersall.github.io/pyFFTW/}.

This code has the following dependencies:
\begin{itemize}
\item Python version 2.7 or greater
\item Numpy version 1.6 or greater
\item FFTW version 3.2 or greater
\end{itemize}
This can be installed in the same way as NumPy, except using the code
distribution above, or using various installation packages as per
the instructions on the above documentation. Note that no other options
need to be specified in the input file, the wrapper will check to
see if this library is available, and if it is it will be used by
default. Otherwise the slower NumPy version will be used.


\section{Clients}




\subsection{Minimal client code}

%Mano's note: Missing section...

\subsection{Patching CP2K}

%Mano's note: Missing section...


\subsection{Patching Quantum-Espresso}

You can download the source code for Quantum Espresso at \url{www.quantum-espresso.org/}.
The tar file can be extracted in the same way as the Python and NumPy
libraries above. However, before this can run with \ipi, the code
must be adapted to use the socket interface. For Quantum Espresso
version 4.3.2, there is a patch file to allow it to be used as a client
code with \ipi in the directory {}``patches/pwscf''. If you are
currently in the top level directory of the Quantum-Espresso distribution,
the patch can be applied to the source code using:

\begin{code}
> patch -p1 < i-pi/patches/pwscf/pw-driver.patch
\end{code}

After this, continue the compilation as per the instructions at \url{www.quantum-espress.org/}.


\subsection{Writing a patch}

%Mano's note: Missing section...


\section{Running \ipi}

\ipi functions based on a client-server protocol, where the evolution of the nuclear dynamics
is performed by the \ipi server, whereas the energy and forces evaluation is delegated to 
one or more instances of an external program, that acts as a client. This design principle
has several advantages, in particular the possibility of performing PIMD based on the forces
produced by one's favourite electronic structure/empirical force field code. However, it 
also makes it slightly more complicated running a simulation, since the two components
must be set up and started independently.

\subsection{Running the \ipi server}

\label{runningsimulations}

\ipi simulations are run using the i-pi Python script found in the
{}``i-pi'' directory. This script takes an xml-formatted file as
input, and automatically starts a simulation as specified by the data
held in it. If the input file is called {}``input\_file.xml'', then
the wrapper is run using:

\begin{code}
> python i-pi input_file.xml
\end{code}

This reads in the input data, initializes all the internally used
objects, and then creates the server socket. The code will then wait
until at least one client code has connected to the server before
running any dynamics. Note that until this has happened the code is
essentially idle, the only action that it performs is to periodically
poll for incoming connections.


\subsection{Running the client code}

\label{runningclients}

\subsection{Built-in, example client}

\subsubsection{CP2K}

%To use CP2K as the client code, an additional file named {}``serverfile''
%must be kept in the same directory that CP2K is being run from. It
%should contain a string a single line long, of the format {}``mode:host:port\_number''.
%{}``mode'' should either be {}``INET'' or {}``UNIX'', representing
%an internet or unix domain socket respectively. The rest of the input file
%is the same as for a standard CP2K calculation.

%Mano's note: This is now all wrong, as it has been updated to more closely resemble the QE input.

\subsubsection{Quantum-Espresso}

To use Quantum-Espresso as the client code using an 
internet domain socket on the host
address {}``host\_address'' and on the port number {}``port''
the following lines must be added to the input file:

\begin{code}
&CONTROL
   ...
   calculation=`driver'
   srvaddress=`host_address:port'
   ...
/
\end{code}

If instead a unix domain socket is required then the following
modification is necessary:


\begin{code}
&CONTROL
   ...
   calculation=`driver'
   srvaddress=`UNIX:host_address:port'
   ...
/
\end{code}

The rest of the input file should be the same as for a standard Quantum
Espresso calculation, as explained at \url{www.quantum-espress.org/}.

\subsection{Running on a HPC system}

Running \ipi on a high-performance computing (HPC) system can be a bit more challenging
than running it locally using UNIX-domain sockets or using the \emph{localhost} 
network interface. 

The main problem is related to the fact that different HPC systems adopt
a variety of solutions to have the different nodes communicate with each other
and with the login nodes, and to queue and manage computational jobs. 
Typically, each node will have more than one network interface: a list
can be obtained for instance with the command
%
\begin{code}
> /sbin/ip addr
\end{code}
%
that will return a list of interfaces of the form
%
\begin{code}
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 16436 qdisc noqueue 
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
    inet 127.0.0.1/8 scope host lo
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:25:b3:e7:a0:44 brd ff:ff:ff:ff:ff:ff
    inet 192.168.1.254/16 brd 192.168.255.255 scope global eth0
3: eth1: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc pfifo_fast qlen 1000
    link/ether 00:25:b3:e7:a0:46 brd ff:ff:ff:ff:ff:ff
    inet 129.67.106.153/22 brd 129.67.107.255 scope global eth1
\end{code}
%
Each item corresponds to a network interface, identified by a number and a name (lo, eth0, eth1, \ldots).
Most of the interfaces will have an associated IP address -- the four numbers separated by dots
that are listed after ``inet'', e.g. 192.168.1.254 for the eth0 interface in the example above.

\begin{figure}[hb]
\centering\includegraphics[width=0.9\textwidth]{ipi-running.pdf}
\caption{\label{fig:running} Different approaches to run \ipi{} and a number of 
instances of the forces code on a HPC system: a) running \ipi and the clients in a single
job; b) running \ipi and the clients on the same system, but using different jobs, or running
\ipi interactively on the login node; c) running \ipi on a local workstation, communicating
with the clients (that can run on one or multiple HPC systems) over the internet. } 
\end{figure}

These internet address should be specified in the address 


\section{A simple tutorial}

Here we give a simple step-by-step guide through an example
simulation, exploring
some of the more generally useful options that \ipi offers and making
no assumptions of previous experience of this code or other MD codes.
Excerpts from the relevant input files are reproduced here, for explanation
purposes, but to get the most out of this tutorial the user is encouraged
to work through it themselves. For this purpose, the input files
have been included with the \ipi distribution, in the {}``test/tutorial''
directory.

The chosen problem is that of a small \emph{NPT} simulation of para-hydrogen, 
using the Silvera-Goldman potential \cite{silv-gold78jcp}. 
We will take (\(N\),\(P\),\(T\)) = (108, 0, 25 K).

Finally, note that this is designed to be a demonstration of some
of the basic abilities of \ipi, and so the user is encouraged to
play with some of the variables to get a feel for how the input file
works. 

\subsection{Part 1 - \emph{NVT} Equilibration run}


\subsubsection{Client code}

Let us now consider the problem of how to use \ipi to run a \emph{NPT}
simulation of para-hydrogen. The first thing that is required is a
client code that is capable of calculating the potential interactions
of para-hydrogen molecules. Fortunately, one of the client codes distributed
with \ipi has an appropriate empirical potential already hard-coded
into it, and
so all that is required is to create the {}``driver.x'' file in
the {}``drivers'' directory, using the UNIX utility make.

This client code can be used for several different problems, some of which
are explored in the {}``tests'' directory, but for the current problem
we will use the Silvera-Goldman potential with a cut-off radius
of 15 \(a_0\). This is run using the following command:

\begin{code}
> ./driver.x -m sg -h localhost -o 15 -p 31415
\end{code}

The option {}``-m'' is followed by the empirical potential required,
in this case we use {}``sg'' for Silvera-Goldman, 
{}``-h localhost'' sets up the client hostname
as {}``localhost'', {}``-o 15'' sets the cut-off to 15 \(a_0\), 
and {}``-p 31415'' sets the port number to 31415. 

Note that usually this step will require setting up appropriate
client code input files, possibly for an \emph{ab initio} electronic
structure code, and so is generally a more involved process. Refer
to \ref{runningclients}, and the documentation of the appropriate
client code, for more details on how to do this step.


\subsubsection{Creating the xml input file}

Now that the client code is ready, an appropriate xml input file needs
to be created from which the host server and the simulation data can
be initialized. Here, we will go step by step through the creation
of a minimal input file for a simple \emph{NVT} equilibration run. Note that
the working final version is held within the {}``tutorial-0'' directory.

Firstly, when reading the input file the \ipi xml functions look
for a {}``simulation''
tag as a sign to start reading data. For those familiar with xml jargon,
we have defined {}``simulation'' as the root tag, so all the input
data read in must start and end with a {}``simulation'' tag, as
show below:

\begin{code}
<simulation>
   Input data here...
</simulation>
\end{code}

xml syntax requires a set of hierarchially nested tags, each of which
contain data and/or more tags. Also, \ipi itself requires certain
tags to be present, and keeps track of which tags are supposed to
be where. More information about which tags are available can be found
in \ref{hierarchy}, more information on xml syntax can be found in
\ref{ifilestructure}, and possible errors which can occur if the
input file is not well formed can be found in \ref{trouble}. 

For the sake of this first tutorial however, we will simply discuss the
those tags which are needed for a single \emph{NVT} equilibration run.
The most important tags are {}``initialize'', {}``ensemble'', 
{}``total\_steps'' and {}``forces''.
These correspond to the tag to initialize the atom configurations,
the tag to define the appropriate ensemble,
the tag to set the length of the simulation and the tag to specify the client code
respectively.
We will also discuss {}``output'', which is used to define what output data
is generated by the code.

At this point then, the input file looks like:

\begin{code}
<simulation>
   <total_steps>
      ...
   </total_steps>
   <initialize>
      ...
   </initialize>
   <forces>
      ...
   </forces>
   <ensemble>
      ...
   </ensemble>
   <output>
      ...
   </output>
</simulation>
\end{code}

Now let us consider each of these tags in turn. Firstly, {}``initialize''.
As the name suggests, this initializes the state of the system, so
this is where we will specify the atom positions and the cell
parameters. Firstly, this takes an attribute which specifies the number
of replicas of the system, called {}``nbeads''. An attribute is
a particular type of xml syntax designed to specify a single bit of
data, and has the following syntax:

\begin{code}
<initialize nbeads='4'>
   ...
</initialize>
\end{code}

Note that an attribute forms part of the opening tag, and that the
value being assigned to it is held within quotation marks. In this
case, we have set the number of replicas, or beads, to 4.

Next, we must specify the atomic configuration. Rather than initialize
the atom positions manually, we will instead use a separate configuration 
file for this purpose.
Here we will discuss two of the input formats that are compatible
with \ipi, xyz files and pdb files.

The xyz format is the simplest input format
for a configuration file that \ipi accepts, and it has the following
syntax:

\begin{code}
natoms
# COMMENT LINE: PUT TITLE OF FILE HERE
atom1   x1  y1  z1
atom2   x2  y2  z2
...
\end{code}
where {}``natoms'' is replaced by an integer giving the total number
of atoms, in this case 108, atom1 is a label for atom 1, in this case
H2 (since we are simulating para-hydrogen), and (x1, y1, z1) are the
x, y and z components of atom 1 respectively. 

Note that we are treating the para-hydrogen molecules isotropically here,
i.e. as spherical psuedo-atoms.
For the current system this is a good approximation, since at 
the state point under consideration every molecule is in its 
rotational ground state. For further details on this potential,
and a demonstration of its application to quantum dynamics, see
\cite{silv-gold78jcp} and \cite{mill-mano05jcp}.

Other than its simplicity, the main advantage of this type of file
is that it is free-formatted, and so there is no set precision
to which each value must be written. This greatly simplifies
both reading and writing these files.

The other file format that we can use is the pdb format. This
has the following structure:

\begin{code}
TITLE insert title here...
CRYST1        a        b        c      A      B      C P 1           1
ATOM      1   n1   1     1          x1      y1      z1  0.00  0.00             0
ATOM      2   n2   1     1          x2      y2      z2  0.00  0.00             0
...
\end{code}
where a, b and c are the cell vector lengths, A, B and C are the angles between
them, n1 and n2 are the labels for atoms 1 and 2, and (x1, y1, z1)
and (x2, y2, z2) give the position vectors of atoms 1 and 2. 

Note that this is
fixed-formatted, so the number of spaces matters. Essentially, the
above format needs to be copied verbatim, using the same column
widths and all the same keywords. For an exact specification
of the file format (of which only a subset is implemented 
with \ipi) see
\url{http://deposit.rcsb.org/adit/docs/pdb_atom_format.html}.

The main advantage of this format is that it simultaneously specifies
the atom configurations and the cell parameters, simplifying
the input file.

Here we will show how the to specify the xml input file
in both of these cases, assuming that the user has already
created the configuration file themselves.
Note that these file formats can be read by
visualization programs such as VMD, and so it is generally advised to
use such software to make sure that the configuration is as expected.

For the sake of this tutorial, we have included valid xyz and pdb input
files in the {}``tutorial-1'' directory called {}``our\_ref.xyz''
and {}``our\_ref.pdb'' respectively.

To use a configuration file the {}``file'' tag in {}``initialize'' should be used.
This will take an input file with a given name and use it to initialize
all relevant data. Both of these formats have the atom
positions and labels, so this will initialize the positions, labels
and masses of all the particles in the system, with the masses being
implicitly set based on the atom label. The pdb configuration file
will also be used to set the cell parameters.

Let us take these two file types in turn, and form the appropriate
input sections. First, the xyz file. 
There are two attributes which are relevant to the {}``file'' tag
for our current problem, {}``mode'' and {}``units''.
{}``mode'' is used to describe what kind of data is being used to
initialize from, and so in this case will be {}``xyz''.
{}``units'' specifies which units the file is given in, and
so in this case is given by {}``angstrom'', which are the
standard units of both xyz and pdb files. 
For more information on the \ipi unit conversion libraries, 
and the available units, see \ref{inputunits}.

This then gives:

\begin{code}
<initialize nbeads='4'>
   <file mode='xyz' units='angstrom'> our_ref.xyz </file>
   ...
</initialize>
\end{code}

In this case, since the cell parameters are not specified in the
configuration file we must specify them separately. 
To initialize just the cell parameters, we use the tag {}``cell''.
These could in theory be set using a separate
file, but here we will initialize them manually. Taking a cubic cell
with cell parameter 17.847 angstroms, we can specify this using
the {}``cell'' tag in three different ways:

\begin{code}
<cell mode='manual' units='angstrom'> 
   [17.847, 0, 0, 0, 17.847, 0, 0, 0, 17.847] 
</cell>
\end{code}

\begin{code}
<cell mode='abcABC' units='angstrom'>
   [17.847, 17.847, 17.847, 90, 90, 90]
</cell>
\end{code}

\begin{code}
<cell mode='abc'>
   [17.847, 17.847, 17.847]
</cell>
\end{code}

Note the use of the different {}``mode'' attributes, {}``manual'',
{}``abcABC'' and {}``abc''. The first creates the cell vector
matrix manually, the second takes the length of the three unit vectors
and the angles between them in degrees, and the last assumes an orthorhombic
cell and so only takes the length of the three unit vectors as arguments.
We will take the last version for brevity, giving as our final {}``initialize''
section:

\begin{code}
<initialize nbeads='4'>
   <file mode='xyz' units='angstrom'> our_ref.xyz </file>
   <cell mode='abc' units='angstrom'>
      [17.847, 17.847, 17.847]
   </cell>
   ...
</initialize>
\end{code}

The pdb file is specified in a similar way, except that no {}``cell''
tag needs be specified and the {}``mode'' tag should be
set to {}``pdb'':

\begin{code}
<initialize nbeads='4'>
   <file mode='pdb' units='angstrom'> our_ref.pdb </file>
   ...
</initialize>
\end{code}

As well as initializing all the atom positions, this section
can also be used to set the atom velocities. Rather than setting these manually,
it is usually simpler to sample these randomly from a Maxwell-Boltzmann
distribution. This can be done using the
{}``velocities'' tag by setting the {}``mode'' attribute to {}``thermal'':

\begin{code}
<initialize nbeads='4'>
   <file mode='pdb' units='angstrom'> our_ref.pdb </file>
   <velocities mode='thermal' units='kelvin'> 50 </velocities>
</initialize>
\end{code}

Next lets consider the {}``forces'' section, which deals with communication
with the client codes. Since in this case we only have one type of
client code which will be using sockets for communication, we will
specify a single {}``sockets'' tag to initialize it:

\begin{code}
<forces>
   <socket>
      ...
   </socket>
</forces>
\end{code}

A socket is specified with three parameters; the port number, the
hostname and whether it is a unix or an internet socket. 
These are specified by the {}``port'' and {}``hostname tags
and the {}``mode'' attribute respectively.
To match up with the client socket specified above,
we will take an internet socket on the hostname localhost and
using port number 31415. 

This gives the final {}``forces'' section:

\begin{code}
<forces>
   <socket mode="inet">
      <hostname> localhost </hostname>
      <port> 31415 <\port>
   </socket>
</forces>
\end{code}

The next section that we will need is the ensemble, which determines
how the dynamics integrator will be initialized. Since we wish to
do a \emph{NVT} simulation, we set the {}``mode'' attribute to {}``nvt'',
and must specify the temperature using the appropriate tag:

\begin{code}
<ensemble mode='nvt'>
   <temperature units='kelvin'> 25 </temperature>
   ...
</ensemble>
\end{code}

This defines the ensemble that will be sampled. We also must decide
which integration algorithm to use, and how large the time step should
be. In general, the time step should be made as large as possible
without there being a drift in the conserved quantity. Usually we
would take a few short runs with different time steps to try and optimize
this, but for the sake of this tutorial we will use a safe value of
1 femtosecond, giving:

\begin{code}
<ensemble mode='nvt'>
   <temperature units='kelvin'> 25 </temperature>
   <timestep units='femtosecond'> 1 </timestep>
   ...
</ensemble>
\end{code}

Finally, while the free-particle evolution part of the integrator
is initialized automatically, there are several different options
for the constant temperature sampling algorithm. For simplicity we
will take the path-integral Langevin equation (PILE) algorithm \cite{ceri+10jcp},
which is specifically designed for path integral simulations, and
since we are trying to equilibrate local properties we will take the
local version of this, {}``pile\_l''. This integrator also has to
be initialized with a time scale parameter, {}``tau'', which determines
how strong the thermostat is. Since we have a local thermostat the
appropriate time scales will be fairly short, so we will take a short
time scale of 1000 atomic time units. Putting all of this together,
we get the final input file:

\begin{code}
<simulation>
   <initialize nbeads='4'>
      <file mode='xyz'> our_ref.xyz </file>
      <cell mode='abc'>
         [33.72594, 33.72594, 33.72594]
      </cell>
   </initialize>
   <forces>
      <socket mode="unix">
         <hostname> localhost </hostname>
      </socket>
   </forces>
   <ensemble mode='nvt'>
      <temperature> 25 </temperature>
      <timestep> 40 </timestep>
      <thermostat mode='pile_l'>
         <tau> 1e3 </tau>
      </thermostat>
   </ensemble>
</simulation>
\end{code}


\subsubsection{Running the simulation}

\label{run1}

Now that we have a valid input file, we can run the test simulation.
The {}``i-pi'' script in the root directory is used to create an
\ipi simulation from a xml input file. As explained in
\ref{runningsimulations} (if we assume that we are in the {}``tutorial-0''
directory) this script is run using:

\begin{code}
> python ../../../i-pi tutorial-0.xml
\end{code}

This will start the \ipi simulation, creating the server socket and
initializing the simulation data. This should at this point print
out a header message to standard output, followed by a few information
messages that end with {}``starting the polling thread main loop'',
which signifies that the server socket has been opened and is waiting
for connections from client codes.

At this point the driver code is run in a new terminal 
from the {}``drivers'' directory using the command
specified above:

\begin{code}
> ./driver.x -m sg -u -h localhost -o 15
\end{code}

The wrapper code should now output a message saying that a new client
code has connected, and start running the simulation.


\subsubsection{Output data}

Once the simulation is finished (which should take about a minute)
it should have output, by default, one file called {}``i-pi.checkpoint''
and one called {}``RESTART'' which have the state of the system
saved as it was at the end of the calculation, one file called {}``i-pi.md''
which contains a log of the values of some of the simple properties
of the system throughout the simulation, and a set of files {}``i-pi.pos\_x.xyz''
which give the positions of the different replicas of the system at
regular intervals. For an in-depth discussion on these three types
of output files see \ref{outputfiles}, but for now let us look at
each of these specific output files in turn.

First, consider the file {}``i-pi.checkpoint''. As said above, this
gives a snapshot of the state of the simulation. Since we didn't specify
how often to print out this file the default value of once every 1000
time steps was used, so in this case the last checkpoint was created
at step 999. This type of file is designed to be a way of restarting
the simulation, by using it as an input file for a new \ipi simulation. 
This is done in exactly the same way as before, i.e.:

\begin{code}
> python ../../../i-pi i-pi.checkpoint
\end{code}

The RESTART file is the same type of file, except this is automatically
generated at the end of the simulation regardless of what is
specified in the input file.

The next set of files to consider are the trajectory files
{}``i-pi.pos\_x.xyz''. Trajectory files are used to print out properties
relevant to all the atoms individually, such as the velocities or forces.
In this case, these give the positions of the 
beads at various snapshots throughout the simulation. These can be useful
for calculating correlation functions or radial distribution functions,
but possibly their most useful feature is that visualization
programs such as VMD can read them, and then use the data to show
a movie of how the simulation is progressing. 

If we do this with these files, we see that the simulation started
from an essentially optimized configuration and then over the course
of the simulation began to melt. Given that at the state point studied
and with the potential given para-hydrogen is a liquid \cite{silv-gold78jcp},
this is what we would expect.

Finally, let us consider the {}``i-pi.md'' file. This is a print out
of the system level properties, and by default we get one file which
prints out the timestep, elapsed time, conserved quantity, temperature,
potential energy and kinetic energy of the system.

At this point there are two simple tests that should be done. Firstly,
we should check that the conserved quantity does not exhibit any major
drift, and second we should check to see if the properties of interest
have converged yet. The file format has been chosen so that programs 
such as awk and gnuplot can read the data easily. In this case, gnuplot
can show how the conserved quantity, temperature, potential energy
and kinetic energy change throughout the simulation using:

\begin{code}
> gnuplot
> p './i-pi.md' u 1:3 # Plots column 1, i.e. timestep, 
> p './i-pi.md' u 1:4 # against columns 3, 4, 5 and 6,
> p './i-pi.md' u 1:5 # i.e. conserved quantity, temperature,
> p './i-pi.md' u 1:6 # kinetic energy and potential energy
\end{code}

This will show that the conserved quantity has only a small drift upwards,
so the time step is sufficiently small, and that the temperature has converged
but the kinetic and potential energies have not.
We therefore need to adjust the input parameters to converge these properties
properly, as will be done in the next section.

In Part 0, we created a minimal input file which could be used to
run a basic \emph{NVT} simulation. However, this ignored several non-essential
but very useful bits of functionality, which are likely to be 
important for most problems users will face. With this in mind,
we now present some impovements to the original input file. 

\subsubsection{Improving convergence and simulation technicalities}

Firstly, we will discuss the input parameters that are necessary for
the simulation to actually do what we originally intended it to
correctly, namely equilibate a small system in the \emph{NVT} ensemble.

We noted at the end of the last run that the simulation did not appear to have
fully converged. Often in this case it will be necessary to adjust the parameters
of the integrators, such as the time step and the thermostat timescale.
However, in this case there are a couple of much simpler ways to
help improve the convergence which were neglected previously, so we will now
concentrate on these.

The most obvious first step is to run the simulation for longer. 
By default the number of
time steps is 1000, so we will increase this to 5000 using the 
{}``total\_steps'' tag:

\begin{code}
<total_steps> 5000 </total_steps>
\end{code} 

One small technicality that can become important if multiple similar
simulations are run is that, to ensure each run is independent, the 
random number generator should be initialized with different
seeds for each. This is simply done using the
{}``prng'' tag, as follows:

\begin{code}
<prng> <seed> 31415 </seed> </prng>
\end{code}

\subsubsection{Simplifying the input file}

Some of the functionality of \ipi is designed to make it easier to use rather
than to improve the performance of the code. One example of this is the
unit conversion library. If appropriate, the input classes have a {}``dimension''
parameter which is used to define their dimensionality.
These variables can then be specified with a {}``units'' attribute
in the input file, which
the xml reading functions can use to automically convert between a 
user specified unit and atomic units. 
For example, the time step we used in tutorial 0
was 40 atomic time units, but we might instead want to express this in S.I.
units for comparison with another paper. Since this happens to be approximately
1 femtosecond, so we can instead use:

\begin{code}
<ensemble mode='nvt'>
   <timestep units='femtosecond'> 1 </timestep>
   ...
</ensemble>
\end{code}
 
Similarly, we might want to specify the input configuration file in
angstrom rather than \(a_0\) (in fact this is the standard unit for
this file type). This can be done in the same way:

\begin{code}
<initialize nbeads='4'>
   <file mode='xyz' units='angstrom'> our_ref.xyz </file>
   <cell mode='abc' units='angstrom'>
      [33.72594, 33.72594, 33.72594]
   </cell>
   <velocities mode='thermal'> 50 </velocities>
</initialize>
\end{code}

Using this, the initialize section is reduced to:

\begin{code}
<initialize nbeads='4'>
   <file mode='pdb' units='angstrom'> our_ref.pdb </file>
   <velocities mode='thermal'> 50 </velocities>
</initialize>
\end{code}

Note that an appropriately formatted pdb file is included with the
{}``tutorial 1'' directory as before.

\subsubsection{Customizing the output}

In the first tutorial only the default output was generated since 
nothing had been specified by the user. There are however a wide
variety of properties of interest that \ipi can calculate 
and a large number of different output
options, so in most cases you will want to specify what is output
manually.

Firstly, the amount of data sent to standard output can be adjusted
with the {}``verbosity'' attribute of {}``simulation'':

\begin{code}
<simulation verbosity='high'>
   ...
</simulation>
\end{code}

By default the verbosity is set to {}``low'', which only outputs
important warning messages and information, and some statistical 
information every 1000 time steps. Here we will set it to 
{}``high'', which should give output of the type:

\small
\begin{code}
 # Average timings at MD step S. t/step: TOTAL [p: P q: Q t: T]
 # MD diagnostics: V: POTENTIAL Kcv: KINETIC Ecns: CONSERVED
 @SOCKET: Assigning [ X ] request id ID to client with last-id LID ( CID/ CTOT : )
\end{code}
\normalsize
where the output values have been replaced with the following:
\begin{description}
\item [{S:}] This gives the current time step.
\item[{TOTAL:}] This gives the amount of time the current time step took.
\item [{P:}] This gives how long the momentum propagation step took.
\item [{Q:}] This gives how long the free-ring polymer propagation step took.
\item [{T:}] This gives how long the thermostat integration step took.
\item [{POTENTIAL:}] This gives the current potential energy of the system.
\item [{KINETIC:}] This gives the current kinetic energy of the system.
\item [{CONSERVED:}] This gives the current conserved quantity.
\item [{X:}] This says whether or not \ipi found a match for the calculation of 
replica ID or not.
If one of the connected client codes calculated the forces for this replica on the
last time step, then X will be {}``match'', and \ipi will automatically assign
this replica to the same client as before. This should happen with all the replicas
if CTOT is the same as the number of beads.
\item [{ID:}] The index of the replica currently being assigned to a client code.
\item [{LID:}] The index of the replica which the client code last did a force calculation
of.
\item [{CID:}] The index of the client code in the list of all connected client codes.
\item [{CTOT:}] The total number of connected client codes.
\end{description}

What output gets written to file is specified by the {}``output'' tag.
There are three types of files, as explained in tutorial 0, 
properties files, trajectory files and checkpoint files, which 
are specified with {}``properties'', {}``trajectory'' 
and {}``checkpoint'' tags respectively.
As an example, the default output would be generated with
the following {}``output'' section:

\begin{code}
<output prefix='i-pi'>
   <properties filename='md' stride='10'>
      [time, step, conserved, temperature, potential, kinetic_cv]
   </properties>
   <trajectory filename='pos' stride='100' format='xyz'>
      positions
   </trajectory>
   <checkpoint filename='checkpoint' stride='1000' overwrite='True'/>
</output>
\end{code}

As seen in tutorial 0, this creates 6 files: {}``i-pi.md'', {}``i-pi.pos\_0.xyz'',
{}``i-pi.pos\_1.xyz'', {}``i-pi.pos\_2.xyz'', {}``i-pi.pos\_3.xyz''
and {}``i-pi.checkpoint''. 
The filenames are created using the syntax 
{}``prefix''.{}``filename''[\_(file specifier)][.(file format)], where the file specifier is
added to separate similar files. For example, in the above case the 
different position trajectories for each bead are given a file specifier
corresponding to the appropriate bead index.

The {}``stride'' attributes set how often data is output to each file;
so in the above case the properties are written out every 10 time steps,
the trajectories every 100, and the checkpoints every 1000.
The {}``format'' attribute sets the format of the trajectory files,
and the {}``overwrite'' attribute sets whether each checkpoint file 
overwrites the previous one or not.

There are several options we can use to customize the
output data. Firstly, the {}``prefix'' attribute should be set to
something which can be used to distinguish the files from different
simulation runs. In this case we can simply set it to {}``tut1'':

\begin{code}
<output prefix='tut1'>
   ...
</output>
\end{code}

As for the input parameters, the units the output is given in can be
set by the user. Unlike the input parameters however, 
this is done by specifying an
appropriate unit in curly braces after the name of the 
property or trajectory of interest, as shown below:

\begin{code}
<output prefix='tut1'>
   <properties filename='md' stride='10'>
      [step, time{picosecond}, conserved{kelvin}, 
       temperature, potential{kelvin}, kinetic_cv{kelvin}] 
   </properties>
   <trajectory filename='pos' stride='100' format='xyz'>
      positions{angstrom} 
   </trajectory>
   <checkpoint filename='checkpoint' stride='1000' overwrite='True'/>
</output>
\end{code}

Next, let us adjust some of the attributes. Let us suppose that we
wish to output the properties every time step, to check for conserved
quantity jumps, and to output the the trajectory in pdb format.
To do this we would set the {}``stride'' and {}``format'' tags,
as shown below:

\small
\begin{code}
<output prefix='tut1'>
   <properties filename='md' stride='1'>
      [step, time{picosecond}, conserved{kelvin}, 
       temperature, potential{kelvin}, kinetic_cv{kelvin}] 
   </properties>
   <trajectory filename='pos' stride='100' format='pdb' cell_units='angstrom'>
      positions{angstrom} 
   </trajectory>
   <checkpoint filename='checkpoint' stride='1000' overwrite='True'/>
</output>
\end{code}
\normalsize

Note that we have added a {}``cell\_units'' attribute
to the {}``trajectory'' tag, so that the
cell parameters are consistent with the position output.

Finally, let us suppose that we wished to output another output property
to a different file to the others. One example of when this 
might be necessary if there
is one output property which was more expensive to calculate than the
others, and so it would be impractical to output it every time step.
With \ipi this is easy to do, all that is required is to add another
{}``properties'' tag with a different filename.

For demonstration purposes, we will chose to print out the forces
acting on one tagged bead, since this requires an argument to be
passed to the function. The \ipi syntax for doing this is to have
the arguments to be passed to the function between standard braces,
separated by semi-colons.

To print out the forces acting on one bead we need the {}``atom\_f''
property, which takes two arguments, {}``atom'' and {}``bead'',
giving the index of the atom and bead tagged respectively. The
appropriate syntax is then given below:

\begin{code}
<properties> 
   [atom_f(atom=0;bead=0)] 
</properties>
\end{code}

This will print out the force vector acting on bead 0 of atom 0.
\ipi also accepts positional arguments
(i.e. arguments not specified by a name, but just by their position
in the list of arguments), and so this could also be written as:

\begin{code}
<properties> 
   [atom_f(0;0)] 
</properties>
\end{code}

Finally, putting all this together, and adjusting some
of the parameters of the new file, we get:

\small
\begin{code}
<output prefix='tut1'>
   <properties filename='md' stride='1'> 
      [step, time{picosecond}, conserved{kelvin}, 
       temperature, potential{kelvin}, kinetic_cv{kelvin}] 
   </properties>
   <properties filename='force' stride='20'> 
      [atom_f{piconewton}(atom=0;bead=0)] 
   </properties>
   <trajectory filename='pos' stride='100' format='pdb' cell_units='angstrom'> 
      positions{angstrom} 
   </trajectory>
   <checkpoint filename='checkpoint' stride='1000' overwrite='True'/>
</output>
\end{code}
\normalsize

\subsubsection{Equilibration run}

Now that we have adjusted the input file to our satisfaction, we can
re-run the simulation by 
repeating the steps in \ref{run1}. The output of the 
{}``tut1.md'' file should show that all the properties of interest
have converged by the end of the simulation. If this
is the case, then we are now ready to start the \emph{NPT} run.

\subsection{Part 2 - \emph{NPT} simulation}

Now that we have converged \emph{NVT} simulation data, we can use this to
initialize a \emph{NPT} simulation. There are two ways of doing this,
both of which involve using the RESTART file generated at
the end of the \emph{NVT} run as a starting point.

\subsubsection{Modifying the RESTART file}

Firstly, you can use the RESTART file directly, modifying it
so that instead of continuing with the original \emph{NVT} simulation
it will instead it will start a new \emph{NPT} simulation. We have included
in the {}``tutorial 2'' directory both a RESTART file from
tutorial 1 and an adjusted file which will run \emph{NPT} dynamics.

These adjustments start with resetting the {}``step'' tag, so that
it starts with the value 0. This can be done by simply removing the
tag. Similarly, we can increase the total number of
steps so that it is more suitable for collecting the necessary
amount of data, in this case we will set the 
{}``total\_steps'' to 20000.

We will also update the output files, first by setting the filenames
to start with {}``tut2a'' rather than {}``tut1'', and secondly by adding
the volume and pressure to the list of computed propertie so that
we can check that the ensemble is being sampled correctly.
Putting this together this gives:

\small
\begin{code}
<output prefix=''>
   <properties shape='(8)' filename='tut2a.prop'>
      [ step, time{picosecond}, conserved{kelvin}, 
        temperature, potential{kelvin}, kinetic_cv{kelvin}, 
        pressure_cv{megapascal}, volume ] 
   </properties>
   <properties stride='20' shape='(1)' filename='tut2a.force'> 
      [ atom_f{piconewton}(atom=0;bead=0) ] 
   </properties>
   <trajectory filename='tut2a.pos' stride='100' format='pdb' cell_units='angstrom'>
      positions{angstrom}
   </trajectory>
   <checkpoint stride='1000' filename='tut2a.restart'/>
</output>
\end{code}
\normalsize

Finally, we must change the {}``ensemble'' tag so that the correct
ensemble is sampled. The first thing that must be done is  
the {}``mode'' tag must be changed from {}``nvt'' to {}``npt'',
and a {}``pressure'' tag must be added:

\begin{code}
<ensemble mode='npt'>
   <pressure> 0 <pressure>
   ...
</ensemble>
\end{code}

We must also specify which constant pressure algorithms are to be used.
\ipi contains two barostats, labelled {}``mht'' and {}``bzp''. These are
broadly similar, but use slightly different integration algorithms.
In this case, we will use {}``bzp''. This gives:

\begin{code}
<ensemble mode='npt'>
   <pressure> 0 <pressure>
   <barostat mode='bzp'>
      ...
   </barostat>
   ...
</ensemble>
\end{code}

This barostat also requires a 
thermostat to deal with the volume degree of freedom, which we will take
to be a simple Langevin thermostat.
This thermostat is specified in the same way as the one which does the
constant temperature algorithms for the atomic degrees of freedom, and
we will take its time constant to be 10000 atomic time units:

\begin{code}
<ensemble mode='npt'>
   <pressure> 0 <pressure>
   <barostat mode='bzp'>
      <thermostat mode='langevin'>
         <tau> 1e4 </tau>
      </thermostat>
      ...
   </barostat>
   ...
</ensemble>
\end{code}

Finally, we will take the barostat time scale to be 10000 atomic time
units, giving:

\begin{code}
<ensemble mode='npt'>
   <pressure> 0 <pressure>
   <barostat mode='bzp'>
      <thermostat mode='langevin'>
         <tau> 1e4 </tau>
      </thermostat>
      <tau> 1e4 </tau>
   </barostat>
   ...
</ensemble>
\end{code}
with the rest of the {}``ensemble'' tag being the same as before.

\subsubsection{Initialization from RESTART}

A different way of initializing the simulation is to use the 
RESTART file as a configuration file, in the same way that
the xyz/pdb files were used previously.

Firstly, the original input file {}``tutorial-1.xml'' needs to
be modified so that
it will do a \emph{NPT} simulation instead of \emph{NVT}. This involves modifying
the {}``total\_steps'', {}``output'' and {}``ensemble'' tags as
above. Next, we replace the {}``initialize'' tag section with:

\begin{code}
<initialize nbeads='4'>
   <file mode='chk'> tutorial-1_RESTART </file>
</initialize>
\end{code}

Note that the {}``mode'' attribute has been set to {}``chk''
to specify that the file is a checkpoint file.
This will then use the RESTART file to initialize the bead
configurations and velocities and the cell parameters.

\subsubsection{Running the simulation}

Whichever method is used to create the input file, the simulation
is run in the same way as before. 
Note how the volume fluctuates with time, as it is no longer held
constant in this ensemble.

\subsection{Part 3 - A fully converged simulation}

As a final example, we note that at this state point 16 replicas
and at least 172 particles are actually 
required to provide converged results.
As a last tutorial then, you should repeat tutorials 1 and 2 with
this number of replicas and atoms. The directory {}``tutorial 3'' contains 
\emph{NVT} and \emph{NPT} input files which can be used to do a fully converged
\emph{NPT} simulation from scratch, except that they are missing some
of the necessary input parameters.

If these are chosen correctly and the simulation is run properly
the volume will be 31 \(\textrm{cm}^3\)/mol and the total energy
should be -48 K \cite{mart+99jcp}.


\section{Testing the install}

\label{tests}

Several test cases are distributed with the code to ensure that your
distribution is working correctly. There are also simple tests to
see if the client codes are working correctly.

All the input files are contained in the directory test, which is
subdivided into the following directories:
\begin{description}
\item [{lj:}] This gives a simple classical Lennard-Jones simulation of
Ne. The state points are given by (\(N\), \(\rho\), \(T\)) = (864, 0.35,
1.62), (\(N\), \(\rho\), \(T\)) = (864, 0.75, 1.069) and (\(N\), \(\rho\), \(T\))
= (864, 0.88, 1.095) in reduced Lennard-Jones units, so that the results
can be compared to those in the paper \cite{lverlet67pr}.
\item [{ph2:}] This simulates para-hydrogen using the isotropic Silvera-Goldman
pair potential. There are three directories, {}``RPMD'', {}``nvt''
and {}``Tuckerman''. {}``RPMD'' and {}``nvt'' have tests which
can be compared to the results of \cite{mill-mano05jcp}, and {}``Tuckerman''
has tests which can be compared to the results of \cite{mart+99jcp}.
\item [{pwscf:}] This has two simple examples to test to see if the Quantum-Espresso
client is functioning correctly. There is one simple 4-atom lithium
test, and a test using a single water molecule.
\item [{harmonic:}] This has a simple example of a 1D harmonic oscillator.
This demonstrates the displaced path integral momentum distribution
estimator as given in \cite{linlin+10prl}. As the momentum distribution
is known analytically for this simple system, this provides an indication
of how well the method is working.
\item [{lammps:}] This has a simple implementation of the q-TIP4P-F empirical
water model of \cite{habe+09jcp} using the classical molecular dynamics
code LAMMPS. It demonstrates both the convergence of the PIGLET method
\cite{ceri-mano12prl}, as well as the use of ring-polymer contraction
methods \cite{mark-mano08jcp}.
\end{description}

\chapter{User guide}

\label{user}


\section{Input files}


\subsection{Input file format and structure}

\label{ifilestructure}

In order to give the clearest layout, xml formatting was chosen as
the basis for the for the main input file. An xml file consists of
a set of hierarchically nested tags. There are three parts to an xml
tag. Each tag is identified by a tag name, which specifies the class
or variable that is being initialized. Between the opening and closing
tags there may be some data, which may or may not contain other tags.
This is used to specify the contents of a class object,
or the value of a variable. Finally tags can have attributes,
which are used for metadata, i.e. data used to specify
how the tag should be interpreted. As an example, attributes
are often used to choose between different classes which can
be used for the same thing, such as the thermostat classes. 

A xml tag has the following syntax:

\begin{code}
<tag_name attribute_name='attribute_data'>tag_data</tag_name>
\end{code}

The syntax for the different types of tag data is given below: 
{\color{red}??? USE MONO FONTS IN THE TABLE, TO MATCH THE CODE ENVIRONMENT}

\begin{center}
\begin{tabular}{cc}
\hline\hline
Data type & Syntax\\
\hline 
Boolean & <tag>True</tag> or <tag>False</tag>\\
Float & <tag>11.111</tag> or <tag>1.1111e+1</tag>\\
Integer & <tag>12345</tag>\\
String & <tag>string\_data</tag>\\
Tuple & <tag> (int1, int2, \ldots )</tag>\\
Array & <tag> {[} entry1, entry2, \ldots {]} </tag>\\
Dictionary & <tag>\{name1: data1, name2: data2, \ldots \}</tag>\\
\hline\hline
\end{tabular}
\end{center}

Note that arrays are always given as one-dimensional lists. In cases
where a multi-dimensional array must be entered, one can use the `shape'
attribute, that determines how the list will be reshaped into a multi-dimensional
array. For example, the bead positions are
represented in the code as an array of shape 
(number of beads, 3*number of atoms). If we take a system with 20 atoms
and 8 beads, then this can be represented in the xml input file as:

\begin{code}
<beads natoms='20' nbeads='8'>
   <q shape=`(8,60)'>[ q11x, q11y, q11z, q12x, q12y, ... ]</tag>
   ...
\end{code}

If `shape' is not specified, a 1D array will be assumed.

The code uses the hierarchical nature of the xml format to help read the data; if
a particular object is held within a parent object in the code, then
the tag for that object will be within the appropriate parent tags.
This is used to make the structure of the simulation clear. 

For example,
the system that is being studied is partly defined by the thermodynamic
ensemble that should be sampled, which in turn may be partly defined
by the pressure, and so on. To make this dependence clear in the code
the global simulation object which holds all the data contains
an ensemble object, which contains a pressure variable.
 
Therefore the input file is specified
by having a {}``simulation'' tag, containing an {}``ensemble''
tag, which itself contains a {}``pressure'' tag, which will contain
a float value corresponding to the external pressure. In this
manner, the simulation class structure can be constructed iteratively.

As a specific example, suppose we want to generate a \emph{NPT} ensemble at an external
pressure of 1e-7 atomic pressure units. This would be specified by
the following input file: 

\begin{code}
<simulation>
   <ensemble mode='npt'>
      <pressure> 1e-7 </pressure>
      ...
   </ensemble>
   ...
</simulation>
\end{code}

To help detect any user error the recognized tag names, data types
and acceptable options are all specified in the code in a specialized
input class for each class of object. A full list of all the available
tags and a brief description of their function is given in chapter~\ref{hierarchy}.


\subsubsection{Overwriting units}

\label{inputunits}

Many of the input parameters, such as the pressure in the above example,
can be specified in more than one unit. Indeed, often the atomic unit
is inconvenient to use, and we would prefer something else. Let us
take the above example, but instead take an external pressure of 3
MPa. Instead of converting this to the atomic unit of pressure, it
is possible to use pascals directly using:

\begin{code}
<simulation>
   <ensemble mode=`npt'>
      <pressure units=`pascal'> 3e6 </pressure>
      ...
   </ensemble>
   ...
</simulation>
\end{code}

The code can also understand S.I. prefixes, so this can be simplified
further using:

\begin{code}
<simulation>
   <ensemble mode='npt'>
      <pressure units=`megapascal'> 3 </pressure>
      ...
   </ensemble>
   ...
</simulation>
\end{code}

A full list of which units are defined for which dimensions
can be found in the units.py module.


\subsection{Initialization section}


\subsubsection{Configuration files}

\label{configfile}

%Mano's note: Add example from tutorial

Instead of initializing the atom positions manually, the starting
configuration can be specified through a separate data file. The name
of the configuration file is specified within the {}``initialize''
tag name with the {}``mode'' attribute given by the file format.
The currently accepted file formats are:
\begin{itemize}
\item pdb
\item xyz
\end{itemize}
This file can be used either to initialize one variable only, or instead
to initialize multiple attributes by using the {}``file'' tag name.
This will initialize the atom positions, labels, masses and possibly
the cell parameters together.


\subsubsection{Initialization from checkpoint files}

%Mano's note: Add example from tutorial

\ipi gives the option to output the entire state of the system at
particular timesteps as an xml input file, called a checkpoint file
(see \ref{checkpoint} for details). As well as being a valid input
file, a checkpoint can also be used as an input data file in the same
way that the configuration files are. This is specified in the input
by using {}``chk'' as the value of the {}``mode'' attribute. As
for the configuration file, a checkpoint file can be used to initialize
either one or many variables depending on which tag name is used.

There is also an ensemble type, {}``replay'', which takes a configuration
file with multiple frames or a checkpoint file with one frame and
reruns it without doing dynamics, by simply setting the configuration
to match that given by the input file at each frame. This can then
be used to calculate properties of interest along a trajectory that
has already been finished, if the user forgot to calculate them the
first time around.


\section{Output files}

\label{outputfiles}

%Mano's note: Add example from tutorial

\ipi uses a very flexible mechanism to specify how and how often
atomic configurations and physical properties should be output. Within
the {}``output'' tag of the xml input file the user can specify
multiple tags, each one of which will correspond to a particular output
file. Each file is managed separately by the code, so what is output
to a particular file and how often can be adjusted independently of
the same parameters for a different file. It is also possible to have
multiple instances of the same type of file.

For example, some of the possible output properties require more than
one force evaluation per time step to calculate, and so can considerably
increase the computational cost of a simulation. On the other hand,
for properties such as the conserved energy quantity it is easy, and
often useful, to output them every time step as they are simple to
compute and do not take long to output to file. In this case it is
most efficient to only output the expensive property rarely, which
would be done by outputting this to a different file to the ones that
are being used to keep track of the conserved quantity, and use a
larger number of time steps between successive writes to this file.

There are three types of output file that can be specified; property
files for system level properties, trajectory files for atom/bead
level properties and checkpoint files which save the state of the
system and so can be used to restart the simulation from a particular
point. These will now be considered in turn.


\subsection{Properties}

\label{propertyfile}

This is the output file for all the system and simulation level properties,
such as the total energy and the time elapsed. It is designed to 
track a small number of important properties throughout a
simulation run, and as such has been formatted to be used as input
for plotting programs such as gnuplot.

The file starts with
a header, which describes the properties being written in the different
columns and their output units. This is followed by the actual
data. Each line corresponds to one instant of the simulation, and
the different columns match the description provided in the header.
The file is fixed formatted, with two blank characters at the start
of each row, then the data in the same order as the header row. Each
column is 16 characters wide and every float is written in exponential
format with 8 digits after the decimal point.

%Mano's note: Add an example of a header file here...

The properties that are output are determined by the {}``properties''
tag in the xml input file. The format of this tag is:

\begin{code}<properties stride=`' filename=`' flush=`' shape=`'>
   [ prop1name{units}(arg1; ... ), prop2name{...}(...), ...  ]
</properties>\end{code}

The attributes have the following meanings:
\begin{description}
\item [{stride}] The number of steps between each output to file
\item [{filename}] The name of the output file
\item [{flush}] The number of steps between flushing the buffer
\item [{shape}] The number of properties in the list.
\end{description}
The tag data is an array of strings, each of which contains three
different parts:
\begin{itemize}
\item The property name, which describes which type of property is to be
output. This is a mandatory part of the string.
\item The units that the property will be output in. These are specified
between curly brackets. If this is not specified, then the property
will be output in atomic units. Note that some properties can only
be output in atomic units.
\item The arguments to be passed to the function. These are specified between
standard brackets, with each argument separated by a semi-colon. These
may or may not be mandatory depending on the property, as some arguments
have well defined default values. The arguments
can be specified by either of two different syntaxes, (name1=arg1;
\ldots ) or (arg1; \ldots ). 

The first syntax uses keyword arguments. The above example would set the variable
with the name {}``name1'' the value {}``arg1''. 
The second syntax uses positional arguments. This syntax
relies on the arguments being specified in the correct order, as defined
in the relevant function in the property.py module, since the user has
not specified which variable to assign the value to. 

The two syntaxes
may be mixed, but positional arguments must be specified first otherwise
undefined behaviour will result. If no arguments are specified, then
the defaults as defined in the properties.py module will be used.
\end{itemize}
The different available property names are:

\input{input_docs/property_list}

\subsection{Trajectory files}

These are the output files for atomic or bead level properties, such
as the bead positions. This will output data for each degree of
freedom, in a format that can be read by visualization packages
such as VMD.

Each trajectory that should be output is specified
by the {}``trajectory'' tag in the input file. The allowable file
formats for the trajectory output files are the same as for the configuration
input files, given in~\ref{configfile}.

These tags have the format:

\begin{code}
<trajectory stride=`' filename=`' format=`' cell_units=`' flush=`' bead=`'>
   traj_name{units}(arg1;...)
</trajectory>
\end{code}

This is very similar to the {}``properties'' tag, except that it has the
additional tags {}``format'' and {}``cell\_units'', and only one
trajectory can be specified per file. `format' specifies the format
of the output file, and `cell\_units' specifies the units in which
the cell dimensions are output. Depending on the chosen trajectory
to output, it will either print a file per bead or per atom. If the
trajectory is output per bead then the output files will be {}``filename''
with the bead index appended, so as to distinguish between the trajectories
of each bead. In this case it is also possible to only output one
trajectory by specifying the {}``bead'' attribute. 

The possible choices of output trajectories are:

\input{input_docs/trajectory_list}


\subsection{Checkpoint files}

\label{checkpoint}

As well as the above output files, the state of the system at a particular
time step can also be saved to file. These checkpoint files can later be
used as input files, with all the information required to restore
the state of the system to the point at which the file was created. 

The syntax for this tag is:

\begin{code}<checkpoint stride=`' filename=`' overwrite=`'>
   step
</checkpoint>\end{code}

Again, this is similar to the {}``trajectory'' and {}``properties''
tags, but instead of having a value which specifies what to output,
the value simply gives a number to identify the current checkpoint
file. There is also one additional attribute, {}``overwrite'', which
specifies whether each new checkpoint file overwrites the old one,
or whether all checkpoint files are kept. If they are kept, they will
be written not to the file {}``filename'', but instead an index
based on the value of {}``step'' will be appended to it to distinguish
between different files.

If the `step' parameter is not specified, the following syntax can
also be used:

\begin{code}<checkpoint stride=`' filename=`' overwrite=`'/>\end{code}


\subsubsection{Soft exit and RESTART}

As well as checkpoint files during a simulation run, \ipi{} also
creates a checkpoint automatically at the end of the simulation, with
file name {}``RESTART''. In the same way as the checkpoint files generated 
above it contains the state of the system
as created by the wrapper, but it does not need to be asked for by
the user in the input file. Its purpose is that if the user decides
that insufficient steps were used in an already completed simulation,
then this file can be used to continue from where it ended.

To stop the program in such a way that it makes sure to save the data
generated in a restart file, simply create a file {}``EXIT'' in
the directory in which the code is running. The thread handler will
automatically detect this and safely shut down the program, outputting
the restart file as detailed above. 

An important point to note is that since each time step is split into
several parts, it is only at the beginning of each step that all the
variables are consistent with each other in such a way that the simulation
can be restarted from them without changing the dynamics. Thus if
a soft exit call is made during a step, then the restart file that
is created must correspond to the state of the system at the start
of the step. To this end, the state of the system is saved at the
start of every step.


\section{Distributed execution}

\label{distrib}

\subsection{Sockets}

\ipi only creates a server, it must interface with a client code
in order to run any simulations. The overarching design principle
of \ipi is that these two codes should be as independent as possible,
and so the only communication between them is done through a socket.
A socket is a data transfer device that is designed for internet communication,
so supports both multiple client connections to the same server and
two way communication. This makes sockets ideal for use in \ipi,
where each calculation may require multiple client codes. 

Sockets are described by an IP address and a port number, and can
either be an internet socket, capable of inter-computer communication,
or a unix socket, which is optimized for local communication. The
IP address is input by the user in the {}``address'' tag, and can
be specified in two ways. Firstly, every network has a unique numeric
code of the form 123.45.678.901. Secondly, most networks are named,
so the name of the network on which the server code is running can
be used as an alias for the IP address. A specific case of this is
{}``localhost'', which is the generic name for the local network
used by unix sockets.

The port number is an integer between 1 and 65535 used to distinguish
between all the different sockets open on a particular computer. As
many of the lower numbers are protected for use in important system
processes or internet communication, it is generally advisable to
only use numbers in the range 1025-65535 for simulations.

There are two modes of socket, internet and unix. Unix sockets are
optimized for local communication, whereas internet sockets can be
used to connect to one computer from another. While they are faster
than internet sockets, unix sockets should only be used if a simple
empirical potential is being run, since they are far less flexible.
Also, if complicated empirical potentials or \emph{ab initio} potentials
are used the force calculation becomes the bottleneck in the code,
so the advantage of using unix sockets is lost. 

Internet sockets have two main advantages that make them much more
useful in general. Firstly, the client code does not need to be run
on the same computer as the server code. In particular, if the client
codes are being run on a cluster this means that you do not need to
waste computing resources running the server, which is idle most of
the time. Secondly, the port number is not used for unix sockets,
so if more than one calculation is being run concurrently internet
sockets must be used, so that the client codes connect to the correct
server code.

There are a two other input parameters that may be used to specify
how the server socket looks for client codes to connect to. {}``latency''
specifies the length of time between each check to see if any new
client codes have connected, and {}``slots'' specifies how many
client codes can queue between checks. Neither is likely to be important
in getting the code to run, but may be used to optimize the connection
time if required.


\subsubsection{Data transfer}

Once at least one client code has connected to the server socket,
the force calculation can start. For this to happen the client code
needs the system configuration, and likewise the server needs the
force and potential data to be returned so that it can continue propagating
the dynamics.

To make sure that the connection is good, a simple query-response
data transfer protocol is used. Before any data is sent through the
socket a header string of 12 characters is sent to verify which stage
of the calculation the server is at. Once the client sends the appropriate
response header string, the data is transferred. If no response is
given, the server will either wait and try again, or disconnect the
client code and reassign its job to another, depending on the severity
of the problem. The server assumes that 4-bit integers, 8-bit floats
and 1-bit characters are used. A typical step is of the form:
\begin{enumerate}
\item A header string of {}``\textbf{STATUS}'' is sent by the server socket.
\item A header string is then returned, giving the status of the client
code. Recognized options are:

\begin{description}
\item [{{}``NEEDINIT'':}] If the client code needs any initialising data,
it can be sent here. The server code will then send a header string
{}``INIT'', followed by an integer corresponding to the bead index,
another integer giving the number of bits in
the initialization string, and finally the initialization string itself.
\item [{{}``READY'':}] Sent if the client code is ready to calculate
the forces. The server socket will then send a string {}``POSDATA'',
then nine floats for the cell vector matrix, then another nine floats
for the inverse matrix, (which need to be transposed if the client
code is written in fortran). The server socket will then send one
integer giving the number of atoms, then the position data as 3 floats
for each atom giving the 3 cartesian components of the atomic position.
\item [{{}``HAVEDATA'':}] This is sent if the client has calculated the
potential and forces. The server socket then sends a string {}``GETFORCE'',
and the client socket returns {}``FORCEREADY''. The potential is
then returned as a float, the number of atoms as an integer, then
the force data as 3 floats per atom in the same way as the positions,
and the virial as 9 floats in the same way as the cell vector matrix.
\end{description}
\item The server socket waits until the force data for each replica of the
system has been calculated and returned, upon which the 
molecular dynamics loop starts.
\end{enumerate}

\subsubsection{Parallelization}

As mentioned before, one of the primary advantages of using this type
of data transfer is that it allows multiple client codes to connect
to one server code, so that different replicas of the system can be
assigned to different client codes and their forces computed in parallel.
In fact it is trivially parallel, in the sense that no communication
between the client codes is necessary.

In the case that there are as many client codes as replicas of the
system this is very simple, as each replica will be assigned its own
client code. In subsequent steps, the interface will attempt to assign
a particular replica of the system to the client code which calculated
the forces for it in the last step. This reduces the change in the particle
positions between calculations for a particular client code, so the
next step is done more efficiently. In the case where there are fewer
client codes than beads, the socket interface will assign spare jobs
to the first client code that finishes running, after matching all
possible jobs to the same client code that calculated it last time
step.

This flexibility is especially useful when the calculations are being
run on a cluster, as in this case the client codes will connect whenever
they reach the front of the queue. More client codes can connect at
any time, and if there is a problem and any client code dies it is
simply disconnected from the server socket and any job it was running
reassigned.

Finally, note that many client codes can be parallelized themselves,
using MPI or other similar protocols. This is fully compatible with
\ipi, as it does not matter how the client does the calculation since
only the forces, potential and virial are sent to the server. Information
on how to run MPI processes can usually be found on the website of
the code provider if the client can be parallelized in this way.


\subsection{ssh tunnelling}

\label{ssh_sockets}

One problem that can often crop up when trying to run an \ipi calculation
is that there is a firewall around the network, especially when the
server code is being run on a cluster. This will often result in error
messages such as {}``Error connecting: Connection timed out'' or
{}``Error connecting: Connection refused''.

Let us suppose that the server code is running on a host network server.net,
and that you are using port 12345. However, when you try to connect
to this port from a computer, let us call this client.net, then you
get error messages like the ones above, due to a firewall on server.net
blocking port 12345.

However, assuming that you can create an ssh connection between the
two computers, then you can use this to forward one of the ports on
client.net to connect to the necessary port on server.net. This can
be done with the following shell command:

\begin{code}
> ssh -f -N server.net -L 23451:server.net:12345
\end{code}

The flags -f and -N just put the ssh process in the background. Then
comes the ssh server, which in this case is the computer on which
the server code is running. The -L flag sets up the ssh tunnel itself.
The above code will forward the port 23451 on client.net to the port
12345 on server.net, as required.

Once this is done, then any data sent to port on 23451 on client.net
will be forwarded through the ssh tunnel to port 12345 on server.net.
By connecting to port 23451 on client.net (or localhost, an alias
for the host the code is running on) with the client the code should
now run.

If the ssh connection fails, with an error message {}``ssh: connect
to host server.net port 22: Connection timed out'', then the server.net
server has also been set up with a firewall around the standard ssh
port, port 22. In this case you can change which port is used to one
that is open using the -p flag, for example:

\begin{code}
> ssh -f -N server.net -L 23451:server.net:12345 -p 99
\end{code}


\subsubsection{Using a script to create a ssh connection}

Now let us suppose that client.net is a cluster, and we wish to submit
the client jobs to the queue. The above code as it is will not work,
since ssh requires a password. However, you can set up ssh such that
no password is needed. 

Firstly, on client.net, we need to set up an ssh key. This can be
done using the command:

\begin{code}
> ssh-keygen -t rsa
\end{code}

It will then prompt you for a passphrase twice. Since we wish to have
use this in a job script where we will not be able to enter a password,
just hit enter twice. Note that this will mean that someone with temporary
access to your account could feasibly take a copy of the ssh key and
then be able to use it, so this should be used with caution.

This should now have created two files in the directory \textasciitilde{}/.ssh,
id\_rsa and id\_rsa.pub. These should be readable only by you, so
use the following code to set up the correct file permissions:

\begin{code}
> chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
\end{code}

Finally, copy the contents of the file id\_rsa.pub and append them
to the file authorized\_keys in the directory \textasciitilde{}/.ssh
of server.net. It should now be possible to ssh from client.net to
server.net without using a password. We can now run the ssh command
from a script, and so we can set up a ssh tunnel from a cluster node.
Note that the cluster nodes will have a different IP address to the
head node, so use {}``localhost'' rather than {}``client.net''
in the input file of the client code.


\chapter{Input reference}

\label{hierarchy}

The following chapter gives a complete list of the tags that can be
specified in the xml input file, along with the hierarchy of objects.
Note that every xml input file must start with the root tag {}``simulation''. 

See the accompanying {}``help.xml'' file in the {}``doc'' directory
to see the recommended input file structure.

\input{input_docs/simulation}
\input{input_docs/initializer}
\input{input_docs/init_file}
\input{input_docs/init_pos}
\input{input_docs/init_mom}
\input{input_docs/init_vel}
\input{input_docs/init_lab}
\input{input_docs/init_mass}
\input{input_docs/init_cell}
\input{input_docs/init_therm}
\input{input_docs/ensembles}
\input{input_docs/forces}
\input{input_docs/socket}
\input{input_docs/cell}
\input{input_docs/beads}
\input{input_docs/atoms}
\input{input_docs/normal_modes}
\input{input_docs/barostats}
\input{input_docs/thermostats}
\input{input_docs/prng}
\input{input_docs/output}
\input{input_docs/checkpoint}
\input{input_docs/properties}
\input{input_docs/trajectory}


\chapter{Troubleshooting}

\label{trouble}


\section{Input errors}
\begin{itemize}
\item \emph{not well-formed (invalid token)}: Seen if the input file does
not have the correct xml syntax. Should be accompanied by a line number
giving the point in the file where the syntax is incorrect.
\item \emph{mismatched tag}: One of the closing tags does not have the
same name as the corresponding opening tag. Could be caused either
by a misspelling of one of the tags, or by having the closing tag
in the wrong place. This last one is a standard part of the xml syntax,
if the opening tag of one item is after the opening tag of a second,
then its closing tag should be before the closing tag of the second.
Should be accompanied by a line number giving the position of the
closing tag.
\item \emph{Uninitialized value of type \_\_\_} or \emph{Attribute/Field name \_\_\_ is mandatory and was not found in the input for property \_\_\_}:
The xml file is missing a mandatory tag, i.e. one without which the
simulation cannot be initialized. Find which tag name is missing and
add it.
\item \emph{Attribute/tag name \_\_\_ is not a recognized property of \_\_\_ objects}:
The first tag should not be found within the second set of tags. Check
that the first tag is spelt correctly, and that it has been put in
the right place.
\item \emph{\_\_\_ is not a valid option (\_\_\_)}: This attribute/tag
only allows a certain range of inputs. Pick one of the items from
the list given.
\item \emph{\_\_\_ is an undefined unit for kind \_\_\_} or \emph{\_\_\_ is not a valid unit prefix} or \emph{Unit \_\_\_ is not structured with a prefix+base syntax}:
The unit input by the user is not correct. Make sure it corresponds
to the correct dimensionality, and is spelt correctly.
\item \emph{Invalid literal for int() with base 10: \_\_\_} or \emph{Invalid literal for float(): \_\_\_} or \emph{\_\_\_ does not represent a bool value}:
The data input by the user does not have the correct data type. See
section \ref{ifilestructure} for what constitutes a valid integer/float/boolean
value.
\item \emph{Error in list syntax: could not locate delimiters}: The array
input data did not have the required braces. For a normal array use
{[}{]}, for a dictionary use \{\}, and for a tuple use ().
\item \emph{The number of atom records does not match the header of xyz file}:
Self-explanatory.
\item \emph{list index out of range}: This will normally occur if the configuration
is initialized from an invalid input file. This will either cause
the code to try to read part of the input file that does not exist,
or to set the number of beads to zero which causes this error in a
different place. Check that the input file has the correct syntax.
\end{itemize}

\section{Initialization errors}
\begin{itemize}
\item \emph{Negative \_\_\_ parameter specified.}: Self-explanatory.
\item \emph{If you are initializing cell from cell side lengths you must pass the 'cell' tag an array of 3 floats}:
If you are attempting to initialize a cell using the {}``abc'' mode,
the code expects three floats corresponding to the three side lengths. 
\item \emph{If you are initializing cell from cell side lengths and angles you must pass the 'cell' tag an array of 6 floats}:
If you are attempting to initialize a cell using the {}``abcABC''
mode, the code expects six floats corresponding to the three side
lengths, followed by the three angles in degrees.
\item \emph{Cell objects must contain a 3x3 matrix describing the cell vectors.}:
If you are attempting to initialize a cell using the {}``manual''
mode, the code expects nine floats corresponding to the cell vector
matrix side lengths. Note that the values of the lower-diagonal elements
will be set to zero.
\item \emph{Array shape mismatch in q/p/m/names in beads input}: The size
of the array in question does not have the correct number of elements
given the number of atoms and the number of beads used in the rest
of the input. If the number of beads is nbeads and the number of atoms
natoms, then q and p should have shape (nbeads, 3{*}natoms) and m
and names should have shape (natoms,).
\item \emph{No thermostat/barostat tag provided for \emph{NVT}/\emph{NPT} simulation}:
Some ensembles can only be sampled if a thermostat and/or barostat
have been defined, and so for simulations at constant temperature
and/or pressure these tags are mandatory. If you wish to not use a
thermostat/barostat, but still want to keep the ensemble the same,
then use {}``dummy'' mode thermostat/barostat, which simply does
nothing.
\item \emph{Pressure/Temperature should be supplied for constant pressure/temperature simulation}:
Since in this case the ensemble is defined by these parameters, these
must be input by the user. Add the appropriate tags to the input file.
\item \emph{Manual path mode requires (nbeads-1) frequencies, one for each internal mode of the path.}:
If the {}``mode'' tag of {}``normal\_modes'' is set to {}``manual'',
it will expect an array of frequencies, one for each of the internal
normal modes of the ring polymers. 
\item \emph{PA-CMD mode requires the target frequency of all the internal modes.}:
If the {}``mode'' tag of {}``normal\_modes'' is set to {}``pa-cmd'',
it will expect an array of one frequency, to which all the internal
modes of the ring polymers will be set. 
\item \emph{WMAX-CMD mode requires [wmax, wtarget]. The normal modes will be scaled such that the first internal mode is at frequency wtarget and all the normal modes coincide at frequency wmax.}:
If the {}``mode'' tag of {}``normal\_modes'' is set to {}``wmax-cmd'',
it will expect an array of two frequencies, one two set the lowest
frequency normal mode, and one for the other normal mode frequencies.
\item \emph{Number of beads \_\_\_ doesn't match GLE parameter nb= \_\_\_}:
The matrices used to define the generalized Langevin equations of
motion do not have the correct first dimension. If matrices have been
downloaded from \url{http://gle4md.berlios.de/ } make sure that you
have input the correct number of beads.
\item \emph{Initialization tries to match up structures with different atom numbers}:
If in the initialization any of the matrices has an array shape which
do not correspond to the same number of atoms, then they cannot correspond
to the same system. Check the size of the arrays specified if they
have been input manually.
\item \emph{Cannot initialize single atom/bead as atom/bead index \_\_\_ is larger than the number of atoms/beads}:
Self-explanatory. However, note that indices are counted from 0, so
the first replica/atom is defined by an index 0, the second by an
index 1, and so on.
\item \emph{Cannot initialize the momenta/masses/labels/single atoms before the size of the system is known.}:
In the code, a beads object is created to hold all the information
related to the configuration of the system. However, until a position
vector has been defined, this object is not created. Therefore, whichever
arrays are being initialized individually, the position vector must
always be initialized first.
\item \emph{Trying to resample velocities before having masses.}: A Maxwell-Boltzmann
distribution is partly defined by the atom velocity, and so the masses
must be defined before the velocities can be resampled from this distribution.
\item \emph{Cannot thermalize a single bead}: It does not make sense to
initialize the momenta of only one of the beads, and so \ipi does
not give this functionality.
\item \emph{Initializer could not initialize \_\_\_}: A property of the
system that is mandatory to properly run the simulation has not been
initialized in either the {}``initialize'' section or the appropriate
section in beads.
\item \emph{Ensemble does not have a thermostat to initialize} or \emph{There is nothing to initialize in non-GLE thermostats} or \emph{Checkpoint file does not contain usable thermostat data}:
These are raised if the user has tried to initialize the matrices
for the GLE thermostats with a checkpoint file that either does not
have a GLE thermostat or does not have a thermostat at all.
\item \emph{Size mismatch in thermostat initialization data}: Called if
the shape of the GLE matrices defined in the checkpoint file is different
from those defined in the new simulation. 
\item \emph{Replay can only read from PDB or XYZ files -- or a single frame from a CHK file}:
If the user specifies a replay ensemble, the state of the system must
be defined by either a configuration file or a checkpoint file, and
cannot be specified manually.
\end{itemize}

\section{Output errors}
\begin{itemize}
\item \emph{The stride length for the \_\_\_ file output must be positive.}:
Self-explanatory
\item \emph{\_\_\_ is not a recognized property/output trajectory}: The
string as defined in the {}``properties''/''trajectory'' tag does
not correspond to one of the available trajectories. Make sure that
both the syntax is correct, and that the property has been spelt correctly.
\item \emph{Could not open file \_\_\_ for output}: Raised if there is
a problem opening the file defined by the {}``filename'' attribute.
\item \emph{Selected bead index \_\_\_ does not exist for trajectory \_\_\_}:
You have asked for the trajectory of a bead index greater than the
number of the replicas of the system. Note that indices are counted
from 0, so the first replica is defined by an index 0, the second
by an index 1, and so on.
\item \emph{Incorrect format in unit specification \_\_\_}: Usually raised
if one of the curly braces has been neglected.
\item \emph{Incorrect format in argument list \_\_\_}: This will be raised
either if one of the brackets has been neglected, or if the delimiters
between arguments, in this case {}``;'', are not correct. This is
usually raised if, instead of separating the arguments using {}``;'',
they are instead separated by {}``,'', since this causes the property
array to be parsed incorrectly.
\item \emph{\_\_\_ got an unexpected keyword argument \_\_\_}: This will
occur if one of the argument lists of one of the properties specified
by the user has a keyword argument that does not match any of those
in the function to calculate it. Check the properties.py module to
see which property this function is calculating, and what the correct
keyword arguments are. Then check the {}``properties'' tag, and
find which of the arguments has been misspelt. 
\item \emph{Must specify the index of atom\_vec property}: Any property
which prints out a vector corresponding to one atom needs the index
of that atom, as no default is specified.
\item \emph{Cannot output \_\_\_ as atom/bead index \_\_\_ is larger than the number of atoms/beads}:
Self-explanatory. However, note that indices are counted from 0, so
the first replica/atom is defined by an index 0, the second by an
index 1, and so on.
\item \emph{Couldn't find an atom that matched the argument of \_\_\_}:
For certain properties, you can specify an atom index or label, so
that the property is averaged only over the atoms that match it. If
however no atom labels match the argument given, then the average
will be undefined. Note that for properties which are cumulatively
counted rather than averaged, this error is not raised, and if no
atom matches the label given 0 will be returned.
\end{itemize}

\section{Socket errors}
\begin{itemize}
\item \emph{Address already in use}: This is called if the server socket
is already being used by the host network. There are several possible
reasons for getting this error. Firstly, it might simply be that two
simulations are running concurrently using the same host and port
number. In this case simply change the port number of one of the simulations.
Secondly, you can get this error if you try to rerun a simulation
that previously threw an exception, since it takes a minute or so
before the host will disconnect the server socket if it is not shut
down cleanly. In this case, simply wait for it to disconnect, and
try again. Finally, you will get this error if you try to use a restricted
port number (i.e. below 1024) while not root. You should always use
a non-restricted port number for \ipi simulations.
\item \emph{Error opening unix socket. Check if a file /tmp/ipi\_\_\_ exists, and remove it if unused.}:
Similar to the above error, but given if you are using a unix socket
rather than an internet socket. Since this binds locally the socket
can be removed by the user, which means that it is not necessary to
wait for the computer to automatically disconnect an unused server
socket. 
\item \emph{Port number \_\_\_ out of acceptable range}: The port number
must be between 1 and 65535, and should be greater than 1024. Change
the port number accordingly.
\item \emph{Slot number \_\_\_ out of acceptable range}: The slot number
must be between 1 and 5. Change the slot number accordingly.
\item \emph{'NoneType' object has no attribute 'Up'}: This is called if
an exception is raised during writing the data to output, and so the
thread that deals with the socket is terminated uncleanly. Check the
stack trace for the original exception, since this will be the actual
source of the problem. Also note that, since the socket thread was
not cleaned up correctly, the server socket may not have been disconnected
properly and you may have to wait for a minute before you can restart
a simulation using the same host and port number.
\end{itemize}

\section{Mathematical errors}
\begin{itemize}
\item \emph{math domain error}: If the cell parameters are defined using
the side lengths and angles, with either a pdb file or using the {}``abcABC''
initialization mode, then for some value of the angles it is impossible
to construct a valid cell vector matrix. This will cause the code
to attempt to take the square root of a negative number, which gives
this exception.
\item \emph{overflow encountered in exp}: Sometimes occurs in \emph{NPT} runs
when the simulation box {}``explodes''. Make sure you have properly
equilibrated the system before starting and that the timestep is short
enough to not introduce very large integration errors.
\end{itemize}
\bibliographystyle{elsarticle-num-names}
\bibliography{mybib}
\end{document}
