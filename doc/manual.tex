\documentclass[12pt,fleqn]{report}
\usepackage{makeidx}
\usepackage{color}
\usepackage{multicol}
\usepackage{amsmath}
\usepackage{hyperref}
\makeindex

\newcommand{\dd}{\; \mathrm{d}}
\newcommand{\Tr}{\mathrm{Tr}}
\newcommand{\bra}{< \! \!}
\newcommand{\ket}{\! \! >}
\newcommand{\betan}{\beta_N}
\newcommand{\logn}{\mathrm{ln}}
\newcommand{\expon}{\mathrm{exp}}
\newcommand{\Imag}{\mathrm{Im}}

\begin{document}
\begin{titlepage}
\begin{center}

\vspace*{+5.5cm}

{\LARGE Wrap-pi PIMD code}
\end{center}
\end{titlepage}

\pagenumbering{roman}

\tableofcontents
\listoffigures

\newpage
\pagenumbering{arabic}

\chapter{Introduction}
wrap-pi is a path integral molecular dynamics (PIMD) wrapper written in python 
for ab initio density functional theory (DFT) codes. It currently works with 
the DFT codes QUANTUM ESPRESSO and CP2K, as well as the classical codes 
LAMMPS and DLPOLY.

It is designed to separate the calculation of the potential energy, forces and 
virial of a system from the algorithmic steps that propagate the dynamics. 
This allows the time intesive force calculation to be done by heavily optimised 
external codes while the dynamics and properties of interest can be calculated 
in the most transparent manner possible.

This manual will be in 5 parts, each with the following information:
\begin{itemize}
\item In this chapter we discuss the functionality of the wrapper and the 
problems it is trying to solve.
\item In the second chapter we will give instructions for the correct download, 
installation and running of the wrapper and specific driver codes.
\item In the third chapter we explain the procedure for creating simulations 
with the appropriate features, and the form of the input and output files.
\item In the fourth chapter the theory behind the algorithms used in the 
wrapper are discussed.
\item In the final chapter we discuss some of the inner workings of the code to 
facilitate user modification of it.
\end{itemize}
\section{Background and nomenclature}
\subsection{Molecular dynamics}
Molecular dynamics is a way of sampling the possible states of a system by 
propagating the positions and momenta of the particles in the system in 
discrete time steps according to a set of physical rules.

By choosing the algorithm used to propagate the momenta correctly, the 
probability of the system being in a particular state will be the same as 
that of a physically realistic system, such as a system in contact with an 
external heat bath.

We will call the complete set of possible states of the system an ensemble of 
states. The relevant ensembles we will be interested in are:
\begin{description}
\item[NVE ensemble] This gives constant particle number, volume and energy, 
and corresponds to an isolated physical system.
\item[NVT ensemble] This gives constant particle number, volume and temperature,
and corresponds to a physical system in thermal equilibrium with a heat bath.
\item[NPT ensemble] This gives constant particle number, pressure and 
temperature, and corresponds to a physical system in thermal equilibrium with 
a heat bath and in equilibrium with a pressure bath.
\end{description}

We will call the total number of possible states of a system for any given set 
of external variables the partition function of that system.

In any practical simulation, the number of atoms has to be far fewer than the 
typical number present in the physical system of interest, for reasons of 
computational difficulty. This means that a high proportion of the particles 
in the simulation are likely to be on the edge of the simulation box. To 
prevent this having a large effect on the properties of the system, all of the 
driver codes implement what is known as periodic boundary conditions. This 

***********************************************88
\subsection{Path integral generalization}
In the path integral generalization of classical mechanics, we use the 
following isomorphism between the quantum partition function of a system and a 
classical partition function in a higher phase space:
\begin{equation}
Q = \Tr (e^{-\hat{H} \beta}) \\
\end{equation}
\begin{align}
&Q = \lim_{N\to \infty} \prod_{i=1}^N \left[ \int_{-\infty}^\infty  
\left( \frac{ 2 \pi m}{h^2 \betan} \right) ^{\frac{3}{2}} 
e^{-\hat{U}_N \betan} \dd \textbf{r}_i \right] \\
& \hat{U}_N=
\sum_{i=1}^N \left[ \frac{m}{2 \betan^2 \hbar^2}(\textbf{r}_i-\textbf{r}_{i-1})^2+\hat{V}_i \right] \\
&\betan = \frac{\beta}{N} \nonumber
\end{align}
Where \(\hat{H}\) is the quantum Hamiltonian of the system, which is the 
operator corresponding to the observable energy, \(\hat{V}_i\) is the potential 
of the replica of the system corresponding to the label \(i\), and \(\hat{U}_N\)
is a classical configurational Hamiltonian in the extended phase space, which 
only depends on particle coordinates. 

In practice we do not need to go to the limit of infinite \(N\), as 
convergence can often be achieved with a small increase of phase space. Note 
that this classical Hamiltonian is equivalent to that of a \(N\) replicas of 
the original system, with a harmonic potential between adjacent replicas. 
We will call this set of replicas of each atom a ring polymer, and the 
component particles of this ring polymer beads.

The last thing we must do to make the connection with molecular dynamics is to 
add fictitious ring polymer momenta to allow us to sample the phase space more 
effectively. In our code we make the choice corresponding to assigning each 
bead the mass of the corresponding atom:
\begin{align}
&Q = \lim_{N\to \infty} \prod_{i=1}^N \left[ \int_{-\infty}^\infty  
\int_{-\infty}^\infty \left( \frac{ 1 }{2 \pi \hbar} \right) ^3 
e^{-\hat{H}_N \betan} \dd \textbf{r}_i \dd \textbf{p}_i \right] \\
&\hat{H}_N = \hat{U}_N + \sum_{i=1}^N \frac{\textbf{p}_i^2}{2 m}
\end{align}

This is then the partition function corresponding to the NVE ensemble for the 
quantum system, and as it has a purely classical Hamiltonian the algorithms 
used in classical dynamics and the generalizations used to sample other 
ensembles can be applied to this system in exactly the same way as for a 
classical system.
\subsection{Ab initio potentials}
An ab initio potential is one that does not require any experimentally derived 
parameters in its calculation. Under the strictest sense of the term many of 
the most popular DFT algorithms are not ab initio as they do use experimentally 
determined parameters, but as prior simulations are not necessary for the 
formulation of a DFT potential, we will define DFT as such for the purposes of 
this manual.

DFT calculations are done by minimising an energy with respect to the one 
electron probability density, rather than the wavefunction as is common in 
most other ab initio potentials. The energy is given in terms of that of a 
fictitious system without electron interaction, for which the energy can be 
found exactly, plus an energy term due to electron correlation. This is the 
quantity of fundamental importance in DFT calculations, and while no analytic 
form for it exists several useful approximations to it have been created. 
We will call these correlation functionals.

DFT calculations are done via an iterative procedure where a guess for the one 
electron wavefunctions are made so that the energy can be calculated, and a new 
set of one electron wavefunctions are then calculated by minimising this 
energy. The new wavefunctions are then put back into the first step and the 
procedure repeated until the initial and final density matrices are consistent.

In what is known as Car-Parrinello molecular dynamics, the converged 
wavefunctions of one step are then used as the starting point for the next 
step, drastically accelerating the convergence.

Another important consideration is the basis set used for the
\section{Driver compatibility}
There are currently patches available for Quantum Espresso version 4.3.2, CP2K
version 2.2, dlpoly version 2.16 and LAMMPS 14 Feb 2012. The next version of 
Quantum Espresso will have the patch as part of the main code.

None of these codes come with the wrap-pi package, and must be downloaded 
separately. See chapter 2 for more details of how to do this. 
\section{Functionality}
\section{Directory structure}
The code is separated into the following directory structure:
\begin{description}
\item[forces] Contains a few stand-alone fortran modules for running particular simple tests without needing to download one of the driver libraries.
\item[doc] Contains the documentation, including this manual.
\item[src] Contains the source code for the wrapper. This is further 
subdivided into:
\begin{description}
\item[engine] Holds the modules containing the internally used objects and 
algorithms
\item[forces] Holds the modules containing the objects that deal with the 
driver communication and data transfer.
\item[utils] Holds the modules containing the utility functions used in the 
other modules.
\end{description}
\item[patches] Contains the patch notes needed to allow the driver codes to 
interact with the wrapper.
\item[test] Contains examples that can be used to make sure the build has been
successful, show the correct form of the input files, and show some of the 
capabilities of the wrapper.
\end{description}
\section{System requirements}
Running wrap-pi requires python v2.4 and the numpy package as well as a C 
compiler such as gcc. Also, each of the driver codes have their own 
requirements. wrap-pi currently only runs on linux based operating systems. 
\section{Online resources}
To obtain the parameters needed to run Path Integral with Generalized 
Langevin Equation Thermostat (PIGLET) calculations, you can use the website:

\begin{center}
\url{http://gle4md.berlios.de/}
\end{center}
\section{Credits}
\section{Citing wrap-pi}
\section{License}

\chapter{Package download and testing}
\section{wrap-pi download}
\section{Driver installation and compilation}
\subsection{Quantum Espresso}
\subsection{dlpoly}
\section{Testing}

\chapter{Running wrap-pi}
In this chapter we discuss the procedure required to set up and execute 
simulations, as well as the expected output.
\section{Commmand line syntax}
The simplest way to run the wrapper code is from the command line, with a 
command of the form:

\begin{center}
python main.py \emph{input\_file.xml}
\end{center} 
Where \emph{input\_file.xml} is replaced with the name of the input file.

It is also possible to run the simulation from within another script, using
the function main in the module main.py. To do this, you can use a python module
of the form:
\\
\\
from main import *
\\ \\
\hspace*{1.6 cm} \vdots
\\ \\
input="input\_file.xml"
\\
main(input)
\\ \\
\hspace*{1.6 cm} \vdots
\\ \\
Note that this code only starts the wrapper and initialises the socket. 
To run any dynamics a driver code must also connect to the socket, so that the
forces and potential can be evaluated.
\section{Input files}
\subsection{xml file}
This is the main input file for the wrapper code. The xml format is based on a
heirarchial tree structure of data held between tags. The format is <tag\_name> data </tag\_name>

In this code, each tag
corresponds to an object used in the code, and the data to the value of this 
object. The data may either be a simple value or another set of tags. The
latter case corresponds to the situation where an object in the wrap-pi code
contains another object.

A list of the possible tag names, and their position in the heirarchy, is 
given in table 2.1:

\begin{table}
blah
\end{table}
\subsection{Configuration file}
\subsection{Internal units}
\section{Driver input}
\subsection{Quantum Espresso}
\subsection{dlpoly}
\section{Restart mechanism}
\subsection{Restart file}
\subsection{Soft exit}
\section{Output files}
\subsection{Property file}
\subsection{Trajectory file}

\chapter{Algorithms}
\section{Integrators}
\subsection{Trotter decomposition}
\subsection{Ring polymer normal mode coordinates}
\subsection{Constant temperature simulations}
\subsection{Constant pressure simulations}
\section{Output}
\subsection{Estimator theory}

\chapter{Developer's tips}
\section{Dependancy class}
\subsection{Dependancy graph}
\section{Class hierarchy}
\section{Output customization}
\section{xml parsing}
\subsection{Sockets}
\section{Interface}

\begin{thebibliography}{99}
\end{thebibliography}

\end{document}
