#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\@ifundefined{definecolor} {\usepackage{color}}{}
\usepackage{multicol}\makeindex
\usepackage{xspace}
\end_preamble
\options fleqn
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
dd}{
\backslash
; 
\backslash
mathrm{d}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Tr}{
\backslash
mathrm{Tr}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
bra}{< 
\backslash
! 
\backslash
!} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ket}{
\backslash
! 
\backslash
! >} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
betan}{
\backslash
beta_N} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
logn}{
\backslash
mathrm{ln}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
expon}{
\backslash
mathrm{exp}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Imag}{
\backslash
mathrm{Im}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
wrappi}{{
\backslash
sc wrap-PI}
\backslash
xspace}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 5.5cm*
\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
A Python wrapper for Path Integral Molecular Dynamics
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is a path integral molecular dynamics (PIMD) wrapper written in Python
 for ab initio density functional theory (DFT) codes.
 It currently works with the DFT codes QUANTUM ESPRESSO and CP2K, as well
 as the classical codes LAMMPS and DLPOLY.
\end_layout

\begin_layout Standard
It is designed to separate the calculation of the potential energy, forces
 and virial of a system from the algorithmic steps that propagate the dynamics.
 This allows the time intesive force calculation to be done by heavily optimised
 external codes while the dynamics and properties of interest can be calculated
 in the most transparent manner possible.
\end_layout

\begin_layout Standard
This manual will be in 5 parts, each with the following information: 
\end_layout

\begin_layout Itemize
In this chapter we discuss the functionality of the wrapper and the problems
 it is trying to solve.
 
\end_layout

\begin_layout Itemize
In the second chapter we will give instructions for the correct download,
 installation and running of the wrapper and specific driver codes.
 
\end_layout

\begin_layout Itemize
In the third chapter we explain the procedure for creating simulations with
 the appropriate features, and the form of the input and output files.
 
\end_layout

\begin_layout Itemize
In the fourth chapter the theory behind the algorithms used in the wrapper
 are discussed.
 
\end_layout

\begin_layout Itemize
In the final chapter we discuss some of the inner workings of the code to
 facilitate user modification of it.
 
\end_layout

\begin_layout Section
Shell variables
\end_layout

\begin_layout Standard
In all that follows, we will make use of the following definitions:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="9" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Name
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
Definition
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
src_dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The directory in which the wrapper code has been installed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
np_dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The directory in which the NumPy library has been installed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
np_dd_dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The directory in which the NumPy tar file has been downloaded
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
driver_dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The directory in which the driver code has been downloaded
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
np_vers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The version of NumPy installed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
py_vers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The version of Python installed
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
esp_dd_dir
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The directory in which the Quantum Espresso has been downloaded
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
esp_vers
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout

\size small
The version of Quantum Espresso installed
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Driver compatibility
\end_layout

\begin_layout Standard
There are currently patches available for Quantum Espresso version 4.3.2,
 CP2K version 2.2, dlpoly version 2.16 and LAMMPS 14 Feb 2012.
 The next version of Quantum Espresso will have the patch as part of the
 main code.
\end_layout

\begin_layout Standard
None of these codes come with the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 package, and must be downloaded separately.
 See chapter 2 for more details of how to do this.
 
\end_layout

\begin_layout Section
Online resources
\end_layout

\begin_layout Standard
For more information about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 and to download the source code go to [appropriate wrappi website].
\end_layout

\begin_layout Standard
To obtain the parameters needed to run Path Integral with Generalized Langevin
 Equation Thermostat (PIGLET) calculations, you can use the website: http://gle4
md.berlios.de/ 
\end_layout

\begin_layout Section
Credits
\end_layout

\begin_layout Section
Citing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Chapter
Programming paradigm
\end_layout

\begin_layout Section
Structure of the code
\end_layout

\begin_layout Subsection
Directory structure
\end_layout

\begin_layout Standard
The code is separated into the following directory structure: 
\end_layout

\begin_layout Description
forces Contains a few stand-alone fortran modules for running particular
 simple tests without needing to download one of the driver libraries.
 
\end_layout

\begin_layout Description
doc Contains the documentation, including this manual.
 
\end_layout

\begin_layout Description
src Contains the source code for the wrapper.
 This is further subdivided into: 
\end_layout

\begin_deeper
\begin_layout Description
engine Holds the modules containing the internally used objects and algorithms
 
\end_layout

\begin_layout Description
forces Holds the modules containing the objects that deal with the driver
 communication and data transfer.
 
\end_layout

\begin_layout Description
utils Holds the modules containing the utility functions used in the other
 modules.
 
\end_layout

\begin_layout Description
inputs Holds the modules containing the classes that read the input files.
\end_layout

\end_deeper
\begin_layout Description
patches Contains the patch notes needed to allow the driver codes to interact
 with the wrapper.
 
\end_layout

\begin_layout Description
test Contains examples that can be used to make sure the build has been
 successful, show the correct form of the input files, and show some of
 the capabilities of the wrapper.
 
\end_layout

\begin_layout Subsection
Code structure
\end_layout

\begin_layout Standard
To run a simulation, the following steps are followed by the code:
\end_layout

\begin_layout Enumerate
The input file is read, parsed and interpreted.
\end_layout

\begin_layout Enumerate
The appropriate python objects are created and initialized.
\end_layout

\begin_layout Enumerate
A socket is opened, and the wrapper waits for a driver code to connect.
\end_layout

\begin_layout Enumerate
Once at least one driver code has connected, the simulation is run forward
 in discrete time steps.
\end_layout

\begin_layout Standard
Each time step splits up into the following stages:
\end_layout

\begin_layout Enumerate
The momenta of the particles are adjusted by an external thermostat, if
 applicable.
\end_layout

\begin_layout Enumerate
The momenta of the particles are adjusted according to the forces acting
 on them
\end_layout

\begin_layout Enumerate
The centroid coordinates of the ring polymers are adjusted according to
 their momenta (and in constant pressure simulations the cell momenta).
\end_layout

\begin_layout Enumerate
The internal modes of the ring polymer are adjusted according to their momenta.
\end_layout

\begin_layout Enumerate
The forces are recalculated by the driver code.
\end_layout

\begin_layout Enumerate
See step 2.
\end_layout

\begin_layout Enumerate
See step 1.
\end_layout

\begin_layout Subsection
Object Hierarchy
\end_layout

\begin_layout Standard
[Maybe insert a graphic here?]
\end_layout

\begin_layout Section
Dependency detection and automatic property caching
\end_layout

\begin_layout Subsection
Rationale
\end_layout

\begin_layout Standard
One of the utility classes that is defined in the code, from which most
 of the classes in the code inherit, is the dobject class.
 Similarly, many of the variables contained in these classes are depend
 objects.
\end_layout

\begin_layout Standard
The depend object class has been designed so that every time it is accessed
 it checks all of the other depend objects on which it is dependent to see
 if they have changed, and if so recalculates its value.
 The dobject class overrides the mechanism by which you can access the members
 of an instance of it, so that they are accessed via the dependency detection
 functions.
\end_layout

\begin_layout Standard
These classes have been defined so that, instead of cluttering up the code
 with functions to recalculate the various parameters of the simulation,
 we simply have to define the function by which to recalculate them and
 the other objects which they depend upon when they are created, and then
 they will automatically be updated when required.
\end_layout

\begin_layout Standard
As an example, take the total kinetic energy for one replica of the system.
 This is a property of the total momentum vector and the mass vector of
 the different atoms.
 Therefore, we would create a 
\begin_inset Quotes eld
\end_inset

kin
\begin_inset Quotes erd
\end_inset

 object in the atoms class that has dependencies 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

momentum
\begin_inset Quotes erd
\end_inset

, and a recalculation function that calculated 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
frac{
\backslash
bf{p}^2}{2
\backslash
bf{m}}
\backslash
)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having done this, any time we access atoms.kin, the code will check to see
 if either the mass vector or momentum vector has changed.
 If it has will recalculate the kinetic energy before returning it, otherwise
 it will simply return the cached value.
\end_layout

\begin_layout Subsection
Synchronized objects
\end_layout

\begin_layout Standard
As well as checking for dependencies, the same infrastructure can also be
 used to synchronize two objects which are different representations of
 the same data.
 A good example of this is the bead coordinates in the cartesian and normal
 mode representations.
 Both of these represent the same data, but have different numerical values.
\end_layout

\begin_layout Standard
In this case we can use a synchronize object, which holds a dictionary of
 functions to transform one representation to another.
 In the case of the normal mode and cartesian representations of position,
 the transformation can be done either by multiplying the position vector
 by a transformation matrix, or via a Fourier transform.
\end_layout

\begin_layout Standard
Using this class, whenever we make a change to one of the representations,
 the others are automatically recalculated by reapplying the transformation
 function the next time they are accessed.
\end_layout

\begin_layout Section
Communication protocol
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 code is only a wrapper code; it only runs the molecular dynamics loop and
 does not calculate the force and potential acting on each particle.
 To do this 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 must interface with a driver code.
 The major design principle behind 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is to keep the wrapper and driver codes as far separated as possible.
 To this end, we run them completely separately, and only allow communication
 through a socket.
\end_layout

\begin_layout Subsection
Sockets
\end_layout

\begin_layout Standard
A socket is a data transfer device that is designed for internet communication.
 It supports both multiple connections to the same socket, and two way communica
tion.
 This makes it ideal for communication between the wrapper code and multiple
 driver codes.
\end_layout

\begin_layout Standard
Each socket is described by an IP address and a port number.
 On top of this, they can either be an internet socket or a local unix socket.
 Each of these different variables is important in a different way.
\end_layout

\begin_layout Standard
The IP address is specified in the code by the 
\begin_inset Quotes eld
\end_inset

address
\begin_inset Quotes erd
\end_inset

 tag.
 This is generally the name of the network on which the wrapper code is
 running, or localhost, which is the generic name for the network used for
 local communication.
\end_layout

\begin_layout Standard
The port number is specified in the code by the 
\begin_inset Quotes eld
\end_inset

port
\begin_inset Quotes erd
\end_inset

 tag.
 The port number is important because it is used to separate the different
 kinds of data transfer.
 The port number is an integer between 1-65535, each of which specifies
 a different port.
 As many of the lower numbers are protected for use in important system
 processes or internet communication, it is generally sensible to use numbers
 between 1025-65535 for simulations.
\end_layout

\begin_layout Standard
A unix or intenet socket is specified by the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 tag.
 The unix/inet distinction is an important one, the unix socket is faster
 than an internet socket, but can only be used for local communication.
 Generally, the simulation should only be run locally if a simple classical
 potential is being used, as complicated empirical potentials or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 potentials make the force calculation the bottleneck in the code, so the
 advantage of using unix sockets is lost.
\end_layout

\begin_layout Standard
In our code, there are a two other input parameters that may be used.
 
\begin_inset Quotes eld
\end_inset

latency
\begin_inset Quotes erd
\end_inset

 specifies the length of time between each check to see if any new driver
 codes have connected, and 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 specifies how many driver codes can queue between checks.
 Neither is likely to be important in running the code.
\end_layout

\begin_layout Subsection
Data transfer
\end_layout

\begin_layout Standard
To make the transfer as simple as possible, the data is transferred in binary
 format.
 The transfer protocol is to send a header string of 12 characters specifying
 the stage of the data transfer, followed if necessary by data, then wait
 for data to be returned.
 We use 4-bit integers, 8-bit floats and 12 character strings for the transfer.
 A typical step is of the form:
\end_layout

\begin_layout Enumerate
A header string of 
\begin_inset Quotes eld
\end_inset

STATUS
\begin_inset Quotes erd
\end_inset

 is sent by the server socket, specifying what stage of the data transfer
 is being done.
\end_layout

\begin_layout Enumerate
A header string is then returned, giving the status.
 Recognized options are:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

NEEDINIT
\begin_inset Quotes erd
\end_inset

: If the driver code needs any initialising data, it can be sent here.
 The server code will then send a header string 
\begin_inset Quotes eld
\end_inset

INIT
\begin_inset Quotes erd
\end_inset

, followed by an integer giving the number of bits in the initialization
 string, then the initialization string itself.
 [Deprecated, may be removed from later versions of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

]
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

READY
\begin_inset Quotes erd
\end_inset

: Sent if the driver code is ready to calculate the forces.
 The server socket will then send a string 
\begin_inset Quotes eld
\end_inset

POSDATA
\begin_inset Quotes erd
\end_inset

, then nine floats the cell vector matrix, then another nine floats for
 the inverse matrix, (which need to be transposed if the driver code is
 written in fortran).
 The server socket will then send one integer giving the number of atoms,
 then the position data as 3 floats for each atom giving the 3 cartesian
 components of the bead position.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

HAVEDATA
\begin_inset Quotes erd
\end_inset

: This is sent if the driver has calculated the potential and forces.
 The server socket then sends a string 
\begin_inset Quotes eld
\end_inset

GETFORCE
\begin_inset Quotes erd
\end_inset

, and the client socket returns 
\begin_inset Quotes eld
\end_inset

FORCEREADY
\begin_inset Quotes erd
\end_inset

.
 The potential is then returned as a float, the number of atoms as an integer,
 then the force data as 3 floats per atom in the same way as the positions,
 and the virial as 9 floats in the same way as the cell vector matrix.
\end_layout

\end_deeper
\begin_layout Enumerate
The server socket waits for an amount of time given by the latency before
 asking for 
\begin_inset Quotes eld
\end_inset

STATUS
\begin_inset Quotes erd
\end_inset

 again, until the force data for each replica of the system has been calculated
 and returned, upon which the job is finished and the molecular dynamics
 loop starts.
\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
This type of data transfer is well suited to working with PIMD, as it allows
 multiple driver codes to connect to the server socket of one simulation,
 so that different replicas of the system can be assigned to different driver
 codes so their forces can be computed in parallel.
\end_layout

\begin_layout Standard
In the case that there are as many driver codes as replicas of the system,
 this is very simple, as each replica will be assigned its own driver code.
 For most potentials, the slowdown due to the socket communication is not
 appreciable, and in this case the force calculation will essentially be
 as fast as a purely classical simulation.
 
\end_layout

\begin_layout Standard
Also, for subsequent steps, the interface will assign a particular replica
 of the system to the same driver code which calculated the forces for it
 the last step.
 This reduces the amount the configuration changes between calculations
 on a particular driver code, which can speed up certain calculations.
\end_layout

\begin_layout Standard
In the case where there are too few driver codes, then the socket interface
 will assign spare jobs to the first driver code that finishes running,
 after matching all possible jobs to the same driver code that calculated
 it last time step.
\end_layout

\begin_layout Standard
This is especially useful when the calculations are being run on a cluster.
 In this case, you can split up the driver codes, and they will connect
 whenever they reach the front of the queue.
 More driver codes can connect at any time, and if there is a problem and
 any driver code dies, it is simply removed from the driver list and any
 job it was running reassigned.
\end_layout

\begin_layout Chapter
Installing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
Background and nomenclature
\end_layout

\begin_layout Subsection
Molecular dynamics
\end_layout

\begin_layout Plain Layout
Molecular dynamics is a way of sampling the possible states of a system
 by propagating the positions and momenta of the particles in the system
 in discrete time steps according to a set of physical rules.
\end_layout

\begin_layout Plain Layout
By choosing the algorithm used to propagate the momenta correctly, the probabili
ty of the system being in a particular state will be the same as that of
 a physically realistic system, such as a system in contact with an external
 heat bath.
\end_layout

\begin_layout Plain Layout
We will call the complete set of possible states of the system an ensemble
 of states.
 The relevant ensembles we will be interested in are: 
\end_layout

\begin_layout Description
NVE ensemble This gives constant particle number, volume and energy, and
 corresponds to an isolated physical system.
 
\end_layout

\begin_layout Description
NVT ensemble This gives constant particle number, volume and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath.
 
\end_layout

\begin_layout Description
NPT ensemble This gives constant particle number, pressure and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath and in equilibrium with a pressure bath.
 
\end_layout

\begin_layout Plain Layout
We will call the total number of possible states of a system for any given
 set of external variables the partition function of that system.
\end_layout

\begin_layout Plain Layout
In any practical simulation, the number of atoms has to be far fewer than
 the typical number present in the physical system of interest, for reasons
 of computational difficulty.
 This means that a high proportion of the particles in the simulation are
 likely to be on the edge of the simulation box.
 To prevent this having a large effect on the properties of the system,
 all of the driver codes implement what is known as periodic boundary conditions.
 This***********************************************88 
\end_layout

\begin_layout Subsection
Path integral generalization
\end_layout

\begin_layout Plain Layout
In the path integral generalization of classical mechanics, we use the following
 isomorphism between the quantum partition function of a system and a classical
 partition function in a higher phase space: 
\begin_inset Formula 
\begin{equation}
Q=\Tr(e^{-\hat{H}\beta})
\end{equation}

\end_inset

 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\left(\frac{2\pi m}{h^{2}\betan}\right)^{\frac{3}{2}}e^{-\hat{U}_{N}\betan}\dd\textbf{r}_{i}\right]\\
 & \hat{U}_{N}=\sum_{i=1}^{N}\left[\frac{m}{2\betan^{2}\hbar^{2}}(\textbf{r}_{i}-\textbf{r}_{i-1})^{2}+\hat{V}_{i}\right]\\
 & \betan=\frac{\beta}{N}\nonumber 
\end{align}

\end_inset

 Where 
\begin_inset Formula \ensuremath{\hat{H}}

\end_inset

 is the quantum Hamiltonian of the system, which is the operator corresponding
 to the observable energy, 
\begin_inset Formula \ensuremath{\hat{V}_{i}}

\end_inset

 is the potential of the replica of the system corresponding to the label
 
\begin_inset Formula \ensuremath{i}

\end_inset

, and 
\begin_inset Formula \ensuremath{\hat{U}_{N}}

\end_inset

 is a classical configurational Hamiltonian in the extended phase space,
 which only depends on particle coordinates.
\end_layout

\begin_layout Plain Layout
In practice we do not need to go to the limit of infinite 
\begin_inset Formula \ensuremath{N}

\end_inset

, as convergence can often be achieved with a small increase of phase space.
 Note that this classical Hamiltonian is equivalent to that of a 
\begin_inset Formula \ensuremath{N}

\end_inset

 replicas of the original system, with a harmonic potential between adjacent
 replicas.
 We will call this set of replicas of each atom a ring polymer, and the
 component particles of this ring polymer beads.
\end_layout

\begin_layout Plain Layout
The last thing we must do to make the connection with molecular dynamics
 is to add fictitious ring polymer momenta to allow us to sample the phase
 space more effectively.
 In our code we make the choice corresponding to assigning each bead the
 mass of the corresponding atom: 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\left(\frac{1}{2\pi\hbar}\right)^{3}e^{-\hat{H}_{N}\betan}\dd\textbf{r}_{i}\dd\textbf{p}_{i}\right]\\
 & \hat{H}_{N}=\hat{U}_{N}+\sum_{i=1}^{N}\frac{\textbf{p}_{i}^{2}}{2m}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout
This is then the partition function corresponding to the NVE ensemble for
 the quantum system, and as it has a purely classical Hamiltonian the algorithms
 used in classical dynamics and the generalizations used to sample other
 ensembles can be applied to this system in exactly the same way as for
 a classical system.
 
\end_layout

\begin_layout Subsection
Ab initio potentials
\end_layout

\begin_layout Plain Layout
An ab initio potential is one that does not require any experimentally derived
 parameters in its calculation.
 Under the strictest sense of the term many of the most popular DFT algorithms
 are not ab initio as they do use experimentally determined parameters,
 but as prior simulations are not necessary for the formulation of a DFT
 potential, we will define DFT as such for the purposes of this manual.
\end_layout

\begin_layout Plain Layout
DFT calculations are done by minimising an energy with respect to the one
 electron probability density, rather than the wavefunction as is common
 in most other ab initio potentials.
 The energy is given in terms of that of a fictitious system without electron
 interaction, for which the energy can be found exactly, plus an energy
 term due to electron correlation.
 This is the quantity of fundamental importance in DFT calculations, and
 while no analytic form for it exists several useful approximations to it
 have been created.
 We will call these correlation functionals.
\end_layout

\begin_layout Plain Layout
DFT calculations are done via an iterative procedure where a guess for the
 one electron wavefunctions are made so that the energy can be calculated,
 and a new set of one electron wavefunctions are then calculated by minimising
 this energy.
 The new wavefunctions are then put back into the first step and the procedure
 repeated until the initial and final density matrices are consistent.
\end_layout

\begin_layout Plain Layout
In what is known as Car-Parrinello molecular dynamics, the converged wavefunctio
ns of one step are then used as the starting point for the next step, drasticall
y accelerating the convergence.
\end_layout

\begin_layout Plain Layout
Another important consideration is the basis set used for the 
\end_layout

\end_inset


\end_layout

\begin_layout Section
System requirements
\end_layout

\begin_layout Standard
To install and run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, you will need to have:
\end_layout

\begin_layout Itemize
A modern C compiler
\end_layout

\begin_layout Itemize
Python version 2.4 or later
\end_layout

\begin_layout Itemize
The Python array library NumPy
\end_layout

\begin_layout Standard
Additionally, most driver codes will have their own software requirements.
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 download
\end_layout

\begin_layout Standard
A tar file can be downloaded from the website [appropriate wrap-pi website].
 To install this you need to input the following commands:
\end_layout

\begin_layout Itemize

\series bold
cd $src_dir
\end_layout

\begin_layout Itemize

\series bold
tar xf [wrapper_tar_file.tar]
\end_layout

\begin_layout Standard
You can also download the git repository at [github repository name] using
 the commands:
\end_layout

\begin_layout Itemize

\series bold
cd $src_dir
\end_layout

\begin_layout Itemize

\series bold
git clone [name of repository]
\end_layout

\begin_layout Section
NumPy download
\end_layout

\begin_layout Standard
Many clusters do not have NumPy already installed upon them.
 How NumPy can be installed depends on whether you have root access or not,
 and on the version of python you are using.
\end_layout

\begin_layout Standard
In any case you must first obtain the NumPy code.
 The numpy library can be downloaded as a tar file from http://sourceforge.net/pr
ojects/numpy/files/NumPy/
\end_layout

\begin_layout Standard
This must then be extracted using the following commands:
\end_layout

\begin_layout Itemize

\series bold
cd $np_dd_dir
\end_layout

\begin_layout Itemize

\series bold
tar czf $np_vers.tar.gz
\end_layout

\begin_layout Standard
You must now install this code.
 Note that this requires the distutils package that comes with the python-dev
 package.
 Assuming that the required software is installed, the NumPy package is
 built using:
\end_layout

\begin_layout Standard

\series bold
python setup.py build
\end_layout

\begin_layout Standard
The next step is to install the package.
 By default the download is to the directory /usr/local.
 This however is only accessible if you have root access.
 In this case all that needs to be done to finish the install is:
\end_layout

\begin_layout Standard

\series bold
python setup.py install
\end_layout

\begin_layout Standard
If you do not have root access, then the next step depends on which version
 of Python is beind used.
 With versions 2.6 or later there is a simple command to automatically download
 into the directory $HOME/local:
\end_layout

\begin_layout Standard

\series bold
python setup.py install --user
\end_layout

\begin_layout Standard
With Python 2.4/2.5 the process is a little more involved.
 First you must explicitly install the package in the directory of choice
 with the following command:
\end_layout

\begin_layout Standard

\series bold
python setup.py install --prefix=$np_dir
\end_layout

\begin_layout Standard
Next, you must tell python where to find this library, by appending to the
 linux environment variable 
\series bold
PYTHONPATH
\series default
:
\end_layout

\begin_layout Standard

\series bold
export PYTHONPATH=$PYTHONPATH:$np_dir/lib64/$py_vers/site-packages
\end_layout

\begin_layout Standard
You may have to replace lib64 with lib depending on whether you are installing
 to a 64-bit or 32-bit architecture.
\end_layout

\begin_layout Section
Driver installation and compilation
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Standard
You can download the source code for Quantum Espresso at: www.quantum-espresso.org
/
\end_layout

\begin_layout Standard
For Quantum Espresso version 4.3.2, there is a patch file to allow it to be
 used as a driver code with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 in the directory $src_dir/patches/pwscf.
 This can be applied to the Quantum Espresso source code using:
\end_layout

\begin_layout Itemize

\series bold
cd $esp_dd_dir
\end_layout

\begin_layout Itemize

\series bold
tar zxvf $esp_vers.tar.gz
\end_layout

\begin_layout Itemize

\series bold
patch -p1 <
\series default
 
\series bold
$src_dir/patches/pwscf
\end_layout

\begin_layout Standard
After this, continue the download as per the instructions at www.quantum-espress.o
rg/.
\end_layout

\begin_layout Standard
Later versions of the code already have driver functionality, and so no
 patch needs to be applied before compiling.
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Subsection
dlpoly
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Chapter
Running 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run the wrapper
\end_layout

\begin_layout Subsection
Command line interface
\end_layout

\begin_layout Standard
The best way to run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is via the command line.
 If the xml-formatted input file is called input_file.xml, then the command
 to do this is:
\end_layout

\begin_layout Standard

\series bold
python $src_dir/main.py input_file.xml
\end_layout

\begin_layout Standard
This is the recommended way of initializing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, as it is both the simplest, and the easiest to script for lots of similar
 runs with different parameters.
\end_layout

\begin_layout Subsection
Python interface
\end_layout

\begin_layout Standard
It is also possible to run 
\begin_inset ERT
status open

\begin_layout Plain Layout

/wrappi
\end_layout

\end_inset

 from inside a Python script.
 This can be done via the following code:
\end_layout

\begin_layout Standard

\series bold
from main import *
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
vspace*{0.5 cm}
\end_layout

\end_inset


\end_layout

\begin_layout Standard

\series bold
main (
\begin_inset Quotes eld
\end_inset

input_file.xml
\begin_inset Quotes erd
\end_inset

)
\end_layout

\begin_layout Section
How to run the driver
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Section
Running simulations
\end_layout

\begin_layout Subsection
Running a simulation
\end_layout

\begin_layout Standard
A simulation is run by first running a wrapper code as above, and then connectin
g to the socket with one or more driver codes.
 For a small simulation, with a simple classical potential, it may be preferable
 to run both halves of the simulation on the same computer, especially as
 this allows us to use the faster unix domain sockets.
 If we assume that the driver code is run by the command 
\series bold
driver_comm
\series default
, the following code will run the wrapper, outputting the statistics to
 a file log, and 4 driver codes, then background the result:
\end_layout

\begin_layout Standard

\series bold
bash -c 
\begin_inset Quotes eld
\end_inset

python $src_dir/main.py input_file.xml &> log &
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Standard

\series bold
for a in `seq 1 4`; do bash -c 
\begin_inset Quotes eld
\end_inset

driver_comm &> 
\backslash
dev
\backslash
null &
\begin_inset Quotes erd
\end_inset

; done
\end_layout

\begin_layout Standard
In general, we want to choose the number of driver codes to be a divisor
 of the total number of replicas of the system, as otherwise there will
 be idle driver codes at the end of each step.
\end_layout

\begin_layout Standard
For most simulations, especially those running with expensive ab initio
 forces and potentials, we will want to run the code on a computational
 cluster.
 The best way to do this is to have the wrapper code running on the head
 node of the cluster, where we have the most control over it, and run the
 driver codes on the cluster nodes.
\end_layout

\begin_layout Standard
Here we make use of both the inherent parallelization in the partitioning
 of different replicas to different drivers, and the socket communication
 mechanism which allows data transfer either by internet connection or by
 ssh tunnelling.
\end_layout

\begin_layout Standard
The only modification required to the above code to do this is to change
 the driver command such that the driver code is submitted to the job queue
 rather than ran on the head node.
 The usual process required to do this is to write a shell script which
 runs the driver codes, then use a program such as qsub to submit this job
 to the cluster.
\end_layout

\begin_layout Subsection
Running multiple simulations
\end_layout

\begin_layout Standard
While running one simulation is useful, the power of the socket communications
 method is most aptly demonstrated when multiple simulations are run at
 once.
\end_layout

\begin_layout Standard
Firstly, the wrapper code is dormant until a driver code connects to the
 socket, so many wrapper codes can be run at once without using large amounts
 of CPU time waiting for the driver codes.
 This is especially useful when the driver codes are being run on a cluster,
 and may have to wait a long time to reach the front of the queue.
\end_layout

\begin_layout Standard
Secondly, each different simulation can be kept separate very easily, by
 just adjusting the port number of each parallel simulation.
 This is very easy to write a shell script to do.
 For example, if we assume the simulations will be run in directories called
 sim_1, sim_2, etc., then we can write:
\end_layout

\begin_layout Standard

\series bold
i=0; for a in sim_*; do cd $a; ((i++)); port=((10000+$i)); sed 
\begin_inset Quotes eld
\end_inset

s/XXX/$port/g
\begin_inset Quotes erd
\end_inset

 input.template > $a/input_file.xml; cd ..; done
\end_layout

\begin_layout Standard
This will replace a string 
\begin_inset Quotes eld
\end_inset

XXXX
\begin_inset Quotes erd
\end_inset

 in a template file with a port number, which will be different for each
 simulation.
\end_layout

\begin_layout Section
Input files
\end_layout

\begin_layout Subsection
xml file
\end_layout

\begin_layout Standard
This is the main input file from which the simulation parameters are initialized.
 The standard xml format is a set of hierarchially nested tags, each with
 a start tag, which may or may not have an attribute parameter, some contained
 data, which may or may not contain other tags, and a closing tag.
 The syntax required is:
\end_layout

\begin_layout Standard

\series bold
<tag_name attribute_name='attribute_data'>tag_data</tag_name>
\end_layout

\begin_layout Standard
The code uses this hierarchial structure to help read the data; if a particular
 object is held within a parent object in the code, then the tag for that
 object will be within the appropriate parent tags.
 In this manner, the entire class structure needed for the simulation can
 be constructed iteratively; the data between the two tags is assumed to
 correspond to data held within the object given by the tag name, which
 may have more tags corresponding to other child objects, so data held within
 those tags are assumed to correspond to data held within the child objects,
 and so on until all the data has been read.
\end_layout

\begin_layout Standard
To help detect any user error the acceptable tag names, type of data and
 possible default values are all specified in the code, in a specialized
 restart class for each class of object.
 More information on how the xml file is read can be found in Chapter 6.
\end_layout

\begin_layout Subsection
Configuration file
\end_layout

\begin_layout Standard
The initial configuration data can be initialized both through the xml file,
 and through a separate configuration file.
 The configuration file is specified using the 
\begin_inset Quotes eld
\end_inset

from_file
\begin_inset Quotes erd
\end_inset

 tag name in the xml file.
 The currently accepted file formats are:
\end_layout

\begin_layout Itemize
pdb
\end_layout

\begin_layout Itemize
xyz
\end_layout

\begin_layout Standard
These files can be used to specify the initial centroid positions and atom
 identities and, depending on the format, the cell parameters as well.
 The code will then try to assign masses to the atoms based on their atomic
 symbol, and an appropriate cell 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 for use in constant pressure simulations.
 Any of this data can be overwritten by the xml file by using the appropriate
 tag names and data.
\end_layout

\begin_layout Subsection
Units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 uses the following set of internal units:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S.I.
 Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bohr radius
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2917721e-11 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4188843e-17 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic mass unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.6605387e-27 kg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kelvin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Energy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hartree
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3597438e-18 J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pressure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.9421912e13 Pa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
However, these units can be overriden in the input file by using the 
\begin_inset Quotes eld
\end_inset

units
\begin_inset Quotes erd
\end_inset

 attribute.
 For example, if you wanted to specify the cell parameters in units of angstrom
 rather than bohr radii, then in the input file you would specify 
\begin_inset Quotes eld
\end_inset

<h units='angstrom'> 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 </h>
\begin_inset Quotes erd
\end_inset


\end_layout

\begin_layout Section
Driver input
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Subsection
dlpoly
\end_layout

\begin_layout Section
Output files
\end_layout

\begin_layout Subsection
Property file
\end_layout

\begin_layout Standard
This is the output file for for all the system and simulation level properties,
 such as the total energy and the overall time taken.
 The properties that are output are determined by the properties list in
 the xml input file.
\end_layout

\begin_layout Standard
The format of the file is given by a comment line giving the name of all
 the properties to be printed, followed by the rows giving their values
 at regular intervals given by the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 The file is fixed formatted, with two blank characters at the start of
 each row, then the data in the same order as the header row.
 Each column is 16 characters wide and every float is written in exponential
 format with 8 digits after the decimal point.
\end_layout

\begin_layout Subsection
Trajectory files
\end_layout

\begin_layout Standard
These are the output file for atomic properties.
 It will print out a configuration in the format given by the 
\begin_inset Quotes eld
\end_inset

traj_format
\begin_inset Quotes erd
\end_inset

 parameter in the xml input file at intervals governed by the value of the
 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 Depending on the chosen property to output, it will either print a file
 for each bead or just for each atom.
 The possible choices of output properties are:
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

positions
\begin_inset Quotes erd
\end_inset

: Gives the bead positions.
 Prints a separate file for each replica of the system
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

velocities
\begin_inset Quotes erd
\end_inset

: As above, except prints the velocities.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

: As above, except prints the forces.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

kinetic_cv
\begin_inset Quotes erd
\end_inset

: Prints the contribution of each atom to the total kinetic energy.
 Prints only one file.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

kodterms_cv
\begin_inset Quotes erd
\end_inset

: Prints the off-diagonal contributions to the kinetic energy tensor.
 Prints only one file.
\end_layout

\begin_layout Itemize
\begin_inset Quotes eld
\end_inset

centroid
\begin_inset Quotes erd
\end_inset

: Prints the position of the centroid coordinate of each atom.
 Prints only one file.
\end_layout

\begin_layout Standard
The allowable file formats for the trajectory output files are the same
 as for the configuration input files.
\end_layout

\begin_layout Section
Restart mechanism
\end_layout

\begin_layout Subsection
Restart file
\end_layout

\begin_layout Standard
As well as the above output files, the state of the system at a particular
 time step can also be saved to file.
 This gives a valid input file, with all the information required to restore
 the state of the system to what it was when the restart file was created.
 It is printed out at regular intervals, with a stride governed by the 
\begin_inset Quotes eld
\end_inset

checkpoint
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
\end_layout

\begin_layout Subsection
Soft exit
\end_layout

\begin_layout Standard
To stop the program in such a way that it makes sure to save the data generated
 in a restart file, simply create a file 
\begin_inset Quotes eld
\end_inset

EXIT
\begin_inset Quotes erd
\end_inset

 in the directory in which you are running the code.
 The thread will automatically detect this and safely shut down the program.
 
\end_layout

\begin_layout Standard
An important point to note is that since each time step is split into several
 parts, it is only at the beginning of each step that all the variables
 are consistent with each other in such a way that the simulation can be
 restarted from them without changing the dynamics.
 Thus if a soft exit call is made during a step, then the restart file that
 is created must correspond to the state of the system at the start of the
 step.
 To this end, the state of the system is saved at the start of every step.
\end_layout

\begin_layout Chapter
Algorithms
\end_layout

\begin_layout Section
Integrators
\end_layout

\begin_layout Subsection
Trotter decomposition
\end_layout

\begin_layout Subsection
Ring polymer normal mode coordinates
\end_layout

\begin_layout Subsection
Constant temperature simulations
\end_layout

\begin_layout Subsection
Constant pressure simulations
\end_layout

\begin_layout Section
Output
\end_layout

\begin_layout Subsection
Estimator theory
\end_layout

\begin_layout Chapter
Developer's tips
\end_layout

\begin_layout Section
Dependancy class
\end_layout

\begin_layout Subsection
Dependancy graph
\end_layout

\begin_layout Section
Class hierarchy
\end_layout

\begin_layout Section
Output customization
\end_layout

\begin_layout Section
xml parsing
\end_layout

\begin_layout Subsection
Sockets
\end_layout

\begin_layout Section
Interface
\end_layout

\end_body
\end_document
