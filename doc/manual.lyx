#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\@ifundefined{definecolor} {\usepackage{color}}{}
\usepackage{multicol}\makeindex
\usepackage{xspace}
\usepackage[numbers]{natbib}
\end_preamble
\options fleqn
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
dd}{
\backslash
; 
\backslash
mathrm{d}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Tr}{
\backslash
mathrm{Tr}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
bra}{< 
\backslash
! 
\backslash
!} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ket}{
\backslash
! 
\backslash
! >} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
betan}{
\backslash
beta_N} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
logn}{
\backslash
mathrm{ln}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
expon}{
\backslash
mathrm{exp}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Imag}{
\backslash
mathrm{Im}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ipi}{{
\backslash
sc i-PI}
\backslash
xspace}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
DFT}{Quantum Espresso, CP2K, CPMD and FHI-AIMS }
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
empirical}{LAMMPS}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 5.5cm*
\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
A Python wrapper for Path Integral Molecular Dynamics
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
About 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{intro}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is a Path Integral Molecular Dynamics (PIMD) wrapper code written in Python,
 designed to be used together with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 evaluation of the interactions between the atoms.
 The main goal is to decouple the problem of evolving the ionic positions
 to sample the appropriate thermodynamic ensemble and the problem of computing
 the inter-atomic forces.
 
\end_layout

\begin_layout Standard
The implementation is based on a client-server paradigm, where 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 acts as the server and deals with the propagation of the nuclear dynamics,
 whereas the calculation of the potential energy, forces and the potential
 energy part of the pressure virial is delegated to one or more instances
 of an external code, acting as clients.
 Since the main focus is on performing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 PIMD -- where the cost of the force evaluation is overwhelming relative
 to the ionic dynamics -- clarity has been privileged over speed.
 Still, the implementation of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is efficient enough that it can be used with empirical forcefields to perform
 simple benchmarks and preparatory simulations.
 
\end_layout

\begin_layout Section
Manual structure
\end_layout

\begin_layout Standard
This manual will be structured as follows: 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{intro}
\end_layout

\end_inset

 we briefly discuss the basis for PIMD and some of the specialized techniques
 used in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{getstarted}
\end_layout

\end_inset

 we will discuss how to install the code and test that it is working, and
 give a brief tutorial on running simulations with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{user}
\end_layout

\end_inset

 we explain in more detail the form of the input and output files and how
 the communication between the client and server codes is done.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{hierarchy}
\end_layout

\end_inset

 a full list of the major classes used in the code is given, along with
 the appropriate tag names and a brief description of all the fields that
 can be specified in the xml input file.
\end_layout

\begin_layout Itemize
In chapter 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{trouble}
\end_layout

\end_inset

 we list some of the more commonly encountered problems, and their solutions.
\end_layout

\begin_layout Section
Path Integral Molecular Dynamics
\end_layout

\begin_layout Standard
Molecular dynamics (MD) is a technique used to study the properties of a
 system of interacting particles by applying Newton's equations of motion
 to produce trajectories which can be used to efficiently explore the phase
 space.
 This can be used to calculate many equilibrium and dynamical properties,
 study systems from isolated gas molecules to condensed phase bulk materials,
 and can be applied to systems from the atomistic scale to mesoscopic colloidal
 particles.
\end_layout

\begin_layout Standard
However, while this technique has been very successful, in most MD implementatio
ns the assumption is made that the nuclei behave as classical particles,
 which for light nuclei such as hydrogen is often a very poor approximation
 as the effect of zero-point energy (ZPE) and quantum tunnelling can be
 large.
 For example, even at room temperature the vibrational frequency of an OH
 stretch in water is over 15 times larger than the available thermal energy,
 and so this motion will be highly quantized.
 The current state-of-the-art method to include nuclear quantum effects
 (NQE) in the calculation of static properties of condensed phase systems
 is path integral molecular dynamics (PIMD).
\end_layout

\begin_layout Standard
PIMD generates the quantum-mechanical ensemble of a system of interacting
 particles by using MD in an extended phase space.
 This is derived from the path integral formalism of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{feyn-hibb65book}
\end_layout

\end_inset

, which relates the statistics of a collection of quantum particles to those
 of a set of classical ring polymers, a ring polymer being a number of replicas
 of a particle coupled by harmonic springs.
 This so-called classical isomorphism is exact in the limit as the number
 of replicas goes to infinity, but in practice is converged numerically
 with only a finite number.
\end_layout

\begin_layout Standard
This then allows quantum phase space averages to be calculated from classical
 trajectories, with only about an order of magnitude more computing time
 than would be required for standard MD.
 Also, since PIMD is simply classical MD in an extended phase space many
 of the techniques developed to improve the scope and efficiency of MD simulatio
ns can be applied straightforwardly to the equivalent PIMD calculations
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{ceri+10jcp,mart+99jcp}
\end_layout

\end_inset

.
 Finally, several techniques designed specifically for PIMD simulations
 are now available to increase the rate of convergence with respect to the
 number of replicas used 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mark-mano08jcp,ceri+11jcp}
\end_layout

\end_inset

, so further reducing the computational overhead of the method.
 All of these facts mean that it is now feasible to do PIMD simulations
 with thousands of molecules, or even using 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 electronic structure calculations to propagate the dynamics for small systems.
\end_layout

\begin_layout Standard
Furthermore, the framework used to run PIMD simulations can be adapted to
 generate approximate quantum dynamical information 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{crai-mano04jcp,hone+06jcp}
\end_layout

\end_inset

, and so can also be used to calculate correlation functions.
 While the dynamics is classical, and so real-time quantum coherences cannot
 be captured, the correct capture of quantum statistical information and
 the rapid decoherence observed in condensed phase systems mean that in
 many cases very accurate results can be obtained from such approximate
 treatments of quantum dynamics 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{habe+13arpc}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Implementation
\end_layout

\begin_layout Subsection
Automated evaluation (depend objects)
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 uses a caching mechanism with automatic value updating to make the code
 used to propagate the dynamics as simple and clear as possible.
 Every physical quantity that is referenced in the code is created using
 a 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object class, which is given the parameters on which it depends and a function
 used to calculate its value.
 
\end_layout

\begin_layout Standard
\begin_inset Quotes eld
\end_inset

Depend
\begin_inset Quotes erd
\end_inset

 objects can be called to get the physical quantity they represent.
 However, they have further functionality.
 Firstly, once the value of a 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object has been calculated, its value is cached, so further references
 to that quantity will not need to evaluate the function that calculates
 it.
 Furthermore, the code keeps track of when any of the dependencies of the
 variable are updated, and makes sure that the quantity is automatically
 recomputed when it is needed.
 
\end_layout

\begin_layout Standard
This choice makes implementation slightly more complex when the physical
 observables are first introduced as variables, as one has to take care
 of stating their dependencies as well as the function that computes them.
 However, the advantage is that when the physical quantities are used, in
 the integrator of the dynamics or in the evaluation of physical properties,
 one does not need to take care of book-keeping and the code can be cleaner,
 transparent and readable.
\end_layout

\begin_layout Subsection
Communication protocol
\end_layout

\begin_layout Standard
Since 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is designed to be used with a wide range of codes and platforms, it has
 to rely on a simple and robust method for communicating between the server
 and client.
 Even though other choices are possible, and it should be relatively simple
 to implement other means of communication, the preferred approach relies
 on sockets as the underlying infrastructure.
 Both Internet and Unix domain sockets can be used: the latter allow for
 fast communication on a single node, whereas the former makes it possible
 to realize a distributed computing paradigm, with clients running on different
 nodes or even on different HPC facilities.
 In order to facilitate implementation of the sockets communication in client
 codes, a simple set of C wrappers to the standard libraries socket implementati
on is provided as part of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 distribution, that can be used in any programming language that can be
 linked with C code
\end_layout

\begin_layout Standard
As far as the communication protocol is concerned, the guiding principle
 has been keeping it to the least common denominator, and avoiding any feature
 that may be code-specific.
 Only minimal amount of information is transferred between the client and
 the server; the position of the atoms and cell parameters in one direction,
 and the forces, virial and potential in the other.
\end_layout

\begin_layout Standard
For more details about sockets and communication, see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{distrib}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Subsection
Internal units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{units}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
All the units used internally by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 are atomic units, as given below.
 By default, both input and output data are given in atomic units, but in
 most cases the default units can be overridden if one wishes so.
 For details on how to do this, see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{inputunits}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{propertyfile}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
\align center
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S.I.
 Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bohr radius
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2917721e-11 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4188843e-17 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Electron mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.1093819e-31 kg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Kelvin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Energy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hartree
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3597438e-18 J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pressure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.9421912e13 Pa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Section
Core features
\end_layout

\begin_layout Standard
The functionality of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 includes:
\end_layout

\begin_layout Itemize
Integrators for constant temperature ensembles, including: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Local and global stochastic thermostats 
\backslash
cite{plangevin1908cras,buss-parr08cpc}, with optional optimized sampling
 over the normal mode coordinates 
\backslash
cite{ceri+10jcp}.
\end_layout

\begin_layout Plain Layout


\backslash
item Optimal sampling generalized Langevin equation (GLE) thermostats 
\backslash
cite{ceri+09jctc}.
\end_layout

\begin_layout Plain Layout


\backslash
item Path integral + GLE (PI+GLE) thermostats 
\backslash
cite{ceri+11jcp} for accelerating convergence of potential energy with respect
 to number of replicas, as well as the more recent PIGLET method 
\backslash
cite{ceri-mano12prl} which also converges kinetic energy quickly.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\end_inset


\end_layout

\begin_layout Itemize
Integrators for constant pressure ensembles 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mart+99jcp,buss+09jpc}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Ring polymer contraction 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mark-mano08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Scaled path finite difference energy and heat capacity estimators 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{tyamamoto05jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Displaced path momentum distribution estimator 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{linlin+10prl}
\end_layout

\end_inset

.
\end_layout

\begin_layout Itemize
Dynamical property calculation modes:
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{itemize}
\end_layout

\begin_layout Plain Layout


\backslash
item Ring polymer molecular dynamics 
\backslash
cite{crai-mano04jcp}.
\end_layout

\begin_layout Plain Layout


\backslash
item Partially-adiabatic centroid molecular dynamics 
\backslash
cite{habe+08jcp,hone+06jcp}.
\end_layout

\begin_layout Plain Layout


\backslash
end{itemize}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Licence and credits
\end_layout

\begin_layout Standard
This code is distributed under the GPL licence.
 For more details see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.gnu.org/licences/gpl.html
\end_layout

\end_inset

.
 If you use this code in any future publications, please cite this using
 [cpc paper citation].
\end_layout

\begin_layout Section
On-line resources
\end_layout

\begin_layout Subsection
Python resources
\end_layout

\begin_layout Standard
For help with Python programming, see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.python.org
\end_layout

\end_inset

.
 For information about the NumPy mathematical library, see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.numpy.org
\end_layout

\end_inset

, and for worked examples of its capabilities see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.scipy.org/Tentative_NumPy_Tutorial
\end_layout

\end_inset

.
 Finally, see 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://hgomersall.github.io/pyFFTW/
\end_layout

\end_inset

 for documentation on the Python FFTW library that is currently implemented
 with the wrapper.
\end_layout

\begin_layout Subsection
Client code resources
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{librarywebsites}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are currently patches available for Quantum Espresso version 4.3.2 and
 CP2K version 2.2.
 It should be possible to adapt these patches to other versions of the codes
 with minor modifications.
 For more information about Quantum Espresso and CP2K, go to 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

www.quantum-espresso.org
\end_layout

\end_inset

 and 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

cp2k.org
\end_layout

\end_inset

 respectively.
\end_layout

\begin_layout Standard
There are several Fortran and C libraries that most client codes will probably
 need to run, such as FFTW, BLAS and LAPACK.
 These can be found at 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

www.fftw.org
\end_layout

\end_inset

, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.netlib.org/blas
\end_layout

\end_inset

 and 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

www.netlib.org/lapack
\end_layout

\end_inset

 respectively.
\end_layout

\begin_layout Standard
These codes do not come as part of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 package, and must be downloaded separately.
 See chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{install}
\end_layout

\end_inset

 for more details of how to do this.
 
\end_layout

\begin_layout Subsection
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 resources
\end_layout

\begin_layout Standard
For more information about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi{}
\end_layout

\end_inset

 and to download the source code go to 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

gle4md.berlios.de 
\end_layout

\end_inset

, where one can also obtain colored-noise parameters to run Path Integral
 with Generalized Langevin Equation thermostat (PI+GLE) calculations.
\end_layout

\begin_layout Chapter
Getting started
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{getstarted}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Installing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{install}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Requirements
\end_layout

\begin_layout Standard
To install and run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, you will need to have:
\end_layout

\begin_layout Itemize
Python version 2.4 or greater
\end_layout

\begin_layout Itemize
The Python numerical library NumPy
\end_layout

\begin_layout Standard
Note that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 does not need to be compiled, it can be run as a script as long as the
 appropriate libraries have been installed.
\end_layout

\begin_layout Standard
Additionally, most client codes will have their own requirements.
 Many of them, including the test client codes given in the 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 directory, will need a suitable Fortran compiler.
 A C compiler is required for the sockets.c wrapper to the sockets standard
 library.
 Most electronic structure codes will also need to be linked with some mathemati
cal libraries, such as BLAS, FFTW and LAPACK.
 Installation instructions for these codes should be provided as part of
 the code distribution and on the appropriate website, as given in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{librarywebsites}
\end_layout

\end_inset

.
 Patching for use with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi{}
\end_layout

\end_inset

 should not introduce further dependencies.
\end_layout

\begin_layout Subsection
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 download
\end_layout

\begin_layout Standard
A tar file can be downloaded from the website 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

gle4md.berlios.de
\end_layout

\end_inset

.
 To install this you need to input the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> tar xf [wrapper_tar_file.tar]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also obtain a local clone of the git repository on 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

bitbucket.org
\end_layout

\end_inset

 using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> git clone [github repository name]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Installing NumPy
\end_layout

\begin_layout Standard
NumPy is the standard Python mathematics library, and is used for most of
 the array manipulation and linear algebra in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

.
 It should be installed alongside most standard Python environments on HPC
 facilities.
 Otherwise, it is generally relatively straightforward to install it.
 
\end_layout

\begin_layout Standard
In any case you must first obtain the NumPy code, which can be downloaded
 as a tar file from 
\begin_inset Flex URL
status open

\begin_layout Plain Layout

http://www.numpy.org
\end_layout

\end_inset

.
 If the version of NumPy being installed is given by 
\begin_inset Quotes eld
\end_inset

np_vers
\begin_inset Quotes erd
\end_inset

, this can be extracted using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> tar czf np_vers.tar.gz
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before installing this code it first needs to be configured correctly.
 Note that this requires the distutils package that comes with the python-dev
 package.
 Assuming that the required software is installed, the NumPy package is
 built using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py build
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to install NumPy.
 By default the download is to the directory /usr/local.
 If you have root access, and so can write to /usr, then all that needs
 to be done to finish the install is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you do not have root access, then the next step depends on which version
 of Python is beind used.
 With versions 2.6 or later there is a simple command to automatically download
 into the directory $HOME/local:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --user
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With Python 2.4/2.5 the process is a little more involved.
 First you must explicitly install the package in the directory of choice,
 
\begin_inset Quotes eld
\end_inset

np_dir
\begin_inset Quotes erd
\end_inset

 say, with the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --prefix=np_dir
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, you must tell python where to find this library, by appending to the
 Linux environment variable 
\series bold
PYTHONPATH
\series default
.
 If you are using Python version 
\begin_inset Quotes eld
\end_inset

py_vers
\begin_inset Quotes erd
\end_inset

, then the NumPy libraries will have been installed in the directory 
\begin_inset Quotes eld
\end_inset

np_dir/lib/py_vers/site-packages
\begin_inset Quotes erd
\end_inset

, or a close analogue of this.
 In the above case the following command will allow the Python interpreter
 to find the NumPy libraries:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> export PYTHONPATH=$PYTHONPATH:np_dir/lib/py_vers/site-packages
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now Python scripts can import the NumPy libraries using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

import numpy
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
PyFFTW
\end_layout

\begin_layout Standard
Some of the steps in the dynamics algorithm involve a change of variables
 from the bead coordinates to the normal modes of the ring polymers.
 Currently, this transformation is, at least by default, computed using
 a fast-Fourier transform (FFT) library within the NumPy distribution.
 This however is not the only distribution that could be used, and indeed
 faster stand-alone versions exist.
 The gold-standard FFT library is the FFTW library, which is a set of C
 libraries that have been heavily optimized for a wide range of applications.
 There have been a number of Python wrappers around the FFTW library, one
 of which is currently interfaced with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

.
 This code can be found at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/hgomersall/pyFFTW
\end_layout

\end_inset

, and has documentation at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://hgomersall.github.io/pyFFTW/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This code has the following dependencies:
\end_layout

\begin_layout Itemize
Python version 2.7 or greater
\end_layout

\begin_layout Itemize
Numpy version 1.6 or greater
\end_layout

\begin_layout Itemize
FFTW version 3.2 or greater
\end_layout

\begin_layout Standard
This can be installed in the same way as NumPy, except using the code distributi
on above, or using various installation packages as per the instructions
 on the above documentation.
 Note that no other options need to be specified in the input file, the
 wrapper will check to see if this library is available, and if it is it
 will be used by default.
 Otherwise the slower NumPy version will be used.
\end_layout

\begin_layout Section
Clients
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Here there should 
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Minimal client code
\end_layout

\begin_layout Subsection
Patching CP2K
\end_layout

\begin_layout Subsection
Patching Quantum-Espresso
\end_layout

\begin_layout Standard
You can download the source code for Quantum Espresso at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espresso.org/
\end_layout

\end_inset

.
 The tar file can be extracted in the same way as the Python and NumPy libraries
 above.
 However, before this can run with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, the code must be adapted to use the socket interface.
 For Quantum Espresso version 4.3.2, there is a patch file to allow it to
 be used as a client code with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 in the directory 
\begin_inset Quotes eld
\end_inset

patches/pwscf
\begin_inset Quotes erd
\end_inset

.
 If you are currently in the top level directory of the Quantum-Espresso
 distribution, the patch can be applied to the source code using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> patch -p1 < i-pi/patches/pwscf/pw-driver.patch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, continue the compilation as per the instructions at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espress.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Writing a patch
\end_layout

\begin_layout Section
Running 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Running the server code
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulations are run using the i-pi Python script found in the 
\begin_inset Quotes eld
\end_inset

i-pi
\begin_inset Quotes erd
\end_inset

 directory.
 This script takes an xml-formatted file as input, and automatically starts
 a simulation as specified by the data held in it.
 If the input file is called 
\begin_inset Quotes eld
\end_inset

input_file.xml
\begin_inset Quotes erd
\end_inset

, then the wrapper is run using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python i-pi input_file.xml
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This reads in the input data, initializes all the internally used objects,
 and then creates the server socket.
 The code will then wait until at least one client code has connected to
 the server before running any dynamics.
 Note that until this has happened the code is essentially idle, the only
 process that it runs is to periodically poll for incoming connections.
\end_layout

\begin_layout Subsection
Running the client code
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{runningclients}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
CP2K
\end_layout

\begin_layout Standard
To use CP2K as the client code, an additional file named 
\begin_inset Quotes eld
\end_inset

serverfile
\begin_inset Quotes erd
\end_inset

 must be kept in the same directory that CP2K is being run from.
 It should contain a string a single line long, of the format 
\begin_inset Quotes eld
\end_inset

mode:host:port_number
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 should either be 
\begin_inset Quotes eld
\end_inset

INET
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

UNIX
\begin_inset Quotes erd
\end_inset

, representing an internet or unix socket respectively.
 The rest of the input file is the same as for a standard CP2K calculation.
\end_layout

\begin_layout Subsubsection
Quantum-Espresso
\end_layout

\begin_layout Standard
To use Quantum-Espresso as the client code using a socket on the host address
 
\begin_inset Quotes eld
\end_inset

host_address
\begin_inset Quotes erd
\end_inset

 and on the port number 
\begin_inset Quotes eld
\end_inset

port
\begin_inset Quotes erd
\end_inset

 we would add the following lines to the input file:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we wanted to run on a UNIX port instead of an INET port, we would instead
 write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`UNIX:host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of the input file should be the same as for a standard Quantum
 Espresso calculation, as explained at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espress.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Running simulations
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{runningsimulations}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
There are two parts to any 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation.
 First the server code is run, which starts the dynamics loop until the
 forces are required.
 Once the server socket has been opened, it then waits for connections from
 client codes.
 
\end_layout

\begin_layout Standard
For a small simulation, with a simple classical potential, it may be preferable
 to run both halves of the simulation on the same computer, especially as
 this allows us to use the faster unix domain sockets.
 This can be done using a single script, such as:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#These are the parameters that need to be specified by
\end_layout

\begin_layout Plain Layout

#the user.
 The number of client codes is given by $nclients,
\end_layout

\begin_layout Plain Layout

#the i-pi source directory containing the i-pi script
\end_layout

\begin_layout Plain Layout

#is given by $src_dir, and the code that runs one of 
\end_layout

\begin_layout Plain Layout

#the client codes is given by $client_comm
\end_layout

\begin_layout Plain Layout

inputfile=...
\end_layout

\begin_layout Plain Layout

hostname=...
\end_layout

\begin_layout Plain Layout

port=...
\end_layout

\begin_layout Plain Layout

nclients=...
\end_layout

\begin_layout Plain Layout

src_dir=...
\end_layout

\begin_layout Plain Layout

client_comm="..."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#This modifies the input file.
 If necessary, the client code
\end_layout

\begin_layout Plain Layout

#input file should be modified here too
\end_layout

\begin_layout Plain Layout

sed -i "s/<address>[^<]*</<address>$hostname</" $inputfile
\end_layout

\begin_layout Plain Layout

sed -i "s/<port>[^<]*</<port>$port</" $inputfile
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if [ -e EXIT ]; then
\end_layout

\begin_layout Plain Layout

   rm EXIT 
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Runs the simulation, and redirects the server
\end_layout

\begin_layout Plain Layout

#standard output to a file named 'log'.
\end_layout

\begin_layout Plain Layout

bash -c "python $src_dir/i-pi $inputfile > log &"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sleep 20 #must wait for server to be initialized
\end_layout

\begin_layout Plain Layout

for a in `seq 1 $nclients`; do
\end_layout

\begin_layout Plain Layout

   bash -c "$client_comm"
\end_layout

\begin_layout Plain Layout

done 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, for most simulations, especially those running with expensive 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 forces and potentials, we will want to run the client codes on a computational
 cluster.
 Here we run the server code elsewhere, and use internet sockets for the
 communication.
\end_layout

\begin_layout Standard
To run the client on a cluster computer, two major changes must be implemented.
 Firstly, the code required to run the client code should be separated from
 that of the server code.
 Secondly, the client script should be executed using a queueing program
 such as qsub rather than the bash shell script as above, and so will need
 to have the appropriate directive comment lines.
 Depending on which cluster is used, additional commands to set parameters
 such as the walltime, number of nodes and number of cores can be used.
 Check the qsub man page for the cluster you are running the code on for
 more details.
\end_layout

\begin_layout Standard
One possible script layout to run the client codes would be:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#$ -S /bin/bash
\end_layout

\begin_layout Plain Layout

#$ -N jobname
\end_layout

\begin_layout Plain Layout

#$ ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#use this if there are library files needed
\end_layout

\begin_layout Plain Layout

#by the client code that are not on the default path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#export LD_LIBRARY_PATH=...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#use this if ssh tunnelling is required
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#server_host=...
 #the server host address
\end_layout

\begin_layout Plain Layout

#server_port=...
 #the server port number
\end_layout

\begin_layout Plain Layout

#cluster_port=...
 #the cluster port number
\end_layout

\begin_layout Plain Layout

#ssh -f -N $server_host -L $cluster_port:$server_host:$server_port
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

inputfile=...
\end_layout

\begin_layout Plain Layout

hostname=...
\end_layout

\begin_layout Plain Layout

port=...
\end_layout

\begin_layout Plain Layout

client_comm="..."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Modify client input file if necessary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bash -c "client_comm"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that it may be necessary to export libraries or modules if they are
 not present by default, or to use an ssh tunnel if the cluster is not open
 to the internet (see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ssh_sockets}
\end_layout

\end_inset

).
\end_layout

\begin_layout Standard
To set up multiple concurrent 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulations each host socket has to be distinguishable, so that the client
 codes appropriate to each simulation connect only to the correct server.
 This can be done with internet sockets by adjusting the port number for
 each simulation, which then acts as a unique identifier for each of the
 server codes.
 The above shell scripts can be easily modified to do this, for example
 if we assume the simulations will be run in directories called sim_1, sim_2,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

, then we can write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

first_port=...
 #The value of the port of sim_1
\end_layout

\begin_layout Plain Layout

i=0
\end_layout

\begin_layout Plain Layout

for a in sim_*; do #finds all directories in which we wish to run simulations
\end_layout

\begin_layout Plain Layout

   cd $a
\end_layout

\begin_layout Plain Layout

   port=$((first_port+i))
\end_layout

\begin_layout Plain Layout

   ((i++))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   #here we run the code for one simulation as before
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   cd ..
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
A simple tutorial
\end_layout

\begin_layout Standard
\begin_inset Note Note
status open

\begin_layout Plain Layout
Here there should be a step-by-step guide on how to run a specific example
 (which we could have in the tests directory as 
\begin_inset Quotes eld
\end_inset

tutorial
\begin_inset Quotes erd
\end_inset

) with as many features as possible.
 E.g.
 PIMD (not piglet) of p-H2 with NPT.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Here we will go through a simple step-by-step guide through an example simulatio
n, starting from a minimal xml input file and then exploring some of the
 more generally useful options that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 offers, and making no assumptions of previous experience of this code or
 other MD codes.
 Exercepts from the relevant input files are reproduced here, for explanation
 purposes, but to get the most out of this tutorial the user is encouraged
 to work through them themselves.
 For this purpose, the input files have been included with the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 distribution, in the 
\begin_inset Quotes eld
\end_inset

test/tutorial
\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Standard
The example is a small NPT simulation of para-hydrogen, using the Silvera-Goldma
n potential 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{???}
\end_layout

\end_inset

.
 We will take (N,P,T) = (108, 0, 25 K).
\end_layout

\begin_layout Standard
Finally, note that this is designed to be a demonstration of some of the
 basic abilities of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, and so the user is encouraged to play with some of the variables to get
 a feel for how the input file works.
\end_layout

\begin_layout Subsection
Part 0 - a minimal input file
\end_layout

\begin_layout Subsubsection
Client code
\end_layout

\begin_layout Standard
Let us now consider the problem of how to use 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 to run an NPT simulation of para-hydrogen.
 The first thing that is required is a client code that is capable of calculatin
g the potential interactions of para-hydrogen molecules.
 Fortunately, one of the client codes distributed with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 has an appropriate empirical potential already hard-coded into it (hence
 why this system was chosen for this tutorial), and so all that is required
 is to create the 
\begin_inset Quotes eld
\end_inset

driver.x
\begin_inset Quotes erd
\end_inset

 file in the 
\begin_inset Quotes eld
\end_inset

drivers
\begin_inset Quotes erd
\end_inset

 directory, using the UNIX utility make.
\end_layout

\begin_layout Standard
This client code can be used for several different problems, which are explored
 in the 
\begin_inset Quotes eld
\end_inset

tests
\begin_inset Quotes erd
\end_inset

 directory, but for the current problem we need to use the Silvera-Goldman
 potential with a cut-off radius of 15 bohr radii.
 This is run using the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ./driver.x -m sg -u -h localhost -o 15
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The option 
\begin_inset Quotes eld
\end_inset

-m
\begin_inset Quotes erd
\end_inset

 is followed by the empirical potential required, in this case we use 
\begin_inset Quotes eld
\end_inset

sg
\begin_inset Quotes erd
\end_inset

 for Silvera-Goldman, 
\begin_inset Quotes eld
\end_inset

-u
\begin_inset Quotes erd
\end_inset

 gives a unix domain socket, 
\begin_inset Quotes eld
\end_inset

-h localhost
\begin_inset Quotes erd
\end_inset

 sets up the client hostname as 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

-o 15
\begin_inset Quotes erd
\end_inset

 sets the cut-off to 15 bohr radii, as required.
 
\end_layout

\begin_layout Standard
Note that usually this step will require setting up an the appropriate client
 code input files, possibly for an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 electronic structure code, and so is generally a more involved process.
 Refer to 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{runningclients}
\end_layout

\end_inset

, or the documentation of the appropriate client code, for more details
 on how to do this step.
\end_layout

\begin_layout Subsubsection
Creating the xml input file
\end_layout

\begin_layout Standard
Now that the client code is ready, an appropriate xml input file needs to
 be created from which the host server and the simulation data can be initialize
d.
 Here, we will go step by step through the creation of a minimal input file
 for a simple NVT equilibration run.
 Note that the working final version is held within the 
\begin_inset Quotes eld
\end_inset

tutorial-0
\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Standard
Firstly, the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 xml reading functions first look for a 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 tag as a sign to start reading data.
 For those familiar with xml jargon, we have defined 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 as the root tag, so all the input data read in must start and end with
 a 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 tag, as show below:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

   Input data here...
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
xml syntax requires a set of hierarchially nested tags, each of which contain
 either data or more tags.
 Also, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 itself requires certain tags to be present, and keeps track of which tags
 are supposed to be where.
 More information about which tags are available can be found in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{hierarchy}
\end_layout

\end_inset

, more information on xml syntax can be found in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ifilestructure}
\end_layout

\end_inset

, and possible errors which can occur if the input file is not well formed
 can be found in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{trouble}
\end_layout

\end_inset

.
 For the sake of this first tutorial however, we will simply discuss the
 mandatory tags: 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

.
 These correspond to the tag to initialize the atom configurations, the
 tag to specify the client code and the tag to define the appropriate ensemble
 respectively.
\end_layout

\begin_layout Standard
At this point then, the input file looks like:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

   <initialize>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </initialize>
\end_layout

\begin_layout Plain Layout

   <forces>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </forces>
\end_layout

\begin_layout Plain Layout

   <ensemble>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now let us consider each of these tags in turn.
 Firstly, 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

.
 As the name suggests, this initializes the state of the system, so this
 is where we will specify the initial atom positions and the cell parameters.
 Firstly, this takes an attribute which specifies the number of replicas
 of the system, called 
\begin_inset Quotes eld
\end_inset

nbeads
\begin_inset Quotes erd
\end_inset

.
 An attribute is a particular type of xml syntax designed to specify a single
 bit of data, and has the following syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <initialize nbeads='4'>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </initialize>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that an attribute forms part of the opening tag, and that the value
 being assigned to it is held within quotation marks.
 In this case, we have set the number of replicas, or beads, to 4.
\end_layout

\begin_layout Standard
Next, we must specify the atomic configuration.
 Rather than initialize the atom positions manually, we will assume that
 the user can create a xyz file with the appropriate data.
 This is the simplest input format for a configuration file that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 accepts, and it has the following syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

natoms
\end_layout

\begin_layout Plain Layout

# COMMENT LINE: PUT TITLE OF FILE HERE
\end_layout

\begin_layout Plain Layout

atom1   x1  y1  z1
\end_layout

\begin_layout Plain Layout

atom2   x2  y2  z2
\end_layout

\begin_layout Plain Layout

...
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Quotes eld
\end_inset

natoms
\begin_inset Quotes erd
\end_inset

 is replaced by an integer giving the total number of atoms, in this case
 108, atom1 is a label for atom 1, in this case H2 (since we are simulating
 para-hydrogen), and (x1, y1, z1) are the x, y and z components of atom
 1 respectively.
 Note that this file is free-formatted, and so the precision of each of
 the position coordinates is arbitrary.
 Also note that visualization software such as VMD will be able to read
 this file format, and so it is generally advised to use such software to
 make sure that the configuration is as expected.
 For the sake of this tutorial, we have included a valid xyz input file
 in the 
\begin_inset Quotes eld
\end_inset

tutorial-0
\begin_inset Quotes erd
\end_inset

 directory called 
\begin_inset Quotes eld
\end_inset

our_ref.xyz
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
To use this reference file, we will use the 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 tag in initialize.
 This will take an input file with a given name, and use it to initialize
 all relevant data.
 In this case, since the xyz file format has both positions and atom labels,
 it will initialize the positions, labels and masses of all the particles
 in the system, with the masses being implicitly set based on the atom label.
 We must also tell it which file type is being used using the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute.
 Putting this together gives:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <initialize nbeads='4'>
\end_layout

\begin_layout Plain Layout

      <file mode='xyz'> our_ref.xyz </file>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </initialize>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The only remaining mandatory parameters that have not been initialized are
 the cell parameters.
 These could in theory be set using a separate file, but here we will initialize
 them manually.
 Taking a cubic cell with cell parameter 33.72594 bohr radii, we can specify
 this using the 
\begin_inset Quotes eld
\end_inset

cell
\begin_inset Quotes erd
\end_inset

 tag in three different ways:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      <cell mode='manual'> 
\end_layout

\begin_layout Plain Layout

         [33.72594, 0, 0, 0, 33.72594, 0, 0, 0, 33.72594] 
\end_layout

\begin_layout Plain Layout

      </cell>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      <cell mode='abcABC'>
\end_layout

\begin_layout Plain Layout

         [33.72594, 33.72594, 33.72594, 90, 90, 90]
\end_layout

\begin_layout Plain Layout

      </cell>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

      <cell mode='abc'>
\end_layout

\begin_layout Plain Layout

         [33.72594, 33.72594, 33.72594]
\end_layout

\begin_layout Plain Layout

      </cell>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note the use of the different 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attributes, 
\begin_inset Quotes eld
\end_inset

manual
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

abcABC
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

.
 The first creates the cell vector matrix manually, the second takes the
 length of the three unit vectors and the angles between them in degrees,
 and the last assumes an orthorhombic cell and so only takes the length
 of the three unit vectors as arguments.
 We will take the last version for brevity, giving as our final 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 section:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <initialize nbeads='4'>
\end_layout

\begin_layout Plain Layout

      <file mode='xyz'> our_ref.xyz </file>
\end_layout

\begin_layout Plain Layout

      <cell mode='abc'>
\end_layout

\begin_layout Plain Layout

         [33.72594, 33.72594, 33.72594]
\end_layout

\begin_layout Plain Layout

      </cell>
\end_layout

\begin_layout Plain Layout

   </initialize>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next lets consider the 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 section, which deals with communication with the client codes.
 Since in this case we only have one type of client code which will be using
 sockets for communication, we will specify a single 
\begin_inset Quotes eld
\end_inset

sockets
\begin_inset Quotes erd
\end_inset

 tag to initialize it:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <forces>
\end_layout

\begin_layout Plain Layout

      <socket>
\end_layout

\begin_layout Plain Layout

         ...
\end_layout

\begin_layout Plain Layout

      </socket>
\end_layout

\begin_layout Plain Layout

   </forces>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A socket is specified with three parameters; the port number, the hostname
 and whether it is a unix or an internet socket.
 Here for simplicity (and to match up with the client socket specified above)
 we will take a unix socket, which uses the hostname localhost, and does
 not need a port number to be specified.
 This gives the final 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 section:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <forces>
\end_layout

\begin_layout Plain Layout

      <socket mode="unix">
\end_layout

\begin_layout Plain Layout

         <hostname> localhost </hostname>
\end_layout

\begin_layout Plain Layout

      </socket>
\end_layout

\begin_layout Plain Layout

   </forces>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The last section that we will need is the ensemble, which determines how
 the dynamics integrator will be initialized.
 Since we wish to do a NVT simulation, we set the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute to 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

, and must specify the temperature using the appropriate tag:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <ensemble mode='nvt'>
\end_layout

\begin_layout Plain Layout

      <temperature> 25 </temperature>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This defines the ensemble that will be sampled.
 We also must decide which integration algorithm to use, and how large the
 time step should be.
 In general, the time step should be made as large as possible without there
 being a drift in the conserved quantity.
 Usually we would take a few short runs with different time steps to try
 and optimize this, but for the sake of this tutorial we will use a safe
 value of 40 atomic time units, giving:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

   <ensemble mode='nvt'>
\end_layout

\begin_layout Plain Layout

      <temperature> 25 </temperature>
\end_layout

\begin_layout Plain Layout

      <timestep> 40 </timestep>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, while the free-particle evolution part of the integrator is initialized
 automatically, there are several different options for the constant temperature
 sampling algorithm.
 For simplicity we will take the path-integral Langevin equation (PILE)
 algorithm 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{???}
\end_layout

\end_inset

, which is specifically designed for path integral simulations, and since
 we are trying to equilibrate local properties we will take the local version
 of this, 
\begin_inset Quotes eld
\end_inset

pile_l
\begin_inset Quotes erd
\end_inset

.
 This integrator also has to be initialized with a time scale parameter,
 
\begin_inset Quotes eld
\end_inset

tau
\begin_inset Quotes erd
\end_inset

, which determines how strong the thermostat is.
 Since we have a local thermostat the appropriate time scales will be fairly
 short, so we will take a short time scale of 1000 atomic time units.
 Putting all of this together, we get the final input file:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

   <initialize nbeads='4'>
\end_layout

\begin_layout Plain Layout

      <file mode='xyz'> our_ref.xyz </file>
\end_layout

\begin_layout Plain Layout

      <cell mode='abc'>
\end_layout

\begin_layout Plain Layout

         [33.72594, 33.72594, 33.72594]
\end_layout

\begin_layout Plain Layout

      </cell>
\end_layout

\begin_layout Plain Layout

   </initialize>
\end_layout

\begin_layout Plain Layout

   <forces>
\end_layout

\begin_layout Plain Layout

      <socket mode="unix">
\end_layout

\begin_layout Plain Layout

         <hostname> localhost </hostname>
\end_layout

\begin_layout Plain Layout

      </socket>
\end_layout

\begin_layout Plain Layout

   </forces>
\end_layout

\begin_layout Plain Layout

   <ensemble mode='nvt'>
\end_layout

\begin_layout Plain Layout

      <temperature> 25 </temperature>
\end_layout

\begin_layout Plain Layout

      <timestep> 40 </timestep>
\end_layout

\begin_layout Plain Layout

      <thermostat mode='pile_l'>
\end_layout

\begin_layout Plain Layout

         <tau> 1e3 </tau>
\end_layout

\begin_layout Plain Layout

      </thermostat>
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Running the simulation
\end_layout

\begin_layout Standard
Now that we have a valid input file, we can run the test simulation.
 The 
\begin_inset Quotes eld
\end_inset

i-pi
\begin_inset Quotes erd
\end_inset

 script in the root directory is used to create an 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation from a xml input file.
 More information on how to run this code can be found in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{runningsimulations}
\end_layout

\end_inset

, but all that is required in this case is (if we assume that we are in
 the 
\begin_inset Quotes eld
\end_inset

tutorial-0
\begin_inset Quotes erd
\end_inset

 directory):
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python ../../../i-pi tutorial-0.xml
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will start the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation, creating the server socket and initializing the simulation
 data.
 This should at this point print out a header message to standard output,
 followed by a few information messages that end with 
\begin_inset Quotes eld
\end_inset

starting the polling thread main loop
\begin_inset Quotes erd
\end_inset

, which signifies that the server socket has been opened and is waiting
 for connections from client codes.
\end_layout

\begin_layout Standard
At this point the driver code is run in a new terminal using the command
 specified above:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ./driver.x -m sg -u -h localhost -o 15
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The wrapper code should now output a message saying that a new client code
 has connected, and start running the simulation.
\end_layout

\begin_layout Subsubsection
Output data
\end_layout

\begin_layout Standard
Once the simulation is finished (which should take about a minute) it should
 have output, by default, one file called 
\begin_inset Quotes eld
\end_inset

i-pi.checkpoint
\begin_inset Quotes erd
\end_inset

 and one called 
\begin_inset Quotes eld
\end_inset

RESTART
\begin_inset Quotes erd
\end_inset

 which have the state of the system saved as it was at the end of the calculatio
n, one file called 
\begin_inset Quotes eld
\end_inset

i-pi.md
\begin_inset Quotes erd
\end_inset

 which contains a log of the values of some of the simple properties of
 the system throughout the simulation, and a set of files 
\begin_inset Quotes eld
\end_inset

i-pi.pos_x.xyz
\begin_inset Quotes erd
\end_inset

 which give the positions of the different replicas of the system at regular
 intervals.
 For an in-depth discussion on these three types of output files see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{outputfiles}
\end_layout

\end_inset

, but for now let us look at each of these specific output files in turn.
\end_layout

\begin_layout Standard
First, consider the file 
\begin_inset Quotes eld
\end_inset

i-pi.checkpoint
\begin_inset Quotes erd
\end_inset

.
 As said above, this gives a snapshot of the state of the simulation.
 Since we didn't specify how often to print out this file the default value
 of once every 1000 time steps was used, so in this case the last checkpoint
 was created at step 999.
 This type of file is designed restart the simulation from, by using it
 as an input file for a new 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation.
 In this case, it will re-run the last step if you use it as an input file
 for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One test of whether the input file was specified correctly is to look at
 the trajectory files 
\begin_inset Quotes eld
\end_inset

i-pi.pos_x.xyz
\begin_inset Quotes erd
\end_inset

 using a visualization program such as VMD.
 If we do this, we see that the simulation started from an essentially optimized
 configuration and then over the course of the simulation began to melt.
 Given that at the state point studied and with the potential given para-hydroge
n is a liquid 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{???}
\end_layout

\end_inset

, this seems reasonable.
 Note however that there is still a noticable amount of order, and so it
 is not certain whether the system has equilibrated yet.
\end_layout

\begin_layout Standard
Another simple test is to check that the conserved quantity does not exhibit
 any long term drift.
\end_layout

\begin_layout Standard
Since we are interested in using this simulation as an equilibration run,
 it makes sense to check whether 
\end_layout

\begin_layout Subsection
Part 1 - Customizing and extending the input file
\end_layout

\begin_layout Standard
In Part 0, we created a minimal input file which could be used to run a
 basic NVT simulation.
 However, this ignored several non-essential but very useful bits of functionali
ty, and so we will now go through the process of improving this generic
 input file so that it is more suitable for an actual simulation.
\end_layout

\begin_layout Section
Testing the install
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{tests}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several test cases are distributed with the code to ensure that your distributio
n is working correctly.
 There are also simple tests to see if the client codes are working correctly.
\end_layout

\begin_layout Standard
All the input files are contained in the directory test, which is subdivided
 into the following directories:
\end_layout

\begin_layout Description
lj: This gives a simple classical Lennard-Jones simulation of Ne.
 The state points are given by (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.35, 1.62), (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.75, 1.069) and (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.88, 1.095) in reduced Lennard-Jones units, so that the results
 can be compared to those in the paper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{lverlet67pr}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
ph2: This simulates para-hydrogen using the isotropic Silvera-Goldman pair
 potential.
 There are three directories, 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 have tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mill-mano05jcp}
\end_layout

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

 has tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mart+99jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
pwscf: This has two simple examples to test to see if the Quantum-Espresso
 client is functioning correctly.
 There is one simple 4-atom lithium test, and a test using a single water
 molecule.
\end_layout

\begin_layout Description
harmonic: This has a simple example of a 1D harmonic oscillator.
 This demonstrates the displaced path integral momentum distribution operator
 as given in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{linlin+10prl}
\end_layout

\end_inset

.
 As the momentum distribution is known analytically for this simple system,
 this provides an indication of how well the method is working.
\end_layout

\begin_layout Description
lammps: This has a simple implementation of the q-TIP4P-F empirical water
 model of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{habe+09jcp}
\end_layout

\end_inset

 using the classical molecular dynamics code LAMMPS.
 It demonstrates both the convergence of the PIGLET method 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{ceri-mano12prl}
\end_layout

\end_inset

, as well as the use of ring-polymer contraction methods 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mark-mano08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Chapter
User guide
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{user}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Input files
\end_layout

\begin_layout Subsection
Input file format and structure
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{ifilestructure}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In order to give the clearest layout, xml formatting was chosen as the basis
 for the for the main input file.
 An xml file consists of a set of hierarchically nested tags.
 There are three parts to an xml tag.
 Each tag is identified by a tag name, which specifies the class or variable
 that is being initialized.
 Between the opening and closing tags there may be some data, which may
 or may not contain other tags.
 In the code this is used to specify the contents of a class object, or
 the value of a variable.
 Finally, any tag can have attributes, which in the code are used for variables
 which specify the state or type of class that will be created.
 A xml tag has the following syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag_name attribute_name='attribute_data'>tag_data</tag_name>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for the different types of tag data is given below: 
\begin_inset Note Note
status open

\begin_layout Plain Layout
Use verbatim for the syntax in the table - JM: If I do that it appears to
 break the lyx table environment.
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="8" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>True</tag> or <tag>False</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>11.111</tag> or <tag>1.1111e+1</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>12345</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>string_data</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag> (int1, int2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 )</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Vector
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag> [ entry1, entry2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ] </tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" bottomline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>{name1: data1, name2: data2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 }</tag>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Note that arrays are always given as one-dimensional lists.
 In cases where a multi-dimensional array must be entered, one can use the
 `shape' attribute, that determines how the list will be reshaped into a
 multi-dimensional array; for instance
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag shape=`(1,2,3)'>[ a111, a112, a113, a121, a122, a123 ]</tag>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

If `shape' is not specified, a 1D array will be assumed.
\end_layout

\begin_layout Standard
The code uses this hierarchical structure to help read the data; if a particular
 object is held within a parent object in the code, then the tag for that
 object will be within the appropriate parent tags.
 This is used to make the structure of the simulation clear.
 For example, the system that is being studied is partly defined by the
 thermodynamic ensemble that should be sampled, which in turn may be partly
 defined by the pressure, and so on.
 In the input file this would be specified by having a 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 tag, containing an 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag, which itself contains a 
\begin_inset Quotes eld
\end_inset

pressure
\begin_inset Quotes erd
\end_inset

 tag, which will contain a float value corresponding to the external pressure.
 In the code itself this will correspond to a simulation object, which will
 contain an ensemble object, which will contain a pressure variable.
 In this manner, the simulation class structure can be constructed iteratively.
\end_layout

\begin_layout Standard
For example, suppose we want to generate a NPT ensemble at an external pressure
 of 1e-7 atomic pressure units.
 This would be specified by the following input file: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

	<ensemble mode='npt'>
\end_layout

\begin_layout Plain Layout

		<pressure> 1e-7 </pressure>
\end_layout

\begin_layout Plain Layout

		...
\end_layout

\begin_layout Plain Layout

	</ensemble>
\end_layout

\begin_layout Plain Layout

	...
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset

To help detect any user error the recognized tag names, data types and acceptabl
e options are all specified in the code in a specialized input class for
 each class of object.
 A full list of all the available tags and a brief description of their
 function is given in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{hierarchy}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsubsection
Overwriting units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{inputunits}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Many of the input parameters, such as the pressure in the above example,
 can be specified in more than one unit.
 Indeed, often the atomic unit is inconvenient to use, and we would prefer
 something else.
 Let us take the above example, but instead take an external pressure of
 3 MPa.
 Instead of converting this to the atomic unit of pressure, it is possible
 to use pascals directly using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

   <ensemble mode=`npt'>
\end_layout

\begin_layout Plain Layout

      <pressure units=`pascal'> 3e6 </pressure>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code can also understand S.I.
 prefixes, so this can be simplified further using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<simulation>
\end_layout

\begin_layout Plain Layout

   <ensemble mode='npt'>
\end_layout

\begin_layout Plain Layout

      <pressure units=`megapascal'> 3 </pressure>
\end_layout

\begin_layout Plain Layout

      ...
\end_layout

\begin_layout Plain Layout

   </ensemble>
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

</simulation>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
A full list of which units are defined for which dimensionalities can be
 found in the units.py module.
\end_layout

\begin_layout Subsection
Initialization section
\end_layout

\begin_layout Subsubsection
Configuration files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{configfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Instead of initializing the atom positions manually, the starting configuration
 can be specified through a separate data file.
 The name of the configuration file is specified within the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag name with the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute given by the file format.
 The currently accepted file formats are:
\end_layout

\begin_layout Itemize
pdb
\end_layout

\begin_layout Itemize
xyz
\end_layout

\begin_layout Standard
This file can be used either to initialize one variable only, or instead
 to initialize multiple attributes by using the 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 tag name.
 This will initialize the atom positions, labels, masses and possibly the
 cell parameters together.
\end_layout

\begin_layout Subsubsection
Initialization from checkpoint files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 gives the option to output the entire state of the system at particular
 timesteps as an xml input file, called a checkpoint file (see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{checkpoint}
\end_layout

\end_inset

 for details).
 As well as being a valid input file, a checkpoint can also be used as an
 input data file in the same way that the configuration files are.
 This is specified in the input by using 
\begin_inset Quotes eld
\end_inset

chk
\begin_inset Quotes erd
\end_inset

 as the value of the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute.
 As for the configuration file, a checkpoint file can be used to initialize
 either one or many variables depending on which tag name is used.
\end_layout

\begin_layout Standard
There is also an ensemble type, 
\begin_inset Quotes eld
\end_inset

replay
\begin_inset Quotes erd
\end_inset

, which takes a configuration file with multiple frames or a checkpoint
 file with one frame and reruns it without doing dynamics, by simply setting
 the configuration to match that given by the input file at each frame.
 This can then be used to calculate properties of interest along a trajectory
 that has already been finished, if the user forgot to calculate them the
 first time around.
\end_layout

\begin_layout Section
Output files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{outputfiles}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 uses a very flexible mechanism to specify how and how often atomic configuratio
ns and physical properties should be output.
 Within the 
\begin_inset Quotes eld
\end_inset

output
\begin_inset Quotes erd
\end_inset

 tag of the xml input file the user can specify multiple tags, each one
 of which will correspond to a particular output file.
 Each file is managed separately by the code, so what is output to a particular
 file and how often can be adjusted independently of the same parameters
 for a different file.
 It is also possible to have multiple instances of the same type of file.
\end_layout

\begin_layout Standard
For example, some of the possible output properties require more than one
 force evaluation per time step to calculate, and so can considerably increase
 the computational cost of a simulation.
 On the other hand, for properties such as the conserved energy quantity
 it is easy, and often useful, to output them every time step as they are
 simple to compute and do not take long to output to file.
 In this case it is most efficient to only output the expensive property
 rarely, which would be done by outputting this to a different file to the
 ones that are being used to keep track of the conserved quantity, and use
 a larger number of time steps between successive writes to this file.
\end_layout

\begin_layout Standard
There are three types of output file that can be specified; property files
 for system level properties, trajectory files for atom/bead level properties
 and checkpoint files which save the state of the system and so can be used
 to restart the simulation from a particular point.
 These will now be considered in turn.
\end_layout

\begin_layout Subsection
Properties
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{propertyfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the output file for all the system and simulation level properties,
 such as the total energy and the time elapsed.
 The file starts by a header, which describes the properties being written
 on the different columns, and their units of measure.
 This is followed by the actual data.
 Each line corresponds to one instant of the simulation, and the different
 columns match the description provided in the header.
 The file is fixed formatted, with two blank characters at the start of
 each row, then the data in the same order as the header row.
 Each column is 16 characters wide and every float is written in exponential
 format with 8 digits after the decimal point.
\end_layout

\begin_layout Standard
The properties that are output are determined by the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag in the xml input file.
 The format of this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<properties stride=`' filename=`' flush=`' shape=`'>
\end_layout

\begin_layout Plain Layout

   [ prop1name{units}(arg1; ...
 ), prop2name{...}(...), ...
  ]
\end_layout

\begin_layout Plain Layout

</properties>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The attributes have the following meanings:
\end_layout

\begin_layout Description
stride The number of steps between each output to file
\end_layout

\begin_layout Description
filename The name of the output file
\end_layout

\begin_layout Description
flush The number of steps between flushing the buffer
\end_layout

\begin_layout Standard
This tag data is an array of strings, each of which containing three different
 parts:
\end_layout

\begin_layout Itemize
The property name, which describes which type of property is to be output.
 This is a mandatory part of the string.
\end_layout

\begin_layout Itemize
The units that the property will be output in.
 These are specified between curly brackets.
 If this is not specified, then the property will be output in atomic units.
\end_layout

\begin_layout Itemize
The arguments to be passed to the function.
 These are specified between standard brackets, with each argument separated
 by a semi-colon.
 These may or may not be mandatory depending on the property.
 The arguments can be specified by either of two different syntaxes, (name1=arg1
; 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ) or (arg1; 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ).
 The first explicitly assigns the argument with the name 
\begin_inset Quotes eld
\end_inset

name1
\begin_inset Quotes erd
\end_inset

 the value 
\begin_inset Quotes eld
\end_inset

arg1
\begin_inset Quotes erd
\end_inset

, whereas the second relies on the arguments being specified in the correct
 order, as defined in the relevant function in the property.py module.
 The two syntaxes may be mixed, but positional arguments must be specified
 first otherwise undefined behaviour will result.
 If no arguments are specified, then the defaults as defined in the properties.py
 module will be used.
\end_layout

\begin_layout Standard
The different available property names are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{input_docs/property_list}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Trajectory files
\end_layout

\begin_layout Standard
These are the output file for atomic or bead level properties, such as the
 bead positions.
 Each trajectory that should be output is specified by the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 tag in the input file.
 The allowable file formats for the trajectory output files are the same
 as for the configuration input files, given in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{configfile}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
These tags have the format:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<trajectory stride=`' filename=`' format=`' cell_units=`'
 flush=`' bead=`'>
\end_layout

\begin_layout Plain Layout

   traj_name{units}(arg1;...)
\end_layout

\begin_layout Plain Layout

</trajectory>
\backslash
end{verbatim}
\end_layout

\end_inset

This is very similar to the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag, but it has the additional tags 
\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cell_units
\begin_inset Quotes erd
\end_inset

, and only one trajectory can be specified per file.
 `format' specifies the format of the output file, and `cell_units' specifies
 the units in which the cell dimensions are output.
 Depending on the chosen trajectory to output, it will either print a file
 per bead or per atom.
 If the trajectory is output per bead then the output files will be 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 with the bead index appended, so as to distinguish between the trajectories
 of each bead.
 In this case it is also possible to only output one trajectory by specifying
 the 
\begin_inset Quotes eld
\end_inset

bead
\begin_inset Quotes erd
\end_inset

 attribute.
 
\end_layout

\begin_layout Standard
The possible choices of output trajectories are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{input_docs/trajectory_list}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Checkpoint files
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{checkpoint}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
As well as the above output files, the state of the system at a particular
 time step can also be saved to file.
 These checkpoint files can be used as valid input files, with all the informati
on required to restore the state of the system to the point at which the
 file was created.
 
\end_layout

\begin_layout Standard
The syntax for this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'>
\end_layout

\begin_layout Plain Layout

   step
\end_layout

\begin_layout Plain Layout

</checkpoint>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, this is similar to the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tags, but instead of having a value which specifies what to output, the
 value simply gives a number to identify the current checkpoint file.
 There is also one additional attribute, 
\begin_inset Quotes eld
\end_inset

overwrite
\begin_inset Quotes erd
\end_inset

, which specifies whether each new checkpoint file overwrites the old one,
 or whether all checkpoint files are kept.
 If they are kept, they will be written not to the file 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

, but instead an index based on the value of 
\begin_inset Quotes eld
\end_inset

step
\begin_inset Quotes erd
\end_inset

 will be appended to it to distinguish between different files.
\end_layout

\begin_layout Standard
If the `step' parameter is not specified, the following syntax can also
 be used:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'/>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Soft exit and RESTART
\end_layout

\begin_layout Standard
As well as checkpoint files during a simulation run, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi{}
\end_layout

\end_inset

 also creates a checkpoint automatically at the end of the simulation, with
 file name 
\begin_inset Quotes eld
\end_inset

RESTART
\begin_inset Quotes erd
\end_inset

.
 In the same way as t
\end_layout

\begin_layout Standard
he checkpoint files generated above it contains the state of the system
 as created by the wrapper, but it doesn't need to be asked for by the user
 in the input file.
 Its purpose is that if the user decides that insufficient steps were used
 in an already completed simulation, then this file can be used to continue
 from where it ended.
\end_layout

\begin_layout Standard
To stop the program in such a way that it makes sure to save the data generated
 in a restart file, simply create a file 
\begin_inset Quotes eld
\end_inset

EXIT
\begin_inset Quotes erd
\end_inset

 in the directory in which the code is running.
 The thread handler will automatically detect this and safely shut down
 the program, outputting the restart file as detailed above.
 
\end_layout

\begin_layout Standard
An important point to note is that since each time step is split into several
 parts, it is only at the beginning of each step that all the variables
 are consistent with each other in such a way that the simulation can be
 restarted from them without changing the dynamics.
 Thus if a soft exit call is made during a step, then the restart file that
 is created must correspond to the state of the system at the start of the
 step.
 To this end, the state of the system is saved at the start of every step.
\end_layout

\begin_layout Section
Distributed execution
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{distrib}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Sockets
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 only creates a server, it must interface with a client code in order to
 run any simulations.
 The overarching design principle of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is that these two codes should be as independent as possible, and so the
 only communication between them is done through a socket.
 A socket is a data transfer device that is designed for internet communication,
 so supports both multiple client connections to the same server and two
 way communication.
 This makes sockets ideal for use in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, where each calculation may require multiple client codes.
 
\end_layout

\begin_layout Standard
Sockets are described by an IP address and a port number, and can either
 be an internet socket, capable of inter-computer communication, or a unix
 socket, which is optimized for local communication.
 The IP address is input by the user in the 
\begin_inset Quotes eld
\end_inset

address
\begin_inset Quotes erd
\end_inset

 tag, and can be specified in two ways.
 Firstly, every network has a unique numeric code of the form 123.45.678.901.
 Secondly, most networks are named, so the name of the network on which
 the server code is running can be used as an alias for the IP address.
 A specific case of this is 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

, which is the generic name for the local network used by unix sockets.
\end_layout

\begin_layout Standard
The port number is an integer between 1 and 65535 used to distinguish between
 all the different sockets open on a particular computer.
 As many of the lower numbers are protected for use in important system
 processes or internet communication, it is generally advisable to only
 use numbers in the range 1025-65535 for simulations.
\end_layout

\begin_layout Standard
There are two modes of socket, internet and unix.
 Unix sockets are optimized for local communication, whereas internet sockets
 can be used to connect to one computer from another.
 While they are faster than internet sockets, unix sockets should only be
 used if a simple empirical potential is being run, since they are far less
 flexible.
 Also, if complicated empirical potentials or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 potentials are used the force calculation becomes the bottleneck in the
 code, so the advantage of using unix sockets is lost.
 
\end_layout

\begin_layout Standard
Internet sockets have two main advantages that make them much more useful
 in general.
 Firstly, the client code does not need to be run on the same computer as
 the server code.
 In particular, if the client codes are being run on a cluster this means
 that you do not need to waste computing resources running the server, which
 is idle most of the time.
 Secondly, the port number is not used for unix sockets, so if more than
 one calculation is being run concurrently internet sockets must be used,
 so that the client codes connect to the correct server code.
\end_layout

\begin_layout Standard
There are a two other input parameters that may be used to specify how the
 server socket looks for client codes to connect to.
 
\begin_inset Quotes eld
\end_inset

latency
\begin_inset Quotes erd
\end_inset

 specifies the length of time between each check to see if any new client
 codes have connected, and 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 specifies how many client codes can queue between checks.
 Neither is likely to be important in getting the code to run, but may be
 used to optimize the connection time if required.
\end_layout

\begin_layout Subsubsection
Data transfer
\end_layout

\begin_layout Standard
Once at least one client code has connected to the server socket, the force
 calculation can start.
 For this to happen the client code needs the system configuration, and
 likewise the server needs the force and potential data to be returned so
 that it can continue propagating the dynamics.
\end_layout

\begin_layout Standard
To make sure that the connection is good, a simple query-response data transfer
 protocol is used.
 Before any data is sent through the socket a header string of 12 characters
 is sent to verify which stage of the calculation the server is at.
 Once the client sends the appropriate response header string, the data
 is transferred.
 If no response is given, the server will either wait and try again, or
 disconnect the client code and reassign its job to another, depending on
 the severity of the problem.
 The server assumes that 4-bit integers, 8-bit floats and 1-bit characters
 are used.
 A typical step is of the form:
\end_layout

\begin_layout Enumerate
A header string of 
\begin_inset Quotes eld
\end_inset


\series bold
STATUS
\series default

\begin_inset Quotes erd
\end_inset

 is sent by the server socket.
\end_layout

\begin_layout Enumerate
A header string is then returned, giving the status of the client code.
 Recognized options are:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

NEEDINIT
\begin_inset Quotes erd
\end_inset

: If the client code needs any initialising data, it can be sent here.
 The server code will then send a header string 
\begin_inset Quotes eld
\end_inset

INIT
\begin_inset Quotes erd
\end_inset

, followed by an integer giving the number of bits in the initialization
 string, then the initialization string itself.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

READY
\begin_inset Quotes erd
\end_inset

: Sent if the client code is ready to calculate the forces.
 The server socket will then send a string 
\begin_inset Quotes eld
\end_inset

POSDATA
\begin_inset Quotes erd
\end_inset

, then nine floats the cell vector matrix, then another nine floats for
 the inverse matrix, (which need to be transposed if the client code is
 written in fortran).
 The server socket will then send one integer giving the number of atoms,
 then the position data as 3 floats for each atom giving the 3 cartesian
 components of the bead position.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

HAVEDATA
\begin_inset Quotes erd
\end_inset

: This is sent if the client has calculated the potential and forces.
 The server socket then sends a string 
\begin_inset Quotes eld
\end_inset

GETFORCE
\begin_inset Quotes erd
\end_inset

, and the client socket returns 
\begin_inset Quotes eld
\end_inset

FORCEREADY
\begin_inset Quotes erd
\end_inset

.
 The potential is then returned as a float, the number of atoms as an integer,
 then the force data as 3 floats per atom in the same way as the positions,
 and the virial as 9 floats in the same way as the cell vector matrix.
\end_layout

\end_deeper
\begin_layout Enumerate
The server socket waits until the force data for each replica of the system
 has been calculated and returned, upon which the job is finished and the
 molecular dynamics loop starts.
\end_layout

\begin_layout Subsubsection
Parallelization
\end_layout

\begin_layout Standard
As mentioned before, one of the primary advantages of using this type of
 data transfer is that it allows multiple client codes to connect to one
 server code, so that different replicas of the system can be assigned to
 different client codes and their forces computed in parallel.
 In fact it is trivially parallel, in the sense that no communication between
 the client codes is necessary.
\end_layout

\begin_layout Standard
In the case that there are as many client codes as replicas of the system
 this is very simple, as each replica will be assigned its own client code.
 In subsequent steps, the interface will attempt to assign a particular
 replica of the system to the client code which calculated the forces for
 it the last step.
 This reduces the change in the particle positions between calculations
 for a particular client code, so the next step is done more efficiently.
 In the case where there are fewer client codes than beads, the socket interface
 will assign spare jobs to the first client code that finishes running,
 after matching all possible jobs to the same client code that calculated
 it last time step.
\end_layout

\begin_layout Standard
This flexibility is especially useful when the calculations are being run
 on a cluster, as in this case the client codes will connect whenever they
 reach the front of the queue.
 More client codes can connect at any time, and if there is a problem and
 any client code dies it is simply disconnected from the server socket and
 any job it was running reassigned.
\end_layout

\begin_layout Standard
Finally, note that many client codes can be parallelized themselves, using
 MPI or other similar protocols.
 This is fully compatible with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, as it does not matter how the client does the calculation since only the
 forces, potential and virial are sent to the server.
 Information on how to run MPI processes can usually be found on the website
 of the code provider if the client can be parallelized in this way.
\end_layout

\begin_layout Subsection
ssh tunnelling
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{ssh_sockets}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One problem that can often crop up when trying to run a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 calculation is that there is a firewall around the network, especially
 when the server code is being run on a cluster.
 This will often result in error messages such as 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection timed out
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection refused
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Let us suppose that the server code is running on a host network server.net,
 and that you are using port 12345.
 However, when you try to connect to this port from a computer, let us call
 this client.net, then you get error messages like the ones above, due to
 a firewall on server.net blocking port 12345.
\end_layout

\begin_layout Standard
However, assuming that you can create an ssh connection between the two
 computers, then you can use this to forward one of the ports on client.net
 to connect to the necessary port on server.net.
 This can be done with the following shell command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N server.net -L 23451:server.net:12345
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The flags -f and -N just put the ssh process in the background.
 Then comes the ssh server, which in this case is the computer on which
 the server code is running.
 The -L flag sets up the ssh tunnel itself.
 The above code will forward the port 23451 on client.net to the port 12345
 on server.net, as required.
\end_layout

\begin_layout Standard
Once this is done, then any data sent to port on 23451 on client.net will
 be forwarded through the ssh tunnel to port 12345 on server.net.
 By connecting to port 23451 on client.net (or localhost, an alias for the
 host the code is running on) with the client the code should now run.
\end_layout

\begin_layout Standard
If the ssh connection fails, with an error message 
\begin_inset Quotes eld
\end_inset

ssh: connect to host server.net port 22: Connection timed out
\begin_inset Quotes erd
\end_inset

, then the server.net server has also been set up with a firewall around
 the standard ssh port, port 22.
 In this case you can change which port is used to one that is open using
 the -p flag, for example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N server.net -L 23451:server.net:12345 -p 99
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsubsection
Using a script to create a ssh connection
\end_layout

\begin_layout Standard
Now let us suppose that client.net is a cluster, and we wish to submit the
 client jobs to the queue.
 The above code as it is will not work, since ssh requires a password.
 However, you can set up ssh such that no password is needed.
 
\end_layout

\begin_layout Standard
Firstly, on client.net, we need to set up an ssh key.
 This can be done using the command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh-keygen -t rsa
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will then prompt you for a passphrase twice.
 Since we wish to have use this in a job script where we will not be able
 to enter a password, just hit enter twice.
 Note that this will mean that someone with temporary access to your account
 could feasibly take a copy of the ssh key and then be able to use it, so
 this should be used with caution.
\end_layout

\begin_layout Standard
This should now have created two files in the directory ~/.ssh, id_rsa and
 id_rsa.pub.
 These should be readable only by you, so use the following code to set
 up the correct file permissions:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, copy the contents of the file id_rsa.pub and append them to the
 file authorized_keys in the directory ~/.ssh of server.net.
 It should now be possible to ssh from client.net to server.net without using
 a password.
 We can now run the ssh command from a script, and so we can set up a ssh
 tunnel from a cluster node.
 Note that the cluster nodes will have a different IP address to the head
 node, so use 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

client.net
\begin_inset Quotes erd
\end_inset

 in the input file of the client code.
\end_layout

\begin_layout Chapter
Input reference
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{hierarchy}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following chapter gives a complete list of the tags that can be specified
 in the xml input file, along with the hierarchy of objects.
 Note that every xml input file must start with the root tag 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
See the accompanying 
\begin_inset Quotes eld
\end_inset

help.xml
\begin_inset Quotes erd
\end_inset

 file in the 
\begin_inset Quotes eld
\end_inset

doc
\begin_inset Quotes erd
\end_inset

 directory to see the recommended input file structure.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{input_docs/simulation}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/initializer}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_file}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_pos}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_mom}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_vel}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_lab}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_mass}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_cell}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/init_therm}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/ensembles}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/forces}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/socket}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/cell}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/beads}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/atoms}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/normal_modes}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/barostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/thermostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/prng}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/output}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/checkpoint}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/properties}
\end_layout

\begin_layout Plain Layout


\backslash
input{input_docs/trajectory}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Troubleshooting
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{trouble}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Input errors
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{not well-formed (invalid token)}
\end_layout

\end_inset

: Seen if the input file does not have the correct xml syntax.
 Should be accompanied by a line number giving the point in the file where
 the syntax is incorrect.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{mismatched tag}
\end_layout

\end_inset

: One of the closing tags does not have the same name as the corresponding
 opening tag.
 Could be caused either by a misspelling of one of the tags, or by having
 the closing tag in the wrong place.
 This last one is a standard part of the xml syntax, if the opening tag
 of one item is after the opening tag of a second, then its closing tag
 should be before the closing tag of the second.
 Should be accompanied by a line number giving the position of the closing
 tag.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Uninitialized value of type 
\backslash
_
\backslash
_
\backslash
_} or 
\backslash
emph{Attribute/Field name 
\backslash
_
\backslash
_
\backslash
_ is mandatory and was not found in the input for property 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: The xml file is missing a mandatory tag, i.e.
 one without which the simulation cannot be initialized.
 Find which tag name is missing and add it.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Attribute/tag name 
\backslash
_
\backslash
_
\backslash
_ is not a recognized property of 
\backslash
_
\backslash
_
\backslash
_ objects}
\end_layout

\end_inset

: The first tag should not be found within the second set of tags.
 Check that the first tag is spelt correctly, and that it has been put in
 the right place.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ is not a valid option (
\backslash
_
\backslash
_
\backslash
_)}
\end_layout

\end_inset

: This attribute/tag only allows a certain range of inputs.
 Pick one of the items from the list given.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ is an undefined unit for kind 
\backslash
_
\backslash
_
\backslash
_} or 
\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ is not a valid unit prefix} or 
\backslash
emph{Unit 
\backslash
_
\backslash
_
\backslash
_ is not structured with a prefix+base syntax}
\end_layout

\end_inset

: The unit input by the user is not correct.
 Make sure it corresponds to the correct dimensionality, and is spelt correctly.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Invalid literal for int() with base 10: 
\backslash
_
\backslash
_
\backslash
_} or 
\backslash
emph{Invalid literal for float(): 
\backslash
_
\backslash
_
\backslash
_} or 
\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ does not represent a bool value}
\end_layout

\end_inset

: The data input by the user does not have the correct data type.
 See section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ifilestructure}
\end_layout

\end_inset

 for what constitutes a valid integer/float/boolean value.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Error in list syntax: could not locate delimiters}
\end_layout

\end_inset

: The array input data did not have the required braces.
 For a normal array use [], for a dictionary use {}, and for a tuple use
 ().
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{The number of atom records does not match the header of xyz file}
\end_layout

\end_inset

: Self-explanatory.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{list index out of range}
\end_layout

\end_inset

: This will normally occur if the configuration is initialized from an invalid
 input file.
 This will either cause the code to try to read part of the input file that
 does not exist, or to set the number of beads to zero which causes this
 error in a different place.
 Check that the input file has the correct syntax.
\end_layout

\begin_layout Section
Initialization errors
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Negative 
\backslash
_
\backslash
_
\backslash
_ parameter specified.}
\end_layout

\end_inset

: Self-explanatory.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{If you are initializing cell from cell side lengths you must pass the
 'cell' tag an array of 3 floats}
\end_layout

\end_inset

: If you are attempting to initialize a cell using the 
\begin_inset Quotes eld
\end_inset

abc
\begin_inset Quotes erd
\end_inset

 mode, the code expects three floats corresponding to the three side lengths.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{If you are initializing cell from cell side lengths and angles you
 must pass the 'cell' tag an array of 6 floats}
\end_layout

\end_inset

: If you are attempting to initialize a cell using the 
\begin_inset Quotes eld
\end_inset

abcABC
\begin_inset Quotes erd
\end_inset

 mode, the code expects six floats corresponding to the three side lengths,
 followed by the three angles in degrees.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Cell objects must contain a 3x3 matrix describing the cell vectors.}
\end_layout

\end_inset

: If you are attempting to initialize a cell using the 
\begin_inset Quotes eld
\end_inset

manual
\begin_inset Quotes erd
\end_inset

 mode, the code expects nine floats corresponding to the cell vector matrix
 side lengths.
 Note that the values of the lower-diagonal elements will be set to zero.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Array shape mismatch in q/p/m/names in beads input}
\end_layout

\end_inset

: The size of the array in question does not have the correct number of
 elements given the number of atoms and the number of beads used in the
 rest of the input.
 If the number of beads is nbeads and the number of atoms natoms, then q
 and p should have shape (nbeads, 3*natoms) and m and names should have
 shape (natoms,).
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{No thermostat/barostat tag provided for NVT/NPT simulation}
\end_layout

\end_inset

: Some ensembles can only be sampled if a thermostat and/or barostat have
 been defined, and so for simulations at constant temperature and/or pressure
 these tags are mandatory.
 If you wish to not use a thermostat/barostat, but still want to keep the
 ensemble the same, then use 
\begin_inset Quotes eld
\end_inset

dummy
\begin_inset Quotes erd
\end_inset

 mode thermostat/barostat, which simply does nothing.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Pressure/Temperature should be supplied for constant pressure/temperature
 simulation}
\end_layout

\end_inset

: Since in this case the ensemble is defined by these parameters, these
 must be input by the user.
 Add the appropriate tags to the input file.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Manual path mode requires (nbeads-1) frequencies, one for each internal
 mode of the path.}
\end_layout

\end_inset

: If the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 tag of 
\begin_inset Quotes eld
\end_inset

normal_modes
\begin_inset Quotes erd
\end_inset

 is set to 
\begin_inset Quotes eld
\end_inset

manual
\begin_inset Quotes erd
\end_inset

, it will expect an array of frequencies, one for each of the internal normal
 modes of the ring polymers.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{PA-CMD mode requires the target frequency of all the internal modes.}
\end_layout

\end_inset

: If the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 tag of 
\begin_inset Quotes eld
\end_inset

normal_modes
\begin_inset Quotes erd
\end_inset

 is set to 
\begin_inset Quotes eld
\end_inset

pa-cmd
\begin_inset Quotes erd
\end_inset

, it will expect an array of one frequency, to which all the internal modes
 of the ring polymers will be set.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{WMAX-CMD mode requires [wmax, wtarget].
 The normal modes will be scaled such that the first internal mode is at
 frequency wtarget and all the normal modes coincide at frequency wmax.}
\end_layout

\end_inset

: If the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 tag of 
\begin_inset Quotes eld
\end_inset

normal_modes
\begin_inset Quotes erd
\end_inset

 is set to 
\begin_inset Quotes eld
\end_inset

wmax-cmd
\begin_inset Quotes erd
\end_inset

, it will expect an array of two frequencies, one two set the lowest frequency
 normal mode, and one for the other normal mode frequencies.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Number of beads 
\backslash
_
\backslash
_
\backslash
_ doesn't match GLE parameter nb= 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: The matrices used to define the generalized Langevin equations of motion
 do not have the correct first dimension.
 If matrices have been downloaded from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gle4md.berlios.de/ 
\end_layout

\end_inset

 make sure that you have input the correct number of beads.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Initialization tries to match up structures with different atom numbers}
\end_layout

\end_inset

: If in the initialization any of the matrices has an array shape which
 do not correspond to the same number of atoms, then they cannot correspond
 to the same system.
 Check the size of the arrays specified if they have been input manually.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Cannot initialize single atom/bead as atom/bead index 
\backslash
_
\backslash
_
\backslash
_ is larger than the number of atoms/beads}
\end_layout

\end_inset

: Self-explanatory.
 However, note that indices are counted from 0, so the first replica/atom
 is defined by an index 0, the second by an index 1, and so on.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Cannot initialize the momenta/masses/labels/single atoms before the
 size of the system is known.}
\end_layout

\end_inset

: In the code, a beads object is created to hold all the information related
 to the configuration of the system.
 However, until a position vector has been defined, this object is not created.
 Therefore, whichever arrays are being initialized individually, the position
 vector must always be initialized first.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Trying to resample velocities before having masses.}
\end_layout

\end_inset

: A Maxwell-Boltzmann distribution is partly defined by the atom velocity,
 and so the masses must be defined before the velocities can be resampled
 from this distribution.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Cannot thermalize a single bead}
\end_layout

\end_inset

: It does not make sense to initialize the momenta of only one of the beads,
 and so 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 does not give this functionality.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Initializer could not initialize 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: A property of the system that is mandatory to properly run the simulation
 has not been initialized in either the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 section or the appropriate section in beads.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Ensemble does not have a thermostat to initialize} or 
\backslash
emph{There is nothing to initialize in non-GLE thermostats} or 
\backslash
emph{Checkpoint file does not contain usable thermostat data}
\end_layout

\end_inset

: These are raised if the user has tried to initialize the matrices for
 the GLE thermostats with a checkpoint file that either does not have a
 GLE thermostat or does not have a thermostat at all.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Size mismatch in thermostat initialization data}
\end_layout

\end_inset

: Called if the shape of the GLE matrices defined in the checkpoint file
 is different from those defined in the new simulation.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Replay can only read from PDB or XYZ files -- or a single frame from
 a CHK file}
\end_layout

\end_inset

: If the user specifies a replay ensemble, the state of the system must
 be defined by either a configuration file or a checkpoint file, and cannot
 be specified manually.
\end_layout

\begin_layout Section
Output errors
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{The stride length for the 
\backslash
_
\backslash
_
\backslash
_ file output must be positive.}
\end_layout

\end_inset

: Self-explanatory
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ is not a recognized property/output trajectory}
\end_layout

\end_inset

: The string as defined in the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 tag does not correspond to one of the available trajectories.
 Make sure that both the syntax is correct, and that the property has been
 spelt correctly.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Could not open file 
\backslash
_
\backslash
_
\backslash
_ for output}
\end_layout

\end_inset

: Raised if there is a problem opening the file defined by the 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 attribute.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Selected bead index 
\backslash
_
\backslash
_
\backslash
_ does not exist for trajectory 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: You have asked for the trajectory of a bead index greater than the number
 of the replicas of the system.
 Note that indices are counted from 0, so the first replica is defined by
 an index 0, the second by an index 1, and so on.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Incorrect format in unit specification 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: Usually raised if one of the curly braces has been neglected.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Incorrect format in argument list 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: This will be raised either if one of the brackets has been neglected,
 or if the delimiters between arguments, in this case 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

, are not correct.
 This is usually raised if, instead of separating the arguments using 
\begin_inset Quotes eld
\end_inset

;
\begin_inset Quotes erd
\end_inset

, they are instead separated by 
\begin_inset Quotes eld
\end_inset

,
\begin_inset Quotes erd
\end_inset

, since this causes the property array to be parsed incorrectly.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{
\backslash
_
\backslash
_
\backslash
_ got an unexpected keyword argument 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: This will occur if one of the argument lists of one of the properties
 specified by the user has a keyword argument that does not match any of
 those in the function to calculate it.
 Check the properties.py module to see which property this function is calculatin
g, and what the correct keyword arguments are.
 Then check the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag, and find which of the arguments has been misspelt.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Must specify the index of atom
\backslash
_vec property}
\end_layout

\end_inset

: Any property which prints out a vector corresponding to one atom needs
 the index of that atom, as no default is specified.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Cannot output 
\backslash
_
\backslash
_
\backslash
_ as atom/bead index 
\backslash
_
\backslash
_
\backslash
_ is larger than the number of atoms/beads}
\end_layout

\end_inset

: Self-explanatory.
 However, note that indices are counted from 0, so the first replica/atom
 is defined by an index 0, the second by an index 1, and so on.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Couldn't find an atom that matched the argument of 
\backslash
_
\backslash
_
\backslash
_}
\end_layout

\end_inset

: For certain properties, you can specify an atom index or label, so that
 the property is averaged only over the atoms that match it.
 If however no atom labels match the argument given, then the average will
 be undefined.
 Note that for properties which are cumulatively counted rather than averaged,
 this error is not raised, and if no atom matches the label given 0 will
 be returned.
\end_layout

\begin_layout Section
Socket errors
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Address already in use}
\end_layout

\end_inset

: This is called if the server socket is already being used by the host
 network.
 There are several possible reasons for getting this error.
 Firstly, it might simply be that two simulations are running concurrently
 using the same host and port number.
 In this case simply change the port number of one of the simulations.
 Secondly, you can get this error if you try to rerun a simulation that
 previously threw an exception, since it takes a minute or so before the
 host will disconnect the server socket if it is not shut down cleanly.
 In this case, simply wait for it to disconnect, and try again.
 Finally, you will get this error if you try to use a restricted port number
 (i.e.
 below 1024) while not root.
 You should always use a non-restricted port number for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulations.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Error opening unix socket.
 Check if a file /tmp/ipi
\backslash
_
\backslash
_
\backslash
_ exists, and remove it if unused.}
\end_layout

\end_inset

: Similar to the above error, but given if you are using a unix socket rather
 than an internet socket.
 Since this binds locally the socket can be removed by the user, which means
 that it is not necessary to wait for the computer to automatically disconnect
 an unused server socket.
 
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Port number 
\backslash
_
\backslash
_
\backslash
_ out of acceptable range}
\end_layout

\end_inset

: The port number must be between 1 and 65535, and should be greater than
 1024.
 Change the port number accordingly.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{Slot number 
\backslash
_
\backslash
_
\backslash
_ out of acceptable range}
\end_layout

\end_inset

: The slot number must be between 1 and 5.
 Change the slot number accordingly.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{'NoneType' object has no attribute 'Up'}
\end_layout

\end_inset

: This is called if an exception is raised during writing the data to output,
 and so the thread that deals with the socket is terminated uncleanly.
 Check the stack trace for the original exception, since this will be the
 actual source of the problem.
 Also note that, since the socket thread was not cleaned up correctly, the
 server socket may not have been disconnected properly and you may have
 to wait for a minute before you can restart a simulation using the same
 host and port number.
\end_layout

\begin_layout Section
Mathematical errors
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{math domain error}
\end_layout

\end_inset

: If the cell parameters are defined using the side lengths and angles,
 with either a pdb file or using the 
\begin_inset Quotes eld
\end_inset

abcABC
\begin_inset Quotes erd
\end_inset

 initialization mode, then for some value of the angles it is impossible
 to construct a valid cell vector matrix.
 This will cause the code to attempt to take the square root of a negative
 number, which gives this exception.
\end_layout

\begin_layout Itemize
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{overflow encountered in exp}
\end_layout

\end_inset

: Sometimes occurs in NPT runs when the simulation box 
\begin_inset Quotes eld
\end_inset

explodes
\begin_inset Quotes erd
\end_inset

.
 Make sure you have properly equilibrated the system before starting and
 that the timestep is short enough to not introduce very large integration
 errors.
\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "mybib"
options "elsarticle-num-names"

\end_inset


\end_layout

\begin_layout Part
CURRENT MANUAL
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status open

\begin_layout Plain Layout
This manual will be structured as follows: 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{intro}
\end_layout

\end_inset

 we discuss some of the background information for the wrapper and define
 the terms to be used throughout the manual.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{commpro}
\end_layout

\end_inset

 we will discuss how the communication between the driver and wrapper codes
 are implemented.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{install}
\end_layout

\end_inset

 we will discuss how to install the code and test that it is working.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{run}
\end_layout

\end_inset

 we explain the procedure for running simulations, and the form of the input
 and output files.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{overview}
\end_layout

\end_inset

 we explain some of the features of the wrapper code.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{hierarchy}
\end_layout

\end_inset

 a full list of the major classes used in the code is given, along with
 the appropriate tag names and a brief description of all the fields that
 can be specified in the xml input file.
\end_layout

\end_inset


\begin_inset Note Comment
status open

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{dev}
\end_layout

\end_inset

 we discuss what is needed to modify the code.
 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Shell variables
\end_layout

\begin_layout Standard
In all that follows, we will make use of the following definitions of shell
 variables:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{|l|p{10cm}|}
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Name & Definition 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

src
\backslash
_dir & The directory in which the wrapper code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dir & The directory in which the NumPy code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dd
\backslash
_dir & The directory in which the NumPy tar file has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

driver
\backslash
_dir & The directory in which the driver code has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_vers & The version of NumPy installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

py
\backslash
_vers & The version of Python installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_dd
\backslash
_dir & The directory in which the Quantum Espresso code has been downloaded
 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_vers & The version of Quantum Espresso installed 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Driver compatibility
\end_layout

\begin_layout Standard
There are currently patches available for Quantum Espresso version 4.3.2 and
 CP2K version 2.2.
 The patch for Quantum Espresso also works with version 5.0 with minor modificati
ons.
\end_layout

\begin_layout Standard
These codes do not come as part of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 package, and must be downloaded separately.
 See chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{install}
\end_layout

\end_inset

 for more details of how to do this.
 
\end_layout

\begin_layout Section
Online resources
\end_layout

\begin_layout Standard
For more information about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 and to download the source code go to [appropriate ipi website].
\end_layout

\begin_layout Standard
Parameters to run Path Integral with Generalized Langevin Equation thermostat
 (PI+GLE) calculations can be found on the website:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gle4md.berlios.de/ 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Credits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 has been developed by Michele Ceriotti and Joshua More.
 
\end_layout

\begin_layout Section
Citing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Chapter
Communication protocol
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{commpro}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sockets
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is only a wrapper code, it must interface with a driver code in order to
 run any simulations.
 The overarching design principle of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 is that these two codes should be as independent as possible, and so the
 only communication between them is done through a socket.
 A socket is a data transfer device that is designed for internet communication,
 so supports both multiple client connections to the same server and two
 way communication.
 This makes sockets ideal for use in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, where each calculation may require multiple driver codes.
 
\end_layout

\begin_layout Standard
Sockets are described by an IP address and a port number, and can either
 be an internet socket, capable of inter-computer communication, or a unix
 socket, which is optimized for local communication.
 The IP address is input by the user in the 
\begin_inset Quotes eld
\end_inset

address
\begin_inset Quotes erd
\end_inset

 tag, and can be specified in two ways.
 Firstly, every network has a unique numeric code of the form 123.45.678.901.
 Secondly, most networks are named, so the name of the network on which
 the wrapper code is running can be used as an alias for the IP address.
 A specific case of this is 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

, which is the generic name for the local network used by unix sockets.
\end_layout

\begin_layout Standard
The port number is specified in the code by the 
\begin_inset Quotes eld
\end_inset

port
\begin_inset Quotes erd
\end_inset

 tag.
 It is an integer between 1 and 65535 used to distinguish between all the
 different communication processes a particular computer is running.
 As many of the lower numbers are protected for use in important system
 processes or internet communication, it is generally advisable to only
 use numbers in the range 1025-65535 for simulations.
\end_layout

\begin_layout Standard
A unix or internet socket is specified by the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

socket
\begin_inset Quotes erd
\end_inset

 tag.
 While they are faster than internet sockets, unix sockets should only be
 used if a simple empirical potential is being run.
 If complicated empirical potentials or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 potentials are used the force calculation becomes the bottleneck in the
 code, so the advantage of using unix sockets is lost.
 
\end_layout

\begin_layout Standard
Internet sockets have two main advantages that make them much more useful
 in general.
 Firstly, the driver code does not need to be run on the same computer as
 the wrapper code.
 In particular, if the driver codes are being run on a cluster this means
 that you do not need to waste computing resources running the wrapper,
 which is idle most of the time.
 Secondly, the port number is not used for unix sockets, so if more than
 one calculation is being run concurrently internet sockets must be used,
 so that the driver codes connect to the correct wrapper code.
\end_layout

\begin_layout Standard
There are a two other input parameters that may be used to specify how the
 server socket looks for driver codes to connect to.
 
\begin_inset Quotes eld
\end_inset

latency
\begin_inset Quotes erd
\end_inset

 specifies the length of time between each check to see if any new driver
 codes have connected, and 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 specifies how many driver codes can queue between checks.
 Neither is likely to be important in getting the code to run, but may be
 used to optimize the connection time if required.
\end_layout

\begin_layout Section
Data transfer
\end_layout

\begin_layout Standard
Once at least one driver code has connected to the server socket, the force
 calculation can start.
 For this to happen the driver code needs the system configuration, and
 likewise the wrapper needs the force and potential data to be returned
 so that it can continue propagating the dynamics.
\end_layout

\begin_layout Standard
To make sure that the connection is good, a simple query-response data transfer
 protocol is used.
 Before any data is sent through the socket a header string of 12 characters
 is sent to verify which stage of the calculation the wrapper is at.
 Once the driver sends the appropriate response header string, the data
 is transferred.
 If no response is given, the wrapper will either wait and try again, or
 disconnect the driver code and reassign its job to another, depending on
 the severity of the problem.
 The wrapper assumes that 4-bit integers, 8-bit floats and 1-bit characters
 are used.
 A typical step is of the form:
\end_layout

\begin_layout Enumerate
A header string of 
\begin_inset Quotes eld
\end_inset


\series bold
STATUS
\series default

\begin_inset Quotes erd
\end_inset

 is sent by the server socket.
\end_layout

\begin_layout Enumerate
A header string is then returned, giving the status of the driver code.
 Recognized options are:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

NEEDINIT
\begin_inset Quotes erd
\end_inset

: If the driver code needs any initialising data, it can be sent here.
 The server code will then send a header string 
\begin_inset Quotes eld
\end_inset

INIT
\begin_inset Quotes erd
\end_inset

, followed by an integer giving the number of bits in the initialization
 string, then the initialization string itself.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

READY
\begin_inset Quotes erd
\end_inset

: Sent if the driver code is ready to calculate the forces.
 The server socket will then send a string 
\begin_inset Quotes eld
\end_inset

POSDATA
\begin_inset Quotes erd
\end_inset

, then nine floats the cell vector matrix, then another nine floats for
 the inverse matrix, (which need to be transposed if the driver code is
 written in fortran).
 The server socket will then send one integer giving the number of atoms,
 then the position data as 3 floats for each atom giving the 3 cartesian
 components of the bead position.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

HAVEDATA
\begin_inset Quotes erd
\end_inset

: This is sent if the driver has calculated the potential and forces.
 The server socket then sends a string 
\begin_inset Quotes eld
\end_inset

GETFORCE
\begin_inset Quotes erd
\end_inset

, and the client socket returns 
\begin_inset Quotes eld
\end_inset

FORCEREADY
\begin_inset Quotes erd
\end_inset

.
 The potential is then returned as a float, the number of atoms as an integer,
 then the force data as 3 floats per atom in the same way as the positions,
 and the virial as 9 floats in the same way as the cell vector matrix.
\end_layout

\end_deeper
\begin_layout Enumerate
The server socket waits until the force data for each replica of the system
 has been calculated and returned, upon which the job is finished and the
 molecular dynamics loop starts.
\end_layout

\begin_layout Section
Parallelization
\end_layout

\begin_layout Standard
As mentioned before, one of the primary advantages of using this type of
 data transfer is that it allows multiple driver codes to connect to one
 wrapper code, so that different replicas of the system can be assigned
 to different driver codes and their forces computed in parallel.
 In fact it is trivially parallel, in the sense that no communication between
 the driver codes is necessary.
\end_layout

\begin_layout Standard
In the case that there are as many driver codes as replicas of the system
 this is very simple, as each replica will be assigned its own driver code.
 In subsequent steps, the interface will attempt to assign a particular
 replica of the system to the driver code which calculated the forces for
 it the last step.
 This reduces the change in the particle positions between calculations
 for a particular driver code, so the next step is done more efficiently.
 In the case where there are fewer driver codes than beads, the socket interface
 will assign spare jobs to the first driver code that finishes running,
 after matching all possible jobs to the same driver code that calculated
 it last time step.
\end_layout

\begin_layout Standard
This flexibility is especially useful when the calculations are being run
 on a cluster, as in this case the driver codes will connect whenever they
 reach the front of the queue.
 More driver codes can connect at any time, and if there is a problem and
 any driver code dies it is simply disconnected from the server socket and
 any job it was running reassigned.
\end_layout

\begin_layout Standard
Finally, note that many driver codes can be parallelized themselves, using
 MPI or other similar protocols.
 This is fully compatible with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, as it does not matter how the driver does the calculation since only the
 forces, potential and virial are sent to the wrapper.
 Information on how to run MPI processes can usually be found on the website
 of the code provider if the driver can be parallelized in this way.
\end_layout

\begin_layout Section
ssh tunnelling
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{ssh_sockets}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One problem that can often crop up when trying to run a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 calculation is that there is a firewall around the network, especially
 when the wrapper code is being run on a cluster.
 This will often result in error messages such as 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection timed out
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection refused
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Let us suppose that the wrapper code is running on a host network wrapper.net,
 and that you are using port 12345.
 However, when you try to connect to this port from a computer, let us call
 this driver.net, then you get error messages like the ones above, due to
 a firewall on wrapper.net blocking port 12345.
\end_layout

\begin_layout Standard
However, assuming that you can create an ssh connection between the two
 computers, then you can use this to forward one of the ports on driver.net
 to connect to the necessary port on wrapper.net.
 This can be done with the following shell command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N wrapper.net -L 23451:wrapper.net:12345
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The flags -f and -N just put the ssh process in the background.
 Then comes the ssh server, which in this case is the computer on which
 the wrapper code is running.
 The -L flag sets up the ssh tunnel itself.
 The above code will forward the port 23451 on driver.net to the port 12345
 on wrapper.net, as required.
\end_layout

\begin_layout Standard
Once this is done, then any data sent to port on 23451 on driver.net will
 be forwarded through the ssh tunnel to port 12345 on wrapper.net.
 By connecting to port 23451 on driver.net (or localhost, an alias for the
 host the code is running on) with the driver the code should now run.
\end_layout

\begin_layout Standard
If the ssh connection fails, with an error message 
\begin_inset Quotes eld
\end_inset

ssh: connect to host wrapper.net port 22: Connection timed out
\begin_inset Quotes erd
\end_inset

, then the wrapper.net server has also been set up with a firewall around
 the standard ssh port, port 22.
 In this case you can change which port is used to one that is open using
 the -p flag, for example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N wrapper.net -L 23451:wrapper.net:12345 -p 99
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using a script to create a ssh connection
\end_layout

\begin_layout Standard
Now let us suppose that driver.net is a cluster, and we wish to submit the
 driver jobs to the queue.
 The above code as it is will not work, since ssh requires a password.
 However, you can set up ssh such that no password is needed.
 
\end_layout

\begin_layout Standard
Firstly, on driver.net, we need to set up an ssh key.
 This can be done using the command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh-keygen -t rsa
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will then prompt you for a passphrase twice.
 Since we wish to have use this in a job script where we will not be able
 to enter a password, just hit enter twice.
 Note that this will mean that someone with temporary access to your account
 could feasibly take a copy of the ssh key and then be able to use it, so
 this should be used with caution.
\end_layout

\begin_layout Standard
This should now have created two files in the directory ~/.ssh, id_rsa and
 id_rsa.pub.
 These should be readable only by you, so use the following code to set
 up the correct file permissions:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, copy the contents of the file id_rsa.pub and append them to the
 file authorized_keys in the directory ~/.ssh of wrapper.net.
 It should now be possible to ssh from driver.net to wrapper.net without using
 a password.
 We can now run the ssh command from a script, and so we can set up a ssh
 tunnel from a cluster node.
 Note that the cluster nodes will have a different IP address to the head
 node, so use 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

driver.net
\begin_inset Quotes erd
\end_inset

 in the input file of the driver code.
\end_layout

\begin_layout Chapter
Installing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{install}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
Background and nomenclature
\end_layout

\begin_layout Subsection
Molecular dynamics
\end_layout

\begin_layout Plain Layout
Molecular dynamics is a way of sampling the possible states of a system
 by propagating the positions and momenta of the particles in the system
 in discrete time steps according to a set of physical rules.
\end_layout

\begin_layout Plain Layout
By choosing the algorithm used to propagate the momenta correctly, the probabili
ty of the system being in a particular state will be the same as that of
 a physically realistic system, such as a system in contact with an external
 heat bath.
\end_layout

\begin_layout Plain Layout
We will call the complete set of possible states of the system an ensemble
 of states.
 The relevant ensembles we will be interested in are: 
\end_layout

\begin_layout Description
NVE ensemble This gives constant particle number, volume and energy, and
 corresponds to an isolated physical system.
 
\end_layout

\begin_layout Description
NVT ensemble This gives constant particle number, volume and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath.
 
\end_layout

\begin_layout Description
NPT ensemble This gives constant particle number, pressure and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath and in equilibrium with a pressure bath.
 
\end_layout

\begin_layout Plain Layout
We will call the total number of possible states of a system for any given
 set of external variables the partition function of that system.
\end_layout

\begin_layout Plain Layout
In any practical simulation, the number of atoms has to be far fewer than
 the typical number present in the physical system of interest, for reasons
 of computational difficulty.
 This means that a high proportion of the particles in the simulation are
 likely to be on the edge of the simulation box.
 To prevent this having a large effect on the properties of the system,
 all of the driver codes implement what is known as periodic boundary conditions.
 This***********************************************88 
\end_layout

\begin_layout Subsection
Path integral generalization
\end_layout

\begin_layout Plain Layout
In the path integral generalization of classical mechanics, we use the following
 isomorphism between the quantum partition function of a system and a classical
 partition function in a higher phase space: 
\begin_inset Formula 
\begin{equation}
Q=\Tr(e^{-\hat{H}\beta})
\end{equation}

\end_inset

 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\left(\frac{2\pi m}{h^{2}\betan}\right)^{\frac{3}{2}}e^{-\hat{U}_{N}\betan}\dd\textbf{r}_{i}\right]\\
 & \hat{U}_{N}=\sum_{i=1}^{N}\left[\frac{m}{2\betan^{2}\hbar^{2}}(\textbf{r}_{i}-\textbf{r}_{i-1})^{2}+\hat{V}_{i}\right]\\
 & \betan=\frac{\beta}{N}\nonumber 
\end{align}

\end_inset

 Where 
\begin_inset Formula \ensuremath{\hat{H}}

\end_inset

 is the quantum Hamiltonian of the system, which is the operator corresponding
 to the observable energy, 
\begin_inset Formula \ensuremath{\hat{V}_{i}}

\end_inset

 is the potential of the replica of the system corresponding to the label
 
\begin_inset Formula \ensuremath{i}

\end_inset

, and 
\begin_inset Formula \ensuremath{\hat{U}_{N}}

\end_inset

 is a classical configurational Hamiltonian in the extended phase space,
 which only depends on particle coordinates.
\end_layout

\begin_layout Plain Layout
In practice we do not need to go to the limit of infinite 
\begin_inset Formula \ensuremath{N}

\end_inset

, as convergence can often be achieved with a small increase of phase space.
 Note that this classical Hamiltonian is equivalent to that of a 
\begin_inset Formula \ensuremath{N}

\end_inset

 replicas of the original system, with a harmonic potential between adjacent
 replicas.
 We will call this set of replicas of each atom a ring polymer, and the
 component particles of this ring polymer beads.
\end_layout

\begin_layout Plain Layout
The last thing we must do to make the connection with molecular dynamics
 is to add fictitious ring polymer momenta to allow us to sample the phase
 space more effectively.
 In our code we make the choice corresponding to assigning each bead the
 mass of the corresponding atom: 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\left(\frac{1}{2\pi\hbar}\right)^{3}e^{-\hat{H}_{N}\betan}\dd\textbf{r}_{i}\dd\textbf{p}_{i}\right]\\
 & \hat{H}_{N}=\hat{U}_{N}+\sum_{i=1}^{N}\frac{\textbf{p}_{i}^{2}}{2m}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout
This is then the partition function corresponding to the NVE ensemble for
 the quantum system, and as it has a purely classical Hamiltonian the algorithms
 used in classical dynamics and the generalizations used to sample other
 ensembles can be applied to this system in exactly the same way as for
 a classical system.
 
\end_layout

\begin_layout Subsection
Ab initio potentials
\end_layout

\begin_layout Plain Layout
An ab initio potential is one that does not require any experimentally derived
 parameters in its calculation.
 Under the strictest sense of the term many of the most popular DFT algorithms
 are not ab initio as they do use experimentally determined parameters,
 but as prior simulations are not necessary for the formulation of a DFT
 potential, we will define DFT as such for the purposes of this manual.
\end_layout

\begin_layout Plain Layout
DFT calculations are done by minimising an energy with respect to the one
 electron probability density, rather than the wavefunction as is common
 in most other ab initio potentials.
 The energy is given in terms of that of a fictitious system without electron
 interaction, for which the energy can be found exactly, plus an energy
 term due to electron correlation.
 This is the quantity of fundamental importance in DFT calculations, and
 while no analytic form for it exists several useful approximations to it
 have been created.
 We will call these correlation functionals.
\end_layout

\begin_layout Plain Layout
DFT calculations are done via an iterative procedure where a guess for the
 one electron wavefunctions are made so that the energy can be calculated,
 and a new set of one electron wavefunctions are then calculated by minimising
 this energy.
 The new wavefunctions are then put back into the first step and the procedure
 repeated until the initial and final density matrices are consistent.
\end_layout

\begin_layout Plain Layout
In what is known as Car-Parrinello molecular dynamics, the converged wavefunctio
ns of one step are then used as the starting point for the next step, drasticall
y accelerating the convergence.
\end_layout

\begin_layout Plain Layout
Another important consideration is the basis set used for the 
\end_layout

\end_inset


\end_layout

\begin_layout Section
System requirements
\end_layout

\begin_layout Standard
To install and run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

, you will need to have:
\end_layout

\begin_layout Itemize
A modern C compiler (for the sockets.c module)
\end_layout

\begin_layout Itemize
Python version 2.4 or greater
\end_layout

\begin_layout Itemize
The Python numerical library NumPy
\end_layout

\begin_layout Standard
Note that 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 does not need to be compiled, it will run automatically as a script if
 the appropriate libraries have been installed.
\end_layout

\begin_layout Standard
Additionally, most driver codes will have their own requirements.
 Many of them, including the test driver codes given in the 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 directory, will need a modern Fortran compiler.
 Most will also need to be linked with some mathematical libraries, such
 as BLAS, FFTW and LAPACK.
 Installation instructions should be provided as part of the code distribution
 and on the appropriate website.
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 download
\end_layout

\begin_layout Standard
A tar file can be downloaded from the website [appropriate wrap-pi website].
 To install this you need to input the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> tar xf [wrapper_tar_file.tar]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also download the git repository at [github repository name] using
 the commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> git clone [github repository name]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
NumPy download
\end_layout

\begin_layout Standard
NumPy is the standard Python mathematics library, and is used for most of
 the array minipulation and linear algebra in the wrapper code.
 How difficult it is to install NumPy depends on whether you have root access
 or not, and on the version of Python you are using.
\end_layout

\begin_layout Standard
In any case you must first obtain the NumPy code.
 The NumPy library can be downloaded as a tar file from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://sourceforge.net/projects/numpy/files/NumPy/
\end_layout

\end_inset

 This must then be extracted using the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $np_dd_dir
\end_layout

\begin_layout Plain Layout

> tar czf $np_vers.tar.gz
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before installing this code it first needs to be configured correctly.
 Note that this requires the distutils package that comes with the python-dev
 package.
 Assuming that the required software is installed, the NumPy package is
 built using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py build
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to install the package.
 By default the download is to the directory /usr/local.
 If you have root access, and so can write to /usr, then all that needs
 to be done to finish the install is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you do not have root access, then the next step depends on which version
 of Python is beind used.
 With versions 2.6 or later there is a simple command to automatically download
 into the directory $HOME/local:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --user
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With Python 2.4/2.5 the process is a little more involved.
 First you must explicitly install the package in the directory of choice
 with the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --prefix=$np_dir
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, you must tell python where to find this library, by appending to the
 linux environment variable 
\series bold
PYTHONPATH
\series default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> export PYTHONPATH=$PYTHONPATH:$np_dir/lib64/$py_vers/site-packages
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may have to replace lib64 with lib depending on whether you are installing
 to a 64-bit or 32-bit architecture.
\end_layout

\begin_layout Section
PyFFTW
\end_layout

\begin_layout Standard
Currently, the normal mode transformation is, at least by default, computed
 using a fast-Fourier transform (FFT) library within the NumPy distribution.
 This however is not the only distribution that could be used, and indeed
 faster stand-alone versions exist.
 The gold-standard FFT library is the FFTW library, which is a set of C
 libraries that have been heavily optimized for a wide range of applications.
 There have been a number of Python wrappers around the FFTW library, of
 which currently one has been interfaced with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

.
 This code can be found at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

https://github.com/hgomersall/pyFFTW
\end_layout

\end_inset

, and has documentation at 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://hgomersall.github.io/pyFFTW/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This code has the following dependencies:
\end_layout

\begin_layout Itemize
Python version 2.7 or greater
\end_layout

\begin_layout Itemize
Numpy version 1.6 or greater
\end_layout

\begin_layout Itemize
FFTW version 3.2 or greater
\end_layout

\begin_layout Standard
This can be installed in the same way as NumPy, except using the code distributi
on above, or using various installation packages as per the instructions
 on the above documentation.
 Note that no other options need to be specified in the input file, the
 wrapper will check to see if this library can be installed, and if it can
 it will be used by default.
 Otherwise the slower NumPy version will be used.
\end_layout

\begin_layout Section
Driver installation and compilation
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Standard
You can download the source code for Quantum Espresso at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espresso.org/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For Quantum Espresso version 4.3.2, there is a patch file to allow it to be
 used as a driver code with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 in the directory $src_dir/patches/pwscf.
 This can be applied to the Quantum Espresso source code using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $esp_dd_dir
\end_layout

\begin_layout Plain Layout

> tar zxvf $esp_vers.tar.gz
\end_layout

\begin_layout Plain Layout

> cd $esp_vers
\end_layout

\begin_layout Plain Layout

> patch -p1 < $src_dir/patches/pwscf/pw-driver.patch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, continue the download as per the instructions at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espress.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
CP2K 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%I still don't even have this code, so can't write this bit...
\end_layout

\end_inset


\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{tests}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several test cases are distributed with the code to ensure that your distributio
n is working correctly.
 There are also simple tests to see if the driver codes are working correctly.
\end_layout

\begin_layout Standard
All the input files are contained in the directory test, which is subdivided
 into the following directories:
\end_layout

\begin_layout Description
lj: This gives a simple classical Lennard-Jones simulation of Ne.
 The state points are given by (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.35, 1.62), (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.75, 1.069) and (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.88, 1.095) in reduced Lennard-Jones units, so that the results
 can be compared to those in the paper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{lverlet67pr}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
ph2: This simulates para-hydrogen using the isotropic Silvera-Goldman pair
 potential.
 There are three directories, 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 have tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mill-mano05jcp}
\end_layout

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

 has tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mart+99jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
pwscf: This has two simple examples to test to see if the Quantum-Espresso
 driver is functioning correctly.
 There is one simple 4-atom lithium test, and a test using a single water
 molecule.
\end_layout

\begin_layout Description
harmonic: This has a simple example of a 1D harmonic oscillator.
 This demonstrates the displaced path integral momentum distribution operator
 as given in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{linlin+10prl}
\end_layout

\end_inset

.
 As the momentum distribution is known analytically for this simple system,
 this provides an indication of how well the method is working.
\end_layout

\begin_layout Chapter
Running 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{run}
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run the wrapper
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulations are run using the top level script found in the src directory.
 If the xml-formatted input file is called input_file.xml, then the command
 to run a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python $src_dir/i-pi input_file.xml
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code will then have to wait until at least one driver code has connected
 before running any dynamics.
 At this point the code is essentially idle, and the only process that it
 runs is to periodically poll the socket for connections.
\end_layout

\begin_layout Section
How to run the driver
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Standard
To run CP2K with the wrapper, an additional file named 
\begin_inset Quotes eld
\end_inset

serverfile
\begin_inset Quotes erd
\end_inset

 must be kept in the same directory that CP2K is being run from.
 It should contain a string a single line long, of the format 
\begin_inset Quotes eld
\end_inset

mode:host:port_number
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 should either be 
\begin_inset Quotes eld
\end_inset

INET
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

UNIX
\begin_inset Quotes erd
\end_inset

, representing an internet or unix socket respectively.
 The rest of the input file is the same as for a standard CP2K calculation.
\end_layout

\begin_layout Subsection
Quantum-Espresso
\end_layout

\begin_layout Standard
Suppose we want to run Quantum-Espresso as the driver code, and we have
 compiled it as given above, and have an input file which will give the
 correct forces and potential for the system of interest.
 If we want to connect to a socket on the host address host_address and
 on the port number port, then we would add the following lines to the input
 file:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we wanted to run on a UNIX port instead of an INET port, we would instead
 write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`UNIX:host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of the input file should be the same as for a standard Quantum
 Espresso calculation.
\end_layout

\begin_layout Section
Running simulations
\end_layout

\begin_layout Subsection
Running a simulation
\end_layout

\begin_layout Standard
There are two parts to any 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation.
 First the wrapper is run, which starts the dynamics loop until the forces
 are required.
 Once the server socket has been opened, it then waits for connections from
 driver codes.
 
\end_layout

\begin_layout Standard
For a small simulation, with a simple classical potential, it may be preferable
 to run both halves of the simulation on the same computer, especially as
 this allows us to use the faster unix domain sockets.
 This can be done using a single script, such as:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#These are the parameters that need to be specified by
\end_layout

\begin_layout Plain Layout

#the user.
 The number of driver codes is given by $ndrivers,
\end_layout

\begin_layout Plain Layout

#the i-pi source directory is given by $src_dir, and the code
\end_layout

\begin_layout Plain Layout

#that runs one of the driver codes is given by $driver_comm
\end_layout

\begin_layout Plain Layout

inputfile=...
\end_layout

\begin_layout Plain Layout

hostname=...
\end_layout

\begin_layout Plain Layout

port=...
\end_layout

\begin_layout Plain Layout

ndrivers=...
\end_layout

\begin_layout Plain Layout

src_dir=...
\end_layout

\begin_layout Plain Layout

driver_comm="..."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#This modifies the input file.
 If necessary, the driver code
\end_layout

\begin_layout Plain Layout

#input file should be modified here too
\end_layout

\begin_layout Plain Layout

sed -i "s/<address>[^<]*</<address>$hostname</" $inputfile
\end_layout

\begin_layout Plain Layout

sed -i "s/<port>[^<]*</<port>$port</" $inputfile
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

if [ -e EXIT ]; then
\end_layout

\begin_layout Plain Layout

   rm EXIT 
\end_layout

\begin_layout Plain Layout

fi
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Runs the simulation, and redirects the wrapper
\end_layout

\begin_layout Plain Layout

#standard output to a file named 'log'.
\end_layout

\begin_layout Plain Layout

bash -c "python $src_dir/i-pi $inputfile > log &"
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

sleep 20 #must wait for server to be initialized
\end_layout

\begin_layout Plain Layout

for a in `seq 1 $ndrivers`; do
\end_layout

\begin_layout Plain Layout

   bash -c "$driver_comm"
\end_layout

\begin_layout Plain Layout

done 
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, for most simulations, especially those running with expensive 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 forces and potentials, we will want to run the driver codes on a computational
 cluster.
 Here we run the wrapper code elsewhere, and use internet sockets for the
 communication.
 For information on how to do this, see section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ssh_sockets}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To run the driver on a cluster computer, two major changes must be implemented.
 Firstly, the code required to run the driver code should be separated from
 that of the wrapper code.
 Secondly, the driver script should be executed using a queueing program
 such as qsub rather than the bash shell script as above, and so will need
 to have the appropriate directive comment lines.
 Depending on which cluster is used, additional commands to set parameters
 such as the walltime, number of nodes and number of cores can be used.
 Check the qsub man page for the cluster you are running the code on for
 more details.
\end_layout

\begin_layout Standard
One possible driver script layout would be:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

#!/bin/bash
\end_layout

\begin_layout Plain Layout

#$ -S /bin/bash
\end_layout

\begin_layout Plain Layout

#$ -N jobname
\end_layout

\begin_layout Plain Layout

#$ ...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#use this if there are library files needed
\end_layout

\begin_layout Plain Layout

#by the driver code that are not on the default path
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#export LD_LIBRARY_PATH=...
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#use this if ssh tunnelling is required
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#wrapper_host=...
 #the wrapper host address
\end_layout

\begin_layout Plain Layout

#wrapper_port=...
 #the wrapper port number
\end_layout

\begin_layout Plain Layout

#driver_port=...
 #the cluster port number
\end_layout

\begin_layout Plain Layout

#ssh -f -N $wrapper_host -L $driver_port:$wrapper_host:$wrapper_port
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

inputfile=...
\end_layout

\begin_layout Plain Layout

hostname=...
\end_layout

\begin_layout Plain Layout

port=...
\end_layout

\begin_layout Plain Layout

driver_comm="..."
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

#Modify driver input file if necessary
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

bash -c "driver_comm"
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Note that it may be necessary to export libraries or modules if they are
 not present by default, or to use an ssh tunnel if the cluster is not open
 to the internet (see 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ssh_sockets}
\end_layout

\end_inset

).
\end_layout

\begin_layout Subsection
Running multiple simulations
\end_layout

\begin_layout Standard
To set up multiple concurrent 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulations each host socket has to be distinguishable, so that the driver
 codes appropriate to each simulation connect only to the correct wrapper
 code.
 This can be done with internet sockets by adjusting the port number for
 each simulation, which then acts as a unique identifier for each server.
 The shell scripts from before can be easily modified to do this, for example
 if we assume the simulations will be run in directories called sim_1, sim_2,
 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

, then we can write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

first_port=...
 #The value of the port of sim_1
\end_layout

\begin_layout Plain Layout

i=0
\end_layout

\begin_layout Plain Layout

for a in sim_*; do 
\end_layout

\begin_layout Plain Layout

   cd $a
\end_layout

\begin_layout Plain Layout

   port=$((first_port+i))
\end_layout

\begin_layout Plain Layout

   ((i++))
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   #here we run the code for one simulation as before
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

   cd ..
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Input files
\end_layout

\begin_layout Subsection
xml file
\end_layout

\begin_layout Standard
This is the main input file from which the simulation parameters are initialized.
 An xml file consists of a set of hierarchially nested tags.
 There are three parts to an xml tag.
 Each tag is identified by a tag name, which specifies the class or variable
 that is being initialized.
 Between the opening and closing tags there may be some data, which may
 or may not contain other tags.
 This will specify the contents of a class, or the value of a variable.
 Finally, any tag can have attributes, which in the code are used for variables
 which specify the state or type of class that will be created.
 A xml tag has the following syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag_name attribute_name=`attribute_data'>tag_data</tag_name>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for the different types of tag data is given below:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>True</tag> or <tag>False</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>11.111</tag> or <tag>1.1111e+1</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>12345</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>{name1: data1, name2: data2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 }</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>string_data</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag> (int1, int2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 )</tag>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Also, for arrays, which have the `shape' attribute, we have the syntax
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag shape=`array_shape'>[entry1, entry2, ...
 ]</tag>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where each entry has the same data type, which will be either float, int,
 boolean or string, and `array_shape' is a tuple that gives the shape of
 the generated array.
 If the shape is not specified, then a 1D array will be assumed.
\end_layout

\begin_layout Standard
The code uses this hierarchial structure to help read the data; if a particular
 object is held within a parent object in the code, then the tag for that
 object will be within the appropriate parent tags.
 This is used to make the structure of the simulation clear.
 For example the system that is being studied is partly defined by the thermodyn
amic ensemble that should be sampled, which in turn may be partly defined
 by the temperature, and so on.
 In the input file this would be specified by having a 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 tag, containing an 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag, which itself contains a 
\begin_inset Quotes eld
\end_inset

temperature
\begin_inset Quotes erd
\end_inset

 tag, which will contain a float value corresponding to the temperature.
 In the code itself this will correspond to a simulation object, which will
 contain an ensemble object, which will contain a temperature variable.
 In this manner, the simulation class structure can be constructed iteratively.
\end_layout

\begin_layout Standard
To help detect any user error the acceptable tag names, type of data and
 possible default values are all specified in the code, in a specialized
 input class for each class of object.
 A full list of all the available tags and a brief description of their
 function is given in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{hierarchy}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Configuration file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{configfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initial configuration data can be initialized both through the xml file,
 and through a separate configuration file.
 The configuration file is specified within the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag name in the xml file, with the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute as the file format.
 The currently accepted file formats are:
\end_layout

\begin_layout Itemize
pdb
\end_layout

\begin_layout Itemize
xyz
\end_layout

\begin_layout Standard
These files can be used to specify the initial atom positions, labels and
 masses (based on atomic symbol) and, depending on the format, the cell
 parameters as well.
 It can either be held within a 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 tag, in which case all applicable information will be initialized, or 
\begin_inset Quotes eld
\end_inset

positions
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

masses
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

labels
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

cell
\begin_inset Quotes erd
\end_inset

, in which case only the specified property will be initialized.
\end_layout

\begin_layout Subsection
Units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{units}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 uses the following set of internal units:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S.I.
 Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bohr radius
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2917721e-11 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4188843e-17 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Electron mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.1093819e-31 kg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kelvin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Energy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hartree
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3597438e-18 J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pressure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.9421912e13 Pa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
However, these units can be overriden in the input file by using the 
\begin_inset Quotes eld
\end_inset

units
\begin_inset Quotes erd
\end_inset

 attribute.
 For example, if you wanted to specify the cell parameters in units of angstrom
 rather than bohr radii then in the input file you would specify:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<cell units=`angstrom'> ...
 </cell>
\backslash
end{verbatim}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Output files
\end_layout

\begin_layout Standard
All output files are specified within the tag name 
\begin_inset Quotes eld
\end_inset

output
\begin_inset Quotes erd
\end_inset

 in the xml file.
 Each tag held here specifies a particular output file, with data specifying
 the file name, the data to be output and the number of steps between each
 write, plus other relevant data.
\end_layout

\begin_layout Subsection
Property file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{propertyfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the output file for for all the system and simulation level properties,
 such as the total energy and the overall time taken.
 The properties that are output are determined by the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag in the xml input file.
 The format of this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<properties stride=`' filename=`' flush=`' shape=`'>
\end_layout

\begin_layout Plain Layout

   [ prop1name{units}(arg1; ...
 ), prop2name{...}(...), ...
  ]
\end_layout

\begin_layout Plain Layout

</properties>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The attributes have the following meanings:
\end_layout

\begin_layout Description
stride The number of steps between each output to file
\end_layout

\begin_layout Description
filename The name of the output file
\end_layout

\begin_layout Description
flush The number of steps between flushing the buffer
\end_layout

\begin_layout Standard
This tag data is an array of strings, each of which containing three different
 parts:
\end_layout

\begin_layout Itemize
First, the property name, which describes which type of property is to be
 output.
 This is a mandatory part of the string.
\end_layout

\begin_layout Itemize
Secondly, you can specify the units that the property will be output in.
 This is specified between curly brackets, as shown above.
 If this is not specified, then the property will be output in atomic units.
\end_layout

\begin_layout Itemize
Thirdly, the arguments to be passed to the function can be specified between
 standard brackets, with each argument separated by a semi-colon.
 These may or may not be mandatory depending on the property.
 The arguments can be specified by either of two different syntaxes, (name1=arg1
; 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ) or (arg1; 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 ).
 The first explicitly assigns the argument with the name 
\begin_inset Quotes eld
\end_inset

name1
\begin_inset Quotes erd
\end_inset

 the value 
\begin_inset Quotes eld
\end_inset

arg1
\begin_inset Quotes erd
\end_inset

, whereas the second relies on the arguments being specified in the correct
 order.
 The two syntaxes may be mixed, but positional arguments must be specified
 first otherwise undefined behaviour will result.
 If no arguments are specified, then the defaults as defined in the properties.py
 module will be used.
\end_layout

\begin_layout Standard
The different available property names are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{input_docs/property_list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The format of the file is given by a comment line per property giving the
 name of the properties and which columns of the input file will be used
 to print it, followed by their values in the appropriate units at regular
 intervals given by the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 The file is fixed formatted, with two blank characters at the start of
 each row, then the data in the same order as the header row.
 Each column is 16 characters wide and every float is written in exponential
 format with 8 digits after the decimal point.
\end_layout

\begin_layout Subsection
Trajectory files
\end_layout

\begin_layout Standard
These are the output file for atomic or bead level properties, such as the
 bead positions.
 Each trajectory that should be output is specified by the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 tag in the input file.
 These tags have the format:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<trajectory stride=`' filename=`' format=`' cell_units=`'
 flush=`' bead=`'>
\end_layout

\begin_layout Plain Layout

   traj_name{units}(arg1;...)
\end_layout

\begin_layout Plain Layout

</trajectory>
\backslash
end{verbatim}
\end_layout

\end_inset

This is very similar to the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag, but it has the additional tags 
\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cell_units
\begin_inset Quotes erd
\end_inset

, and only one trajectory can be specified.
 `format' specifies the format of the output file, and `cell_units' specifies
 the units in which the cell dimensions are output.
 Depending on the chosen trajectory to output, it will either print a file
 per bead or per atom.
 If the trajectory is output per bead then the output files will be 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 with the bead index appended, so as to distinguish between the trajectories
 of each bead.
 In this case it is also possible to only output one trajectory by specifying
 the 
\begin_inset Quotes eld
\end_inset

bead
\begin_inset Quotes erd
\end_inset

 attribute.
 The possible choices of output properties are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{input_docs/trajectory_list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The allowable file formats for the trajectory output files are the same
 as for the configuration input files, given in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{configfile}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Restart mechanism
\end_layout

\begin_layout Subsection
Checkpoint files
\end_layout

\begin_layout Standard
As well as the above output files, the state of the system at a particular
 time step can also be saved to file.
 These checkpoint files can be used as valid input files, with all the informati
on required to restore the state of the system to the point at which the
 file was created.
 The syntax for this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'>
\end_layout

\begin_layout Plain Layout

   step
\end_layout

\begin_layout Plain Layout

</checkpoint>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, this is similar to the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tags, but instead of having a value which specifies what to output, the
 value simply gives a number to identify which checkpoint is which.
 There is also one additional attribute 
\begin_inset Quotes eld
\end_inset

overwrite
\begin_inset Quotes erd
\end_inset

, which specifies whether each new checkpoint file overwrites the old one,
 or whether all checkpoint files are kept.
 If they are kept, they will be written not to the file 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

, but instead an index will be appended to it to distinguish between different
 files.
\end_layout

\begin_layout Standard
If the `step' parameter is not specified, the following syntax can also
 be used:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'/>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restart file
\end_layout

\begin_layout Standard
As well as checkpoint files during a simulation run, ipi also creates
 a file to restart from automatically at the end of the simulation, with
 file name 
\begin_inset Quotes eld
\end_inset

RESTART
\begin_inset Quotes erd
\end_inset

.
 In the same way as the checkpoint files generated above, it contains the
 state of the system is created by the wrapper, but it doesn't need to be
 asked for by the user in the input file.
 Its purpose is that if the user decides that insufficient steps where used
 in an already completed simulation, then this file can be used to continue
 from where it ended.
\end_layout

\begin_layout Subsection
Soft exit
\end_layout

\begin_layout Standard
To stop the program in such a way that it makes sure to save the data generated
 in a restart file, simply create a file 
\begin_inset Quotes eld
\end_inset

EXIT
\begin_inset Quotes erd
\end_inset

 in the directory in which the code is running.
 The thread handler will automatically detect this and safely shut down
 the program, outputting the restart file as detailed above.
 
\end_layout

\begin_layout Standard
An important point to note is that since each time step is split into several
 parts, it is only at the beginning of each step that all the variables
 are consistent with each other in such a way that the simulation can be
 restarted from them without changing the dynamics.
 Thus if a soft exit call is made during a step, then the restart file that
 is created must correspond to the state of the system at the start of the
 step.
 To this end, the state of the system is saved at the start of every step.
\end_layout

\begin_layout Subsection
Initialization from RESTART
\end_layout

\begin_layout Standard
As well as being a valid input file, the RESTART file can be used as a starting
 point for simulations in two other ways.
 Firstly, in the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag, there is a 
\begin_inset Quotes eld
\end_inset

chk
\begin_inset Quotes erd
\end_inset

 option for the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of all the initializable properties.
 This will use the restart file as a basis for initializing the specified
 bits of data.
\end_layout

\begin_layout Standard
Secondly, there is a particular ensemble type, 
\begin_inset Quotes eld
\end_inset

replay_file
\begin_inset Quotes erd
\end_inset

, which takes a configuration file with multiple frames or a checkpoint
 file with one frame and reruns it without doing dynamics, by simply setting
 the configuration to match that given by the input file at each frame.
 
\end_layout

\begin_layout Chapter
Feature overview
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{overview}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ring polymer contraction
\end_layout

\begin_layout Standard
Often, we will want to take a description of the system in terms of a certain
 number of beads and instead represent it with a different number of beads.
 In the wrapper this is done using a ring polymer contraction scheme
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{mark-mano08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This works by matching the normal mode amplitudes of the old ring polymer
 with those of the new ring polymer.
 The normal modes are matched in ascending frequency order, until either
 all the ring polymer normal modes of the new ring polymer have been assigned
 a frequency, or all the original ring polymer normal modes have been used.
 Any remaining normal mode amplitudes are set to zero.
\end_layout

\begin_layout Standard
This is used in two different cases:
\end_layout

\begin_layout Itemize
Initializing a simulation from a previous one with a different number of
 beads.
\end_layout

\begin_layout Itemize
Calculating long range interactions with a reduced number of beads.
\end_layout

\begin_layout Standard
The first of these points is fairly self-explanatory.
 To specify the number of beads that the system should be initialized to,
 the 
\begin_inset Quotes eld
\end_inset

nbeads
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag simply needs to be set to the appropriate value in the input file.
 This will take whatever configuration is specified in the initilialization
 and use the above transformation to give a new configuration with the correct
 number of beads.
 
\end_layout

\begin_layout Standard
The second of these uses is more complicated.
 To understand this, consider an empirical potential model that can be split
 into a short-ranged potential and a long-ranged potential, where the long-range
d part of the potential is slowly varying in space.
 This means that the long-ranged part of the potential will require fewer
 beads to converge the calculated potential energy than the short-ranged
 part, as it only varies slightly over the ring polymer length scale.
 
\end_layout

\begin_layout Standard
Also, let us suppose that the calculation of the long-range terms is the
 computational bottleneck, as they are more numerous than the short-range
 terms.
 In this case calculating the long-range part of the potential on a contracted
 ring polymer will have a large effect on the simulation time, even if the
 short-range part is calculated on the full ring polymer.
 Therefore this technique allows us to speed up the simulation without sacrifici
ng accuracy.
\end_layout

\begin_layout Standard
Once the force, potential and virial have been calculated using the reduced
 ring polymer, the resulting force and virial vectors are transformed back
 to the appropriate size for the full ring polymer phase space, before being
 used to propagate the trajectory.
\end_layout

\begin_layout Standard
For a given 
\begin_inset Quotes eld
\end_inset

socket
\begin_inset Quotes erd
\end_inset

 tag, this can be specified in the input file by setting the 
\begin_inset Quotes eld
\end_inset

nbeads
\begin_inset Quotes erd
\end_inset

 attribute.
 This value will dictate how many beads will be used to calculate that part
 of the force, and if it is not equal to the number of beads in the system
 then ring polymer contraction will be used.
\end_layout

\begin_layout Section
Constant temperature simulations
\end_layout

\begin_layout Standard
There are a variety of different stochastic thermostats implemented within
 the wrapper.
 All the algorithms that are used in the wrapper are based on either the
 Langevin equation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{plangevin1908cras}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

%perhaps a more relevant citation required here as well?
\end_layout

\end_inset

 or stochastic velocity rescaling
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{buss-parr08cpc}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The Langevin thermostat is a local thermostat, so couples to each degree
 of freedom, whereas the stochastic velocity rescaling is a global algorithm,
 so is only coupled to the total kinetic energy.
 Global thermostats are less disruptive to the dynamics, so are much better
 for calculation of properties that require reorganisation of the structure,
 such as dielectric constants
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+10jcp}
\end_layout

\end_inset

.
 However, they tend be less efficient for local properties such as the total
 energy.
\end_layout

\begin_layout Standard
The path integral Langevin equation (PILE) thermostat
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+10jcp}
\end_layout

\end_inset

 adapts these algorithms for PIMD simulations, and may be either local or
 global.
 It uses 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{a priori}
\end_layout

\end_inset

 estimates for the friction coefficients of the thermostats coupled to the
 internal ring polymer normal modes, so this is much more effective for
 path integral calculations than standard stochastic thermostats.
\end_layout

\begin_layout Standard
Constant temperature simulations can be run by setting the 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag to 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

, and the 
\begin_inset Quotes eld
\end_inset

thermostat
\begin_inset Quotes erd
\end_inset

 tag specifies how the thermostat is defined.
\end_layout

\begin_layout Subsection
Generalized Langevin equation thermostats
\end_layout

\begin_layout Standard
The Langevin equation can be generalized to include non-Markovian effects,
 so that the stochastic step of the algorithm requires information from
 previous timesteps.
 This is however very difficult to implement in practice.
\end_layout

\begin_layout Standard
However, this can be shown to be mathematically equivalent to a Markovian
 algorithm in an extended momentum phase space
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+09jctc}
\end_layout

\end_inset

.
 This is much simpler to implement, but still maintains the increased power
 and flexibility of the non-Markovian formulation.
 In particular, this has two main advantages over standard Langevin equation
 dynamics.
\end_layout

\begin_layout Standard
Firstly, there are a large number of adjustable parameters, so the thermostat
 can be fine-tuned to efficiently sample all the vibrational frequencies
 present in the system rather than just a small range of frequencies.
\end_layout

\begin_layout Standard
Secondly, the algorithm does not need to obey the fluctuation-dissipation
 theorem, so the ensemble that is sampled can be adjusted manually.
 For example, using information from the harmonic limit this thermostat
 can attempt to enforce the appropriate quantum ensemble during a low bead
 PIMD simulation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+11jcp}
\end_layout

\end_inset

, increasing the rate of convergence with respect to the number of beads
 used.
\end_layout

\begin_layout Section
Constant pressure simulations
\end_layout

\begin_layout Standard
Constant pressure simulations are also possible within the wrapper.
 There is one barostat currently implemented
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{buss+09jpc}
\end_layout

\end_inset

, which is designed to be used in combination with stochastic thermostating,
 so is only suitable for simulations where both the pressure and temperature
 are held constant.
 Note that these algorithms allow the system box size to fluctuate, which
 can cause problems for some driver codes if variable cell dynamics have
 not been implemented.
\end_layout

\begin_layout Standard
Constant pressure simulations can be run by setting the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag to 
\begin_inset Quotes eld
\end_inset

npt
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

barostat
\begin_inset Quotes erd
\end_inset

 tag specifies how the barostat is defined.
\end_layout

\begin_layout Section
Dynamical property calculations
\end_layout

\begin_layout Standard
As well as calculating the static properties shown in section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{propertyfile}
\end_layout

\end_inset

, the wrapper code is capable of calculating approximations to dynamical
 properties such as correlation functions.
 Currently, two different techniques have been implemented for this, ring
 polymer molecular dynamics (RPMD)
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{crai-mano04jcp}
\end_layout

\end_inset

 and partially adiabatic centroid molecular dynamics (PA-CMD)
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{habe+08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
RPMD uses the trajectories generated during a PIMD run to calculate correlation
 functions, so is straightforward to use.
 The largest difference between RPMD and PIMD is that local thermostats
 usually disrupt the particle motion too much to be used in the calculation
 of dynamical properties, so often a constant energy ensemble must be sampled
 instead.
 An example of one way to run an RPMD simulation is given in one of the
 test directories, as explained in section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{tests}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
PA-CMD uses different dynamics to calculate correlation functions.
 In particular, the ring polymer bead masses are scaled, shifting the ring
 polymer normal mode frequencies.
 This is particularly useful where non-zero frequency components of the
 correlation functions are important, as the ring polymer normal mode frequencie
s can contaminate the spectrum.
 PA-CMD avoids this by shifting these frequencies out of the frequency range
 of interest.
\end_layout

\begin_layout Standard
PA-CMD dynamics can be used by adjusting the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

normal_modes
\begin_inset Quotes erd
\end_inset

 tag.
 
\begin_inset Quotes eld
\end_inset

normal modes
\begin_inset Quotes erd
\end_inset

 takes an array argument, which can be used to specify how the ring polymer
 normal mode frequencies are defined.
\end_layout

\begin_layout Section
Output properties
\end_layout

\begin_layout Standard
While most of the properties that can be output during a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ipi
\end_layout

\end_inset

 simulation are self-explanatory, there are some for which the algorithms
 used or the properties calculated are non-trivial and so deserve some comment.
\end_layout

\begin_layout Subsection
Displaced path momentum distribution estimators
\end_layout

\begin_layout Standard
Momentum distributions are very difficult quantities to calculate, because
 they require knowledge of the off-diagonal elements of the density matrix.
 In a path-integral context, this means that the distribution of open paths,
 where two of the neighbouring beads in the ring polymer are not connected
 by springs, must be sampled.
 However, since the ensemble is defined by the distribution of closed paths,
 only one path can be opened in this way at a time without introducing sampling
 errors.
 
\end_layout

\begin_layout Standard
Multiple techniques have been proposed to try and alleviate the problems
 of poor statistical sampling that this causes, but in the wrapper only
 the displaced path estimator of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{linlin+10prl}
\end_layout

\end_inset

 has been implemented.
 This uses a closed path integral simulation to generate the dynamics, and
 only opens the paths when the estimator is to be calculated, so no sampling
 errors are introduced by calculating this property for multiple atoms during
 a particular timestep.
\end_layout

\begin_layout Standard
This therefore gives better statistical sampling, as the property can be
 calculated for all identical atoms in a particular timestep without introducing
 errors.
 Also, since the vector that opens the path can be chosen by the user, this
 allows the phase space to be searched systematically.
 The main disadvantages of this method are first that every time the property
 is calculated a new force calculation must be done, and secondly that convergen
ce is very poor for highly quantum systems.
 The latter problem can be circumvented by a thermodynamic integration scheme,
 although this reintroduces the sampling error problem that the open path
 simulations have.
 See 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{linlin+10prl}
\end_layout

\end_inset

 for a more in depth discussion of the method.
\end_layout

\begin_layout Subsection
Finite difference energy and heat capacity estimators
\end_layout

\begin_layout Standard
As the momenta associated with the beads in a PIMD simulation do not correspond
 to physical variables, they cannot be used to help calculate statistical
 averages.
 Momentum dependent properties are therefore usually calculated using identities
 derived from thermodynamics.
 For example, the kinetic energy is calculated by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{align} 
\backslash
langle 
\backslash
hat{T} 
\backslash
rangle = 
\backslash
langle 
\backslash
hat{H} 
\backslash
rangle - 
\backslash
langle 
\backslash
hat{V} 
\backslash
rangle = - 
\backslash
frac{
\backslash
partial 
\backslash
, 
\backslash
textrm{ln}(Z)}{
\backslash
partial 
\backslash
beta} - 
\backslash
langle 
\backslash
hat{V} 
\backslash
rangle 
\backslash
end{align} 
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This can then be used to derive an estimator for the kinetic energy using
 the ring polymer Hamiltonian to calculate 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(Z
\backslash
)
\end_layout

\end_inset

.
 There are two possible ways of representing the result.
 If the result of the above calculation is used directly, then an estimator
 that only depends on the positions of the beads is derived, but it involves
 the difference of two large terms that scale with the number of beads and
 so has a variance that increases linearly with the number of beads used.
 The second result uses the virial theorem to derive another estimator with
 the same average value, but with better statistics.
 This method however involves the derivative of the potential with respect
 to the bead positions.
\end_layout

\begin_layout Standard
For the kinetic energy, we use the virial form, since we already must have
 the first derivative of the potential (i.e.
 the forces).
 However, for other quantities such as the heat capacity, the virial estimator
 involves second or higher derivatives, and so is much more costly to evaluate.
\end_layout

\begin_layout Standard
Instead of having to compromise between statistical sampling and computational
 expense, we take the approach of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{tyamamoto05jcp}
\end_layout

\end_inset

 and calculate the temperature derivative by finite differences.
 While this means that each step will require two extra force calculations
 it has the same statistical properties as the virial estimator without
 requiring potential derivatives to be calculated, so is often the most
 efficient method to calculate such properties.
\end_layout

\begin_layout Subsection
Extras list
\end_layout

\begin_layout Standard
In many cases, the driver code calculation will derive important quantities
 other than the potential, forces and virial, which may be necessary to
 calculate properties of interest such as the charge distribution.
 It is therefore useful to have a mechanism by which such data can be passed
 back to the wrapper code, so that it does not have to be recalculated as
 a post-processing step.
 This is done in the code using an 
\begin_inset Quotes eld
\end_inset

extras
\begin_inset Quotes erd
\end_inset

 string.
 This is passed at the end of the driver message, and read directly into
 a string by the wrapper.
 This can then be printed directly to file using the 
\begin_inset Quotes eld
\end_inset

extras
\begin_inset Quotes erd
\end_inset

 trajectory output.
\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Chapter
Developer's tips
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{dev}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Directory structure
\end_layout

\begin_layout Plain Layout
The code is separated into the following directory structure: 
\end_layout

\begin_layout Description
forces: Contains a few short fortran driver files for running simple tests.
 
\end_layout

\begin_layout Description
doc: Contains the documentation, including this manual.
 
\end_layout

\begin_layout Description
src: Contains the source code for the wrapper.
 This is further subdivided into: 
\end_layout

\begin_deeper
\begin_layout Description
engine: Holds the modules containing the internally used objects and algorithms
 
\end_layout

\begin_layout Description
driver: Holds the modules containing the objects that deal with the driver
 communication and data transfer.
 
\end_layout

\begin_layout Description
utils: Holds the modules containing the utility functions used in the other
 modules.
 
\end_layout

\begin_layout Description
inputs: Holds the modules containing the classes that read the input files.
\end_layout

\end_deeper
\begin_layout Description
patches: Contains the patch files that must be applied to allow the driver
 codes to interact with the wrapper.
 
\end_layout

\begin_layout Description
test: Contains examples that can be used to make sure the build has been
 successful, show the correct form of the input files, and show some of
 the capabilities of the wrapper.
 
\end_layout

\begin_layout Section
Dependency detection and automatic property caching
\end_layout

\begin_layout Subsection
Rationale
\end_layout

\begin_layout Plain Layout
One of the utility classes that is defined in the code, from which most
 of the classes in the code inherit, is the dobject class.
 Similarly, many of the variables contained in these classes are depend
 objects.
\end_layout

\begin_layout Plain Layout
The depend object class has been designed so that every time it is accessed
 it checks all of the other depend objects on which it is dependent to see
 if they have changed, and if so recalculates its value.
 The dobject class overrides the mechanism by which you can access the members
 of an instance of it, so that they are accessed via the dependency detection
 functions.
\end_layout

\begin_layout Plain Layout
These classes have been defined so that, instead of cluttering up the code
 with functions to recalculate the various parameters of the simulation,
 we simply have to define the function by which to recalculate them and
 the other objects which they depend upon when they are created, and then
 they will automatically be updated when required.
\end_layout

\begin_layout Plain Layout
As an example, take the total kinetic energy for one replica of the system.
 This is a property of the total momentum vector and the mass vector of
 the different atoms.
 Therefore, we would create a 
\begin_inset Quotes eld
\end_inset

kin
\begin_inset Quotes erd
\end_inset

 object in the atoms class that has dependencies 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

momentum
\begin_inset Quotes erd
\end_inset

, and a recalculation function that calculated 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
frac{
\backslash
bf{p}^2}{2
\backslash
bf{m}}
\backslash
)
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Having done this, any time we access atoms.kin, the code will check to see
 if either the mass vector or momentum vector has changed.
 If it has will recalculate the kinetic energy before returning it, otherwise
 it will simply return the cached value.
\end_layout

\begin_layout Subsection
Synchronized objects
\end_layout

\begin_layout Plain Layout
As well as checking for dependencies, the same infrastructure can also be
 used to synchronize two objects which are different representations of
 the same data.
 A good example of this is the bead coordinates in the cartesian and normal
 mode representations.
 Both of these represent the same data, but have different numerical values.
\end_layout

\begin_layout Plain Layout
In this case we can use a synchronize object, which holds a dictionary of
 functions to transform one representation to another.
 In the case of the normal mode and cartesian representations of position,
 the transformation can be done either by multiplying the position vector
 by a transformation matrix, or via a Fourier transform.
\end_layout

\begin_layout Plain Layout
Using this class, whenever we make a change to one of the representations,
 the others are automatically recalculated by reapplying the transformation
 function the next time they are accessed.
\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Plain Layout
While many of the simple properties of interest can be output directly to
 the properties output file, and many others can be obtained by post-processing
 the available data, it may be that some property you wish to calculate
 is not explicitly available for output.
\end_layout

\begin_layout Plain Layout
In this case, you may wish to modify the code so that this property can
 be output.
 All the code to do this is found in the 
\begin_inset Quotes eld
\end_inset

properties.py
\begin_inset Quotes erd
\end_inset

 module in the 
\begin_inset Quotes eld
\end_inset

engine
\begin_inset Quotes erd
\end_inset

 directory.
 To add a new property to the existing list, you must first define a function
 that calculates this property.
\end_layout

\begin_layout Plain Layout
In standard Python notation, we must define a new function inside the 
\begin_inset Quotes eld
\end_inset

Properties
\begin_inset Quotes erd
\end_inset

 class.
 This is written by:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def new_func(self):
\end_layout

\begin_layout Plain Layout

   ...code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We can now use this function to calculate the property of interest.
 If the name of this property is 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

, we can add this to the dictionary of named properties by:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict["new_prop"] = new_func
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
We now simply need to add the name 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 list in the xml input file, and the property will be written to the properties
 output file when appropriate.
\end_layout

\begin_layout Plain Layout
If you need a function with arguments, then the code we need is given by:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict["new_arg_prop"] = new_arg_func
\end_layout

\begin_layout Plain Layout

...code here...
\end_layout

\begin_layout Plain Layout

def new_arg_func(self, arg1, arg2, ...
 ):
\end_layout

\begin_layout Plain Layout

   ...more code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Now in the property list you must put:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<properties>
\end_layout

\begin_layout Plain Layout

   [ new_arg_prop(arg1; arg2; ...
 ), ...
 ]
\end_layout

\begin_layout Plain Layout

</properties>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The code will now automatically call the function with the arguments defined
 in the properties list.
\end_layout

\begin_layout Section
Creating a new class
\end_layout

\begin_layout Plain Layout
While creating a new property may be possible by using existing objects,
 it may be that you wish to calculate something in a way that is not implemented
 by the code.
 In this case, it may be necessary to create a new class to do the calculation.
 To do this efficiently, you must be understand some of the more advanced
 features of the code.
\end_layout

\begin_layout Subsection
Depend objects
\end_layout

\begin_layout Plain Layout
Many of the new objects created inside a class may depend on other objects
 in the code for their value.
 As discussed in Chapter 3, the calculation of such variables is facilitated
 by the use of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 classes defined in the 
\begin_inset Quotes eld
\end_inset

utils
\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Plain Layout
Since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overwrites the standard way of getting and setting functions, so
 there is a special syntax for creating them.
 To create a depend object 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 with name 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 inside an object 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

, you need to use the syntax: 
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

dset(object, name, value)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
The arguments that are important for creating 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects are:
\end_layout

\begin_layout Description
name: A string giving the name of the depend object.
\end_layout

\begin_layout Description
value: 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 only.
 Defines the memory the object references.
\end_layout

\begin_layout Description
synchro: An optional 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This keeps track of different views on the same data.
\end_layout

\begin_layout Description
func: An optional function to recalculate the object when one of its dependencie
s are updated.
\end_layout

\begin_layout Description
dependencies: An optional list of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects which are required to recalculate the new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object.
 Essentially a list of all the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects that appear in 
\series bold
func
\series default
.
\end_layout

\begin_layout Plain Layout
There are two different classes of 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, 
\begin_inset Quotes eld
\end_inset

depend_value
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class is a specialist class for NumPy arrays, to deal with the slicing
 mechanism.
 This means that for the 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class there is a second method of creating new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, you can take a slice of an old one.
 
\end_layout

\begin_layout Plain Layout
This will return a slice with the same dependencies and synchro objects,
 and a reference to the correct slice of the base array of the parent 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object, so that the automatic updating keeps all the data consistent.
 Note that it is therefore incorrect to create a new 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object that is a slice of an old one using the 
\series bold
dset
\series default
 function, as it will not copy the dependencies correctly.
\end_layout

\begin_layout Plain Layout
There is also a method for dealing with separate objects that are different
 views on the same data; the 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This object is shared with all of the different views to the same data,
 and deals with keeping all of them consistent with each other.
\end_layout

\begin_layout Plain Layout
Also, the 
\series bold
func
\series default
 initialization argument must be a dictionary of functions that transform
 from the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object being created to the other synchronized objects, using the syntax:
\end_layout

\begin_layout Plain Layout
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

func = {synchro1: func1, synchro2: func2, ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Plain Layout
Where 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 of the Nth synchro object, and 
\begin_inset Quotes eld
\end_inset

funcN
\begin_inset Quotes erd
\end_inset

 transforms from the 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 object to the one being created.
 Note that we have to make sure that we do not mix the two forms of 
\series bold
func
\series default
, synchonized objects can only depend on the other synchronized objects,
 and not on any other depend objects.
\end_layout

\begin_layout Plain Layout
Finally, there are several utility functions that help to manipulate 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects:
\end_layout

\begin_layout Description
dget: Gets a specified 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overrides the standard Python method of getting attributes, so you
 need a way to get the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object and not just its value.
\end_layout

\begin_layout Description
dset: Creates a 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed for the same reason as 
\series bold
dget
\series default
.
\end_layout

\begin_layout Description
depstrip: Takes a 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object and returns the base array.
 Useful in algorithms where the array is used as a read-only variable, as
 it removes the dependancy network from the object, and so speeds up the
 calculation.
\end_layout

\begin_layout Description
depcopy: Copies the 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 objects from one 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object to another.
\end_layout

\begin_layout Description
deppipe: Gives one 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object the same value as another, and adds a dependency such that this
 remains the case.
\end_layout

\begin_layout Subsection
Input class
\end_layout

\begin_layout Plain Layout
To be able to use the xml input file to create an instance of this new class,
 and to write the file to the restart file, you must create a new input
 class, or modify an old one to recognize the new class.
\end_layout

\begin_layout Plain Layout
Each input class must have the following class attributes:
\end_layout

\begin_layout Description
fields: This is a dictionary giving the tag names for the objects that can
 be specified in the xml input file within the tags of your class.
 Every object that can be given a value by the user should be a keyword
 of this dictionary, or of the 
\series bold
attributes 
\series default
dictionary.
 Within the dictionary, you must specify the particular class of input object
 that will be created and arguments to initialize it.
 The format of the dictionary is: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

{tag_name1 :
\end_layout

\begin_layout Plain Layout

   (InputClass, 
\end_layout

\begin_layout Plain Layout

      {default: default value,
\end_layout

\begin_layout Plain Layout

       help: help string, 
\end_layout

\begin_layout Plain Layout

       dtype: data type,
\end_layout

\begin_layout Plain Layout

       options: [option1, option2, ...
 ],
\end_layout

\begin_layout Plain Layout

       dimension: dimensionality of the data}), 
\end_layout

\begin_layout Plain Layout

tag_name2: ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Description
attribs: This is a dictionary of the same form as 
\series bold
fields
\series default
, but for the tag attribute data instead.
 These should always be simple data classes InputValue or InputArray, as
 their value must be specified by the user.
\end_layout

\begin_layout Description
default_help: This is the help string that will be given to help explain
 the new class to others if no other help string is given.
 It will also be the help string seen in the section in the latex file for
 the new class.
\end_layout

\begin_layout Description
default_label: This is the label used to identify the appropriate section
 in the latex help file so that different sections can cross-reference with
 the others.
\end_layout

\begin_layout Plain Layout
The class can have the following functions:
\end_layout

\begin_layout Description
fetch: This takes the InputClass object and creates a new object of your
 class from it.
 You must make sure to call the base class fetch function using the standard
 Python function super.
\end_layout

\begin_layout Description
store: This takes an object of your class, and stores the relevant information
 needed to reinitialize it in an InputClass object.
 You must make sure to call the base class store function using the standard
 Python function super.
\end_layout

\begin_layout Description
check: This is an optional function that will check to see if the data specified
 in the input file will create a valid instance of your class, and possibly
 raise an exception otherwise.
 You must make sure to call the base class check function using the standard
 Python function super.
\end_layout

\begin_layout Description
write: This is a function that you can use to override the base class write
 function, so that you can tailor what is printed to the restart file.
\end_layout

\begin_layout Plain Layout
The last thing that you must do to be able to use your class is to create
 an appropriate fields tag in the parent input class where you want the
 instance of your class to be held, with InputClass set to the name of your
 input class, and alter the check, store and fetch functions of the input
 class of the parent class.
\end_layout

\begin_layout Section
Submitting improvements
\end_layout

\begin_layout Plain Layout
This code is still in developement, and any submissions to improve the code
 are welcome.
 However, to be considered as a candidate for inclusion in the main version
 of the code additions must adhere to the standards described in this section.
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Plain Layout
Any new code should be tested for bugs before being submitted.
 At the very least the modified code should reproduce the properties in
 the test directory, and be shown to give the expected new results.
 Preferably, new results found with wrap-PI should also be compared with
 other published results, and a suitable test case added to the test directory.
\end_layout

\begin_layout Plain Layout
It should also be tested for user input error, especially if a new input
 class has been created, so that such errors can be detected before the
 simulation is run.
 For example, if a parameter cannot be negative then this should be tested
 in the code, so that a sensible error message is given if the user inputs
 a negative value.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Plain Layout
We have taken great care to make sure that all the code is well documented,
 and as such any submissions should be documented to the same standard.
 We have used the Google Python Style Guide, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://google-styleguide.googlecode.com/svn/trunk/pyguide.html
\end_layout

\end_inset

, as a template for the documentation.
\end_layout

\begin_layout Plain Layout
For each module we require the following documentation:
\end_layout

\begin_layout Itemize
Each new module must be added to the __init__.py and README files of the
 directory in which it is found.
\end_layout

\begin_layout Itemize
At the head of each new module, you must give a string with a summary and
 a brief description of the module with all the classes and functions that
 it defines, and an __all__ object giving the same classes and functions
 as above.
\end_layout

\begin_layout Itemize
Each class must have a docstring giving a summary, a brief description of
 its purpose and the variables it contains, including a separate section
 for any depend objects defined, and what their dependencies are.
 Input classes must also have a help string defined for all its tags, and
 an appropriate default tag.
\end_layout

\begin_layout Itemize
Each function must have a docstring giving a summary, a brief description
 of its purpose, any arguments it uses, any exceptions it can raise and
 what is returned by the function, if not None.
 
\end_layout

\begin_layout Itemize
Any new class must have its input class added to the create_man.py and help.py
 files in the doc directory, so that the automatic manual creation will
 work correctly.
\end_layout

\begin_layout Plain Layout
If new modules are being submitted, then all of the above documentation
 should be done.
 If only a new class or function is being added, then only parts of the
 above will be necessary.
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Input class hierarchy
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%
\backslash
label{hierarchy}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following chapter gives a complete list of the tags that can be specified
 in the xml input file, along with the hierarchy of objects.
 Note that every xml input file must start with the root tag 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
See the accompanying 
\begin_inset Quotes eld
\end_inset

help.xml
\begin_inset Quotes erd
\end_inset

 file in the 
\begin_inset Quotes eld
\end_inset

doc
\begin_inset Quotes erd
\end_inset

 directory to see the recommended input file structure.
\end_layout

\end_body
\end_document
