#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\@ifundefined{definecolor} {\usepackage{color}}{}
\usepackage{multicol}\makeindex
\usepackage{xspace}
\end_preamble
\options fleqn
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
dd}{
\backslash
; 
\backslash
mathrm{d}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Tr}{
\backslash
mathrm{Tr}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
bra}{< 
\backslash
! 
\backslash
!} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ket}{
\backslash
! 
\backslash
! >} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
betan}{
\backslash
beta_N} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
logn}{
\backslash
mathrm{ln}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
expon}{
\backslash
mathrm{exp}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Imag}{
\backslash
mathrm{Im}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
wrappi}{{
\backslash
sc wrap-PI}
\backslash
xspace}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 5.5cm*
\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
A Python wrapper for Path Integral Molecular Dynamics
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{intro}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is a path integral molecular dynamics (PIMD) wrapper written in Python
 for ab initio density functional theory (DFT) codes.
 It currently works with the DFT codes QUANTUM ESPRESSO and CP2K, as well
 as the classical codes LAMMPS and DLPOLY.
\end_layout

\begin_layout Standard
It is designed to separate the calculation of the potential energy, forces
 and virial of a system from the algorithmic steps that propagate the dynamics.
 This allows the time intesive force calculation to be done by heavily optimised
 external codes while the dynamics and properties of interest can be calculated
 in the most transparent manner possible.
\end_layout

\begin_layout Standard
This manual will contain the following information: 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{intro}
\end_layout

\end_inset

 we discuss some of the background information for the wrapper and define
 the terms to be used throughout the manual.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{progpar}
\end_layout

\end_inset

 we will discuss some of the design principles of the wrapper, and some
 of the inner workings of the code.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{install}
\end_layout

\end_inset

 we will discuss how to install the code, and test that it is working.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{run}
\end_layout

\end_inset

 we explain the procedure for running simulations with the appropriate features,
 and the form of the input and output files.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{algorithms}
\end_layout

\end_inset

 the theory behind the algorithms used in the wrapper are discussed.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{dev}
\end_layout

\end_inset

 we discuss what is needed to modify the code.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{hierarchy}
\end_layout

\end_inset

 a full list of the major classes used in the code is given, along with
 the appropriate tag names and a brief description of all the fields that
 can be specified in the xml input file.
\end_layout

\begin_layout Section
Shell variables
\end_layout

\begin_layout Standard
In all that follows, we will make use of the following definitions:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{|l|p{10cm}|}
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Name & Definition 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

src
\backslash
_dir & The directory in which the wrapper code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dir & The directory in which the NumPy code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dd
\backslash
_dir & The directory in which the NumPy tar file has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

driver
\backslash
_dir & The directory in which the driver code has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_vers & The version of NumPy installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

py
\backslash
_vers & The version of Python installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_dd
\backslash
_dir & The directory in which the Quantum Espresso code has been downloaded
 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_vers & The version of Quantum Espresso installed 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Driver compatibility
\end_layout

\begin_layout Standard
There are currently patches available for Quantum Espresso version 4.3.2 and
 CP2K version 2.2.
 Both patches have been added to the current developement branches of these
 codes, and should be included as standard in newer versions.
\end_layout

\begin_layout Standard
These codes do not come as part of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 package, and must be downloaded separately.
 See chapter 3 for more details of how to do this.
 
\end_layout

\begin_layout Section
Online resources
\end_layout

\begin_layout Standard
For more information about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 and to download the source code go to [appropriate wrappi website].
\end_layout

\begin_layout Standard
Parameters to run Path Integral with Generalized Langevin Equation Thermostat
 (PIGLET) calculations can be found on the website:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gle4md.berlios.de/ 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Credits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 has been developed by Michele Ceriotti and Joshua More.
\end_layout

\begin_layout Section
Citing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Chapter
Programming paradigm
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{progpar}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Structure of the code
\end_layout

\begin_layout Subsection
Directory structure
\end_layout

\begin_layout Standard
The code is separated into the following directory structure: 
\end_layout

\begin_layout Description
forces: Contains a few stand-alone fortran driver modules for running simple
 tests.
 
\end_layout

\begin_layout Description
doc: Contains the documentation, including this manual.
 
\end_layout

\begin_layout Description
src: Contains the source code for the wrapper.
 This is further subdivided into: 
\end_layout

\begin_deeper
\begin_layout Description
engine: Holds the modules containing the internally used objects and algorithms
 
\end_layout

\begin_layout Description
forces: Holds the modules containing the objects that deal with the driver
 communication and data transfer.
 
\end_layout

\begin_layout Description
utils: Holds the modules containing the utility functions used in the other
 modules.
 
\end_layout

\begin_layout Description
inputs: Holds the modules containing the classes that read the input files.
\end_layout

\end_deeper
\begin_layout Description
patches: Contains the patch notes needed to allow the driver codes to interact
 with the wrapper.
 
\end_layout

\begin_layout Description
test: Contains examples that can be used to make sure the build has been
 successful, show the correct form of the input files, and show some of
 the capabilities of the wrapper.
 
\end_layout

\begin_layout Subsection
Code structure
\end_layout

\begin_layout Standard
To run a simulation, the following steps are followed by the code:
\end_layout

\begin_layout Enumerate
The input file is read, parsed and interpreted.
\end_layout

\begin_layout Enumerate
The appropriate python objects are created and initialized.
\end_layout

\begin_layout Enumerate
A socket is opened, and the wrapper waits for a driver code to connect.
\end_layout

\begin_layout Enumerate
Once at least one driver code has connected, the simulation is run forward
 in discrete time steps.
\end_layout

\begin_layout Standard
Each time step splits up into the following stages:
\end_layout

\begin_layout Enumerate
The momenta of the particles are adjusted by an external thermostat, if
 applicable.
\end_layout

\begin_layout Enumerate
The momenta of the particles are adjusted according to the forces acting
 on them
\end_layout

\begin_layout Enumerate
The centroid coordinates of the ring polymers are adjusted according to
 their momenta (and in constant pressure simulations the cell momenta).
\end_layout

\begin_layout Enumerate
The internal modes of the ring polymer are adjusted according to their momenta.
\end_layout

\begin_layout Enumerate
The forces are recalculated by the driver code.
\end_layout

\begin_layout Enumerate
See step 2.
\end_layout

\begin_layout Enumerate
See step 1.
\end_layout

\begin_layout Section
Dependency detection and automatic property caching
\end_layout

\begin_layout Subsection
Rationale
\end_layout

\begin_layout Standard
One of the utility classes that is defined in the code, from which most
 of the classes in the code inherit, is the dobject class.
 Similarly, many of the variables contained in these classes are depend
 objects.
\end_layout

\begin_layout Standard
The depend object class has been designed so that every time it is accessed
 it checks all of the other depend objects on which it is dependent to see
 if they have changed, and if so recalculates its value.
 The dobject class overrides the mechanism by which you can access the members
 of an instance of it, so that they are accessed via the dependency detection
 functions.
\end_layout

\begin_layout Standard
These classes have been defined so that, instead of cluttering up the code
 with functions to recalculate the various parameters of the simulation,
 we simply have to define the function by which to recalculate them and
 the other objects which they depend upon when they are created, and then
 they will automatically be updated when required.
\end_layout

\begin_layout Standard
As an example, take the total kinetic energy for one replica of the system.
 This is a property of the total momentum vector and the mass vector of
 the different atoms.
 Therefore, we would create a 
\begin_inset Quotes eld
\end_inset

kin
\begin_inset Quotes erd
\end_inset

 object in the atoms class that has dependencies 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

momentum
\begin_inset Quotes erd
\end_inset

, and a recalculation function that calculated 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
frac{
\backslash
bf{p}^2}{2
\backslash
bf{m}}
\backslash
)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having done this, any time we access atoms.kin, the code will check to see
 if either the mass vector or momentum vector has changed.
 If it has will recalculate the kinetic energy before returning it, otherwise
 it will simply return the cached value.
\end_layout

\begin_layout Subsection
Synchronized objects
\end_layout

\begin_layout Standard
As well as checking for dependencies, the same infrastructure can also be
 used to synchronize two objects which are different representations of
 the same data.
 A good example of this is the bead coordinates in the cartesian and normal
 mode representations.
 Both of these represent the same data, but have different numerical values.
\end_layout

\begin_layout Standard
In this case we can use a synchronize object, which holds a dictionary of
 functions to transform one representation to another.
 In the case of the normal mode and cartesian representations of position,
 the transformation can be done either by multiplying the position vector
 by a transformation matrix, or via a Fourier transform.
\end_layout

\begin_layout Standard
Using this class, whenever we make a change to one of the representations,
 the others are automatically recalculated by reapplying the transformation
 function the next time they are accessed.
\end_layout

\begin_layout Section
Communication protocol
\end_layout

\begin_layout Standard
The 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 code is only a wrapper code; it only runs the molecular dynamics loop and
 does not calculate the force and potential acting on each particle.
 To do this 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 must interface with a driver code.
 The major design principle behind 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is to keep the wrapper and driver codes as far separated as possible.
 To this end, we run them completely separately, and only allow communication
 through a socket.
\end_layout

\begin_layout Subsection
Sockets
\end_layout

\begin_layout Standard
A socket is a data transfer device that is designed for internet communication.
 It supports both multiple connections to the same socket, and two way communica
tion.
 This makes it ideal for communication between the wrapper code and multiple
 driver codes.
\end_layout

\begin_layout Standard
Each socket is described by an IP address and a port number.
 On top of this, they can either be an internet socket or a local unix socket.
 Each of these different variables is important in a different way.
\end_layout

\begin_layout Standard
The IP address is specified in the code by the 
\begin_inset Quotes eld
\end_inset

address
\begin_inset Quotes erd
\end_inset

 tag.
 This is generally the name of the network on which the wrapper code is
 running, or localhost, which is the generic name for the network used for
 local communication.
\end_layout

\begin_layout Standard
The port number is specified in the code by the 
\begin_inset Quotes eld
\end_inset

port
\begin_inset Quotes erd
\end_inset

 tag.
 The port number is important because it is used to separate the different
 kinds of data transfer.
 The port number is an integer between 1-65535, each of which specifies
 a different port.
 As many of the lower numbers are protected for use in important system
 processes or internet communication, it is generally sensible to use numbers
 in the range 1025-65535 for simulations.
\end_layout

\begin_layout Standard
A unix or intenet socket is specified by the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

interface
\begin_inset Quotes erd
\end_inset

 tag.
 The unix/inet distinction is an important one, the unix socket is faster
 than an internet socket, but can only be used for local communication.
 Generally, the simulation should only be run locally if a simple classical
 potential is being used.
 If complicated empirical potentials or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 potentials are used the force calculation becomes the bottleneck in the
 code, so the advantage of using unix sockets is lost.
\end_layout

\begin_layout Standard
There are a two other input parameters that may be used.
 
\begin_inset Quotes eld
\end_inset

latency
\begin_inset Quotes erd
\end_inset

 specifies the length of time between each check to see if any new driver
 codes have connected, and 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 specifies how many driver codes can queue between checks.
 Neither is likely to be important in running the code, but may be used
 to optimize the data transfer if required.
\end_layout

\begin_layout Subsection
Data transfer
\end_layout

\begin_layout Standard
To make the transfer as simple as possible, the data is transferred in binary
 format.
 The transfer protocol is to send a header string of 12 characters specifying
 the stage of the data transfer, followed if necessary by data, then wait
 for data to be returned.
 We use 4-bit integers, 8-bit floats and 12 character strings for the transfer.
 A typical step is of the form:
\end_layout

\begin_layout Enumerate
A header string of 
\begin_inset Quotes eld
\end_inset

STATUS
\begin_inset Quotes erd
\end_inset

 is sent by the server socket, specifying what stage of the data transfer
 is being done.
\end_layout

\begin_layout Enumerate
A header string is then returned, giving the status.
 Recognized options are:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

NEEDINIT
\begin_inset Quotes erd
\end_inset

: If the driver code needs any initialising data, it can be sent here.
 The server code will then send a header string 
\begin_inset Quotes eld
\end_inset

INIT
\begin_inset Quotes erd
\end_inset

, followed by an integer giving the number of bits in the initialization
 string, then the initialization string itself.
 [Deprecated, may be removed from later versions of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

]
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

READY
\begin_inset Quotes erd
\end_inset

: Sent if the driver code is ready to calculate the forces.
 The server socket will then send a string 
\begin_inset Quotes eld
\end_inset

POSDATA
\begin_inset Quotes erd
\end_inset

, then nine floats the cell vector matrix, then another nine floats for
 the inverse matrix, (which need to be transposed if the driver code is
 written in fortran).
 The server socket will then send one integer giving the number of atoms,
 then the position data as 3 floats for each atom giving the 3 cartesian
 components of the bead position.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

HAVEDATA
\begin_inset Quotes erd
\end_inset

: This is sent if the driver has calculated the potential and forces.
 The server socket then sends a string 
\begin_inset Quotes eld
\end_inset

GETFORCE
\begin_inset Quotes erd
\end_inset

, and the client socket returns 
\begin_inset Quotes eld
\end_inset

FORCEREADY
\begin_inset Quotes erd
\end_inset

.
 The potential is then returned as a float, the number of atoms as an integer,
 then the force data as 3 floats per atom in the same way as the positions,
 and the virial as 9 floats in the same way as the cell vector matrix.
\end_layout

\end_deeper
\begin_layout Enumerate
The server socket waits until the force data for each replica of the system
 has been calculated and returned, upon which the job is finished and the
 molecular dynamics loop starts.
\end_layout

\begin_layout Subsection
Parallelization
\end_layout

\begin_layout Standard
This type of data transfer is well suited to working with PIMD, as it allows
 multiple driver codes to connect to the server socket of one simulation,
 so that different replicas of the system can be assigned to different driver
 codes so their forces can be computed in parallel.
\end_layout

\begin_layout Standard
In the case that there are as many driver codes as replicas of the system,
 this is very simple, as each replica will be assigned its own driver code.
 For most potentials, the slowdown due to the socket communication is not
 appreciable, and in this case the force calculation will essentially be
 as fast as a purely classical simulation.
 
\end_layout

\begin_layout Standard
Also, for subsequent steps, the interface will assign a particular replica
 of the system to the same driver code which calculated the forces for it
 the last step.
 This reduces the amount the configuration changes between calculations
 on a particular driver code, which can speed up certain calculations.
\end_layout

\begin_layout Standard
In the case where there are fewer driver codes than beads, the socket interface
 will assign spare jobs to the first driver code that finishes running,
 after matching all possible jobs to the same driver code that calculated
 it last time step.
\end_layout

\begin_layout Standard
This is especially useful when the calculations are being run on a cluster.
 In this case, you can split up the driver codes, and they will connect
 whenever they reach the front of the queue.
 More driver codes can connect at any time, and if there is a problem and
 any driver code dies, it is simply removed from the driver list and any
 job it was running reassigned.
\end_layout

\begin_layout Chapter
Installing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{install}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
Background and nomenclature
\end_layout

\begin_layout Subsection
Molecular dynamics
\end_layout

\begin_layout Plain Layout
Molecular dynamics is a way of sampling the possible states of a system
 by propagating the positions and momenta of the particles in the system
 in discrete time steps according to a set of physical rules.
\end_layout

\begin_layout Plain Layout
By choosing the algorithm used to propagate the momenta correctly, the probabili
ty of the system being in a particular state will be the same as that of
 a physically realistic system, such as a system in contact with an external
 heat bath.
\end_layout

\begin_layout Plain Layout
We will call the complete set of possible states of the system an ensemble
 of states.
 The relevant ensembles we will be interested in are: 
\end_layout

\begin_layout Description
NVE ensemble This gives constant particle number, volume and energy, and
 corresponds to an isolated physical system.
 
\end_layout

\begin_layout Description
NVT ensemble This gives constant particle number, volume and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath.
 
\end_layout

\begin_layout Description
NPT ensemble This gives constant particle number, pressure and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath and in equilibrium with a pressure bath.
 
\end_layout

\begin_layout Plain Layout
We will call the total number of possible states of a system for any given
 set of external variables the partition function of that system.
\end_layout

\begin_layout Plain Layout
In any practical simulation, the number of atoms has to be far fewer than
 the typical number present in the physical system of interest, for reasons
 of computational difficulty.
 This means that a high proportion of the particles in the simulation are
 likely to be on the edge of the simulation box.
 To prevent this having a large effect on the properties of the system,
 all of the driver codes implement what is known as periodic boundary conditions.
 This***********************************************88 
\end_layout

\begin_layout Subsection
Path integral generalization
\end_layout

\begin_layout Plain Layout
In the path integral generalization of classical mechanics, we use the following
 isomorphism between the quantum partition function of a system and a classical
 partition function in a higher phase space: 
\begin_inset Formula 
\begin{equation}
Q=\Tr(e^{-\hat{H}\beta})
\end{equation}

\end_inset

 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\left(\frac{2\pi m}{h^{2}\betan}\right)^{\frac{3}{2}}e^{-\hat{U}_{N}\betan}\dd\textbf{r}_{i}\right]\\
 & \hat{U}_{N}=\sum_{i=1}^{N}\left[\frac{m}{2\betan^{2}\hbar^{2}}(\textbf{r}_{i}-\textbf{r}_{i-1})^{2}+\hat{V}_{i}\right]\\
 & \betan=\frac{\beta}{N}\nonumber 
\end{align}

\end_inset

 Where 
\begin_inset Formula \ensuremath{\hat{H}}

\end_inset

 is the quantum Hamiltonian of the system, which is the operator corresponding
 to the observable energy, 
\begin_inset Formula \ensuremath{\hat{V}_{i}}

\end_inset

 is the potential of the replica of the system corresponding to the label
 
\begin_inset Formula \ensuremath{i}

\end_inset

, and 
\begin_inset Formula \ensuremath{\hat{U}_{N}}

\end_inset

 is a classical configurational Hamiltonian in the extended phase space,
 which only depends on particle coordinates.
\end_layout

\begin_layout Plain Layout
In practice we do not need to go to the limit of infinite 
\begin_inset Formula \ensuremath{N}

\end_inset

, as convergence can often be achieved with a small increase of phase space.
 Note that this classical Hamiltonian is equivalent to that of a 
\begin_inset Formula \ensuremath{N}

\end_inset

 replicas of the original system, with a harmonic potential between adjacent
 replicas.
 We will call this set of replicas of each atom a ring polymer, and the
 component particles of this ring polymer beads.
\end_layout

\begin_layout Plain Layout
The last thing we must do to make the connection with molecular dynamics
 is to add fictitious ring polymer momenta to allow us to sample the phase
 space more effectively.
 In our code we make the choice corresponding to assigning each bead the
 mass of the corresponding atom: 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\left(\frac{1}{2\pi\hbar}\right)^{3}e^{-\hat{H}_{N}\betan}\dd\textbf{r}_{i}\dd\textbf{p}_{i}\right]\\
 & \hat{H}_{N}=\hat{U}_{N}+\sum_{i=1}^{N}\frac{\textbf{p}_{i}^{2}}{2m}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout
This is then the partition function corresponding to the NVE ensemble for
 the quantum system, and as it has a purely classical Hamiltonian the algorithms
 used in classical dynamics and the generalizations used to sample other
 ensembles can be applied to this system in exactly the same way as for
 a classical system.
 
\end_layout

\begin_layout Subsection
Ab initio potentials
\end_layout

\begin_layout Plain Layout
An ab initio potential is one that does not require any experimentally derived
 parameters in its calculation.
 Under the strictest sense of the term many of the most popular DFT algorithms
 are not ab initio as they do use experimentally determined parameters,
 but as prior simulations are not necessary for the formulation of a DFT
 potential, we will define DFT as such for the purposes of this manual.
\end_layout

\begin_layout Plain Layout
DFT calculations are done by minimising an energy with respect to the one
 electron probability density, rather than the wavefunction as is common
 in most other ab initio potentials.
 The energy is given in terms of that of a fictitious system without electron
 interaction, for which the energy can be found exactly, plus an energy
 term due to electron correlation.
 This is the quantity of fundamental importance in DFT calculations, and
 while no analytic form for it exists several useful approximations to it
 have been created.
 We will call these correlation functionals.
\end_layout

\begin_layout Plain Layout
DFT calculations are done via an iterative procedure where a guess for the
 one electron wavefunctions are made so that the energy can be calculated,
 and a new set of one electron wavefunctions are then calculated by minimising
 this energy.
 The new wavefunctions are then put back into the first step and the procedure
 repeated until the initial and final density matrices are consistent.
\end_layout

\begin_layout Plain Layout
In what is known as Car-Parrinello molecular dynamics, the converged wavefunctio
ns of one step are then used as the starting point for the next step, drasticall
y accelerating the convergence.
\end_layout

\begin_layout Plain Layout
Another important consideration is the basis set used for the 
\end_layout

\end_inset


\end_layout

\begin_layout Section
System requirements
\end_layout

\begin_layout Standard
To install and run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, you will need to have:
\end_layout

\begin_layout Itemize
A modern C compiler
\end_layout

\begin_layout Itemize
Python version 2.4 or later
\end_layout

\begin_layout Itemize
The Python array library NumPy
\end_layout

\begin_layout Standard
Additionally, most driver codes will have their own software requirements.
 Many of them, including the test driver codes given in the test directories,
 will need a fortran compiler.
 Most will also need to be linked with some mathematical libraries, such
 as BLAS, FFTW and LAPACK.
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 download
\end_layout

\begin_layout Standard
A tar file can be downloaded from the website [appropriate wrap-pi website].
 To install this you need to input the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> tar xf [wrapper_tar_file.tar]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also download the git repository at [github repository name] using
 the commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> git clone [github repository name]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
NumPy download
\end_layout

\begin_layout Standard
Many clusters do not have NumPy already installed upon them.
 How NumPy can be installed depends on whether you have root access or not,
 and on the version of python you are using.
\end_layout

\begin_layout Standard
In any case you must first obtain the NumPy code.
 The numpy library can be downloaded as a tar file from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://sourceforge.net/projects/numpy/files/NumPy/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This must then be extracted using the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $np_dd_dir
\end_layout

\begin_layout Plain Layout

> tar czf $np_vers.tar.gz
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You must now install this code.
 Note that this requires the distutils package that comes with the python-dev
 package.
 Assuming that the required software is installed, the NumPy package is
 built using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py build
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to install the package.
 By default the download is to the directory /usr/local.
 This however is only accessible if you have root access.
 In this case all that needs to be done to finish the install is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you do not have root access, then the next step depends on which version
 of Python is beind used.
 With versions 2.6 or later there is a simple command to automatically download
 into the directory $HOME/local:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --user
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With Python 2.4/2.5 the process is a little more involved.
 First you must explicitly install the package in the directory of choice
 with the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --prefix=$np_dir
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, you must tell python where to find this library, by appending to the
 linux environment variable 
\series bold
PYTHONPATH
\series default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> export PYTHONPATH=$PYTHONPATH:$np_dir/lib64/$py_vers/site-packages
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may have to replace lib64 with lib depending on whether you are installing
 to a 64-bit or 32-bit architecture.
\end_layout

\begin_layout Section
Driver installation and compilation
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Standard
You can download the source code for Quantum Espresso at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espresso.org/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For Quantum Espresso version 4.3.2, there is a patch file to allow it to be
 used as a driver code with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 in the directory $src_dir/patches/pwscf.
 This can be applied to the Quantum Espresso source code using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $esp_dd_dir
\end_layout

\begin_layout Plain Layout

> tar zxvf $esp_vers.tar.gz
\end_layout

\begin_layout Plain Layout

> patch -p1 < $src_dir/patches/pwscf
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, continue the download as per the instructions at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espress.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
Later versions of the code already have driver functionality, and so no
 patch needs to be applied before compiling.
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
Several test cases are distributed with the code to ensure that your distributio
n is working correctly.
 There are also simple tests to see if the driver codes are working correctly.
\end_layout

\begin_layout Standard
All the input files are contained in the directory test, which is subdivided
 into the following directories:
\end_layout

\begin_layout Description
lj: This gives a simple classical Lennard-Jones simulation of Ne.
 The state point is given by (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.35, 1.62) in reduced Lennard-Jones units, so that the results
 can be compared to those in the paper
 
\lang english

\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{lverlet67pr}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
ph2: This simulates para-hydrogen using the isotropic Silvera-Goldman pair
 potential.
 There are two directories, nvt and Tuckerman, which can be compared to
 the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mill-mano05jcp}
\end_layout

\end_inset

 and 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mart-tuck99jcp}
\end_layout

\end_inset

 respectively.
\end_layout

\begin_layout Chapter
Running 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{run}
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run the wrapper
\end_layout

\begin_layout Subsection
Command line interface
\end_layout

\begin_layout Standard
The best way to run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is via the command line.
 If the xml-formatted input file is called input_file.xml, then the command
 to do this is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python $src_dir/main.py input_file.xml
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the recommended way of initializing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, as it is both the simplest, and the easiest to script for lots of similar
 runs with different parameters.
\end_layout

\begin_layout Subsection
Python interface
\end_layout

\begin_layout Standard
It is also possible to run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 from inside a Python script.
 This can be done via the following code:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

from main import *
\end_layout

\begin_layout Plain Layout

\end_layout

\begin_layout Plain Layout

main("input_file.xml")
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run the driver
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Section
Running simulations
\end_layout

\begin_layout Subsection
Running a simulation
\end_layout

\begin_layout Standard
A simulation is run by first running a wrapper code as above, and then connectin
g to the socket with one or more driver codes.
 For a small simulation, with a simple classical potential, it may be preferable
 to run both halves of the simulation on the same computer, especially as
 this allows us to use the faster unix domain sockets.
 If we assume that the driver code is run by the command 
\series bold
driver_comm
\series default
, the following code will run the wrapper, outputting the statistics to
 a file log, and 4 driver codes, then background the result:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> bash -c "python $src_dir/main.py input_file.xml &> log &"
\end_layout

\begin_layout Plain Layout

> for a in `seq 1 4`
\end_layout

\begin_layout Plain Layout

> do bash -c "driver_comm &> 
\backslash
dev
\backslash
null &"
\end_layout

\begin_layout Plain Layout

> done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
In general, we want to choose the number of driver codes to be a divisor
 of the total number of replicas of the system, as otherwise there will
 be idle driver codes at the end of each step.
\end_layout

\begin_layout Standard
For most simulations, especially those running with expensive ab initio
 forces and potentials, we will want to run the code on a computational
 cluster.
 The best way to do this is to have the wrapper code running on the head
 node of the cluster, where we have the most control over it, and run the
 driver codes on the cluster nodes.
\end_layout

\begin_layout Standard
Here we make use of both the inherent parallelization in the partitioning
 of different replicas to different drivers, and the socket communication
 mechanism which allows data transfer either by internet connection or by
 ssh tunnelling.
\end_layout

\begin_layout Standard
The only modification required to the above code to do this is to change
 the driver command such that the driver code is submitted to the job queue
 rather than ran on the head node.
 The usual process required to do this is to write a shell script which
 runs the driver codes, then use a program such as qsub to submit this job
 to the cluster.
\end_layout

\begin_layout Subsection
Running multiple simulations
\end_layout

\begin_layout Standard
While running one simulation is useful, the power of the socket communications
 method is most aptly demonstrated when multiple simulations are run at
 once.
\end_layout

\begin_layout Standard
Firstly, the wrapper code is dormant until a driver code connects to the
 socket, so many wrapper codes can be run at once without using large amounts
 of CPU time waiting for the driver codes.
 This is especially useful when the driver codes are being run on a cluster,
 and may have to wait a long time to reach the front of the queue.
\end_layout

\begin_layout Standard
Secondly, each different simulation can be kept separate very easily, by
 just adjusting the port number of each parallel simulation.
 This is very easy to write a shell script to do.
 For example, if we assume the simulations will be run in directories called
 sim_1, sim_2, etc., then we can write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> i=0
\end_layout

\begin_layout Plain Layout

> for a in sim_*
\end_layout

\begin_layout Plain Layout

> do cd $a
\end_layout

\begin_layout Plain Layout

>   ((i++))
\end_layout

\begin_layout Plain Layout

>   port=((10000+$i))
\end_layout

\begin_layout Plain Layout

>   sed s/XXX/$port/g input.template > $a/input_file.xml
\end_layout

\begin_layout Plain Layout

>   cd ..
\end_layout

\begin_layout Plain Layout

> done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will replace a string 
\begin_inset Quotes eld
\end_inset

XXXX
\begin_inset Quotes erd
\end_inset

 in a template file with a port number, which will be different for each
 simulation.
\end_layout

\begin_layout Section
Input files
\end_layout

\begin_layout Subsection
xml file
\end_layout

\begin_layout Standard
This is the main input file from which the simulation parameters are initialized.
 The standard xml format is a set of hierarchially nested tags, each with
 a start tag, which may or may not have an attribute parameter, some contained
 data, which may or may not contain other tags, and a closing tag.
 The syntax required is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag_name attribute_name='attribute_data'>tag_data</tag_name>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code uses this hierarchial structure to help read the data; if a particular
 object is held within a parent object in the code, then the tag for that
 object will be within the appropriate parent tags.
 In this manner, the entire class structure needed for the simulation can
 be constructed iteratively; the data between the two tags is assumed to
 correspond to data held within the object given by the tag name, which
 may have more tags corresponding to other child objects, so data held within
 those tags are assumed to correspond to data held within the child objects,
 and so on until all the data has been read.
\end_layout

\begin_layout Standard
To help detect any user error the acceptable tag names, type of data and
 possible default values are all specified in the code, in a specialized
 input class for each class of object.
 More information on how the xml file is read can be found in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{dev}
\end_layout

\end_inset

, and a full list of all the available tags and a brief description of their
 function is given in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{hierarchy}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Configuration file
\end_layout

\begin_layout Standard
The initial configuration data can be initialized both through the xml file,
 and through a separate configuration file.
 The configuration file is specified using the 
\begin_inset Quotes eld
\end_inset

from_file
\begin_inset Quotes erd
\end_inset

 tag name in the xml file.
 The currently accepted file formats are:
\end_layout

\begin_layout Itemize
pdb
\end_layout

\begin_layout Itemize
xyz
\end_layout

\begin_layout Standard
These files can be used to specify the initial centroid positions and atom
 identities and, depending on the format, the cell parameters as well.
 The code will then try to assign masses to the atoms based on their atomic
 symbol, and an appropriate cell 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 for use in constant pressure simulations.
 Any of this data can be overwritten by the xml file by using the appropriate
 tag names and data.
\end_layout

\begin_layout Subsection
Units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 uses the following set of internal units:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S.I.
 Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bohr radius
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2917721e-11 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4188843e-17 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Atomic mass unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1.6605387e-27 kg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kelvin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Energy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hartree
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3597438e-18 J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pressure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.9421912e13 Pa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
However, these units can be overriden in the input file by using the 
\begin_inset Quotes eld
\end_inset

units
\begin_inset Quotes erd
\end_inset

 attribute.
 For example, if you wanted to specify the cell parameters in units of angstrom
 rather than bohr radii, then in the input file you would specify:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<h units='angstrom'> ...
 </h>
\backslash
end{verbatim}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Driver input
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Section
Output files
\end_layout

\begin_layout Subsection
Property file
\end_layout

\begin_layout Standard
This is the output file for for all the system and simulation level properties,
 such as the total energy and the overall time taken.
 The properties that are output are determined by the properties list in
 the xml input file.
\end_layout

\begin_layout Standard
The format of the property list is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<properties>
\end_layout

\begin_layout Plain Layout

   [ prop1name, prop2name, prop3name(arg1; arg2), ...
  ]
\end_layout

\begin_layout Plain Layout

</properties>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Some of the properties that require array indices or other parameters to
 be specified will require the arguments to be specified as shown above.
 A full list of the allowed property names is given below:
\end_layout

\begin_layout Description
time: Total time elapsed in the simulation.
\end_layout

\begin_layout Description
step: The current simulation time step.
\end_layout

\begin_layout Description
conserved: The value of the conserved quantity for the simulation.
\end_layout

\begin_layout Description
temperature: The system temperature.
 Note that for path integral simulations this is not the same as the simulation
 temperature, as the particles are held at a higher classical temperature.
\end_layout

\begin_layout Description
volume: The volume of the system box.
\end_layout

\begin_layout Description
h: The unit cell vector matrix.
 You must specify the args x and v to get the index h[x,v].
 If not specified, they both default to 0.
\end_layout

\begin_layout Description
potential: The potential energy of the system.
\end_layout

\begin_layout Description
kinetic_md: The classical simulation kinetic energy.
\end_layout

\begin_layout Description
kinetic_cv: The centroid virial quantum kinetic energy estimator.
\end_layout

\begin_layout Description
stress_md: The classical stress tensor.
 You must specify the args x and v to get the index stress_md[x,v].
 If not specified, they both default to 0.
\end_layout

\begin_layout Description
stress_cv: The quantum stress tensor estimator.
 You must specify the args x and v to get the index stress_cv[x,v].
 If not specified, they both default to 0.
\end_layout

\begin_layout Description
pressure_md: The classical simulation pressure.
 
\end_layout

\begin_layout Description
pressure_cv: The quantum pressure estimator.
\end_layout

\begin_layout Description
kstress_cv: The quantum kinetic stress tensor estimator.
 You must specify the args x and v to get the index stress_cv[x,v].
 If not specified, they both default to 0.
\end_layout

\begin_layout Description
kin_yama: The scaled path quantum kinetic energy estimator.
\end_layout

\begin_layout Description
linlin: A point of the scaled Fourier transform of the momentum distribution.
 Given by 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
tilde{n}(
\backslash
textbf{x})
\backslash
)
\end_layout

\end_inset

 in Phys.
 Rev.
 Lett.
 
\series bold
105
\series default
, 110602.
 You must specify the args ux, uy and uz to give the displaced path vector,
 and atom to give the atom for which the path will be opened.
\end_layout

\begin_layout Standard
The format of the file is given by a comment line giving the name of all
 the properties to be printed, followed by the rows giving their values
 at regular intervals given by the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 The file is fixed formatted, with two blank characters at the start of
 each row, then the data in the same order as the header row.
 Each column is 16 characters wide and every float is written in exponential
 format with 8 digits after the decimal point.
\end_layout

\begin_layout Subsection
Trajectory files
\end_layout

\begin_layout Standard
These are the output file for atomic properties.
 It will print out a configuration in the format given by the 
\begin_inset Quotes eld
\end_inset

traj_format
\begin_inset Quotes erd
\end_inset

 parameter in the xml input file at intervals governed by the value of the
 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 Depending on the chosen property to output, it will either print a file
 for each bead or just for each atom.
 The possible choices of output properties are:
\end_layout

\begin_layout Description
positions: Gives the bead positions.
 Prints a separate file for each replica of the system
\end_layout

\begin_layout Description
velocities: As above, except prints the velocities.
\end_layout

\begin_layout Description
forces: As above, except prints the forces.
\end_layout

\begin_layout Description
kinetic_cv: Prints the contribution of each atom to the total kinetic energy.
 Prints only one file.
\end_layout

\begin_layout Description
kodterms_cv: Prints the off-diagonal contributions to the kinetic energy
 tensor.
 Prints only one file.
\end_layout

\begin_layout Description
centroid: Prints the position of the centroid coordinate of each atom.
 Prints only one file.
\end_layout

\begin_layout Standard
The allowable file formats for the trajectory output files are the same
 as for the configuration input files.
\end_layout

\begin_layout Section
Restart mechanism
\end_layout

\begin_layout Subsection
Restart file
\end_layout

\begin_layout Standard
As well as the above output files, the state of the system at a particular
 time step can also be saved to file.
 This gives a valid input file, with all the information required to restore
 the state of the system to what it was when the restart file was created.
 It is printed out at regular intervals, with a stride governed by the 
\begin_inset Quotes eld
\end_inset

checkpoint
\begin_inset Quotes erd
\end_inset

 keyword of the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
\end_layout

\begin_layout Subsection
Soft exit
\end_layout

\begin_layout Standard
To stop the program in such a way that it makes sure to save the data generated
 in a restart file, simply create a file 
\begin_inset Quotes eld
\end_inset

EXIT
\begin_inset Quotes erd
\end_inset

 in the directory in which you are running the code.
 The thread will automatically detect this and safely shut down the program.
 
\end_layout

\begin_layout Standard
An important point to note is that since each time step is split into several
 parts, it is only at the beginning of each step that all the variables
 are consistent with each other in such a way that the simulation can be
 restarted from them without changing the dynamics.
 Thus if a soft exit call is made during a step, then the restart file that
 is created must correspond to the state of the system at the start of the
 step.
 To this end, the state of the system is saved at the start of every step.
\end_layout

\begin_layout Chapter
Algorithms
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{algorithms}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Integrators
\end_layout

\begin_layout Subsection
Trotter decomposition
\end_layout

\begin_layout Subsection
Ring polymer normal mode coordinates
\end_layout

\begin_layout Subsection
Constant temperature simulations
\end_layout

\begin_layout Subsection
Constant pressure simulations
\end_layout

\begin_layout Section
Output
\end_layout

\begin_layout Subsection
Estimator theory
\end_layout

\begin_layout Chapter
Developer's tips
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{dev}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Standard
While many of the simple properties of interest can be output directly to
 the properties output file, and many others can be obtained by post-processing
 the available data, it may be that some property you wish to calculate
 is not explicitly available for output.
\end_layout

\begin_layout Standard
In this case, you may wish to modify the code so that this property can
 be output.
 All the code to do this is found in the 
\begin_inset Quotes eld
\end_inset

properties.py
\begin_inset Quotes erd
\end_inset

 module in the 
\begin_inset Quotes eld
\end_inset

engine
\begin_inset Quotes erd
\end_inset

 directory.
 To add a new property to the existing list, you must first define a function
 that calculates this property.
\end_layout

\begin_layout Standard
In standard Python notation, we must define a new function inside the 
\begin_inset Quotes eld
\end_inset

Properties
\begin_inset Quotes erd
\end_inset

 class.
 This is written by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def new_func(self):
\end_layout

\begin_layout Plain Layout

   ...code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now use this function to calculate the property of interest.
 If the name of this property is 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

, we can add this to the dictionary of named properties by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict[new_prop] = new_func
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now simply need to add the name 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 list in the xml input file, and the property will be written to the properties
 output file when appropriate.
\end_layout

\begin_layout Standard
If you need a function with arguments, then the code we need is given by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict[new_arg_prop] = new_arg_func
\end_layout

\begin_layout Plain Layout

...code here...
\end_layout

\begin_layout Plain Layout

def new_arg_func(self, arg1, arg2, ...
 ):
\end_layout

\begin_layout Plain Layout

   ...more code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now in the property list you must put:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<properties>
\end_layout

\begin_layout Plain Layout

   [ new_arg_prop(arg1; arg2; ...
 ), ...
 ]
\end_layout

\begin_layout Plain Layout

</properties>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code will now automatically call the function with the arguments defined
 in the properties list.
\end_layout

\begin_layout Section
Creating a new class
\end_layout

\begin_layout Standard
While creating a new property may be possible by using existing objects,
 it may be that you wish to calculate something in a way that is not implemented
 by the code.
 In this case, it may be necessary to create a new class to do the calculation.
 To do this efficiently, you must be understand some of the more advanced
 features of the code.
\end_layout

\begin_layout Subsection
Depend objects
\end_layout

\begin_layout Standard
Many of the new objects created inside a class may depend on other objects
 in the code for their value.
 As discussed in Chapter 3, the calculation of such variables is facilitated
 by the use of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 classes defined in the 
\begin_inset Quotes eld
\end_inset

utils
\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Standard
Since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overwrites the standard way of getting and setting functions, so
 there is a special syntax for creating them.
 To create a depend object 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 with name 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 inside an object 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

, you need to use the syntax: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

dset(object, name, value)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The arguments that are important for creating 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects are:
\end_layout

\begin_layout Description
name: A string giving the name of the depend object.
\end_layout

\begin_layout Description
value: 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 only.
 Defines the memory the object references.
\end_layout

\begin_layout Description
synchro: An optional 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This keeps track of different views on the same data.
\end_layout

\begin_layout Description
func: An optional function to recalculate the object when one of its dependencie
s are updated.
\end_layout

\begin_layout Description
dependencies: An optional list of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects which are required to recalculate the new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object.
 Essentially a list of all the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects that appear in 
\series bold
func
\series default
.
\end_layout

\begin_layout Standard
There are two different classes of 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, 
\begin_inset Quotes eld
\end_inset

depend_value
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class is a specialist class for NumPy arrays, to deal with the slicing
 mechanism.
 This means that for the 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class there is a second method of creating new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, you can take a slice of an old one.
 
\end_layout

\begin_layout Standard
This will return a slice with the same dependencies and synchro objects,
 and a reference to the correct slice of the base array of the parent 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object, so that the automatic updating keeps all the data consistent.
 Note that it is therefore incorrect to create a new 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object that is a slice of an old one using the 
\series bold
dset
\series default
 function, as it will not copy the dependencies correctly.
\end_layout

\begin_layout Standard
There is also a method for dealing with separate objects that are different
 views on the same data; the 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This object is shared with all of the different views to the same data,
 and deals with keeping all of them consistent with each other.
\end_layout

\begin_layout Standard
Also, the 
\series bold
func
\series default
 initialization argument must be a dictionary of functions that transform
 from the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object being created to the other synchronized objects, using the syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

func = {synchro1: func1, synchro2: func2, ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 of the Nth synchro object, and 
\begin_inset Quotes eld
\end_inset

funcN
\begin_inset Quotes erd
\end_inset

 transforms from the 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 object to the one being created.
\end_layout

\begin_layout Standard
Finally, there are several utility functions that help to manipulate 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects:
\end_layout

\begin_layout Description
dget: Gets a specified 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overrides the standard Python method of getting attributes, so you
 need a way to get the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object and not just its value.
\end_layout

\begin_layout Description
dset: Creates a 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed for the same reason as 
\series bold
dget
\series default
.
\end_layout

\begin_layout Description
depstrip: Takes a 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object and returns the base array.
 Useful in algorithms where the array is used as a read-only variable, as
 it removes the dependancy network from the object, and so speeds up the
 calculation.
\end_layout

\begin_layout Description
depcopy: Copies the 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 objects from one 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object to another.
\end_layout

\begin_layout Description
deppipe: Creates a new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object so that it keeps the same value as one that has already been created.
\end_layout

\begin_layout Subsection
Input class
\end_layout

\begin_layout Standard
To be able to use the xml input file to create an instance of this new class,
 and to write the file to the restart file, you must create a new input
 class, or modify an old one to recognize the new class.
\end_layout

\begin_layout Standard
Each input class must have the following class attributes:
\end_layout

\begin_layout Description
fields: This is a dictionary giving the tag names for the objects that can
 be specified in the xml input file within the tags of your class.
 Every object that can be given a value by the user should be a keyword
 of this dictionary, or of the 
\series bold
attributes 
\series default
dictionary.
 Within the dictionary, you must specify the particular class of input object
 that will be created and arguments to initialize it.
 The format of the dictionary is: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

{tag_name1 :
\end_layout

\begin_layout Plain Layout

   (InputClass, 
\end_layout

\begin_layout Plain Layout

      {default: default value,
\end_layout

\begin_layout Plain Layout

       help: help string, 
\end_layout

\begin_layout Plain Layout

       dtype: data type,
\end_layout

\begin_layout Plain Layout

       options: [option1, option2, ...
 ],
\end_layout

\begin_layout Plain Layout

       dimension: dimensionality of the data}), 
\end_layout

\begin_layout Plain Layout

tag_name2: ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Description
attribs: This is a dictionary of the same form as 
\series bold
fields
\series default
, but for the tag attribute data instead.
 These should always be simple data classes InputValue or InputArray, as
 their value must be specified by the user.
\end_layout

\begin_layout Description
default_help: This is the help string that will be given to help explain
 the new class to others if no other help string is given.
 It will also be the help string seen in the section in the latex file for
 the new class.
\end_layout

\begin_layout Description
default_label: This is the label used to identify the appropriate section
 in the latex help file so that different sections can cross-reference with
 the others.
\end_layout

\begin_layout Standard
The class can have the following functions:
\end_layout

\begin_layout Description
fetch: This takes the InputClass object and creates a new object of your
 class from it.
 You must make sure to call the base class fetch function using the standard
 Python function super.
\end_layout

\begin_layout Description
store: This takes an object of your class, and stores the relevant information
 needed to reinitialize it in an InputClass object.
 You must make sure to call the base class store function using the standard
 Python function super.
\end_layout

\begin_layout Description
check: This is an optional function that will check to see if the data specified
 in the input file will create a valid instance of your class, and possibly
 raise an exception otherwise.
 You must make sure to call the base class check function using the standard
 Python function super.
\end_layout

\begin_layout Description
write: This is a function that you can use to override the base class write
 function, so that you can tailor what is printed to the restart file.
\end_layout

\begin_layout Standard
The last thing that you must do to be able to use your class is to create
 an appropriate fields tag in the parent input class where you want the
 instance of your class to be held, with InputClass set to the name of your
 input class, and alter the check, store and fetch functions of the input
 class of the parent class.
\end_layout

\begin_layout Section
Submitting patches
\end_layout

\begin_layout Standard
This code is still in developement, and any submissions to improve the code
 are welcome.
 However, to be considered as a candidate for inclusion in the main version
 of the code additions must adhere to the standards described in this section.
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Chapter
Input class hierarchy
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{hierarchy}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following chapter gives a complete list of the tags that can be specified
 in the xml input file, along with the hierarchy of objects.
 Note that every xml input file must start with the root tag 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

.
 See the accompanying 
\begin_inset Quotes eld
\end_inset

help.xml
\begin_inset Quotes erd
\end_inset

 file in the 
\begin_inset Quotes eld
\end_inset

doc
\begin_inset Quotes erd
\end_inset

 directory to see the recommended input file structure.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{simulation}
\end_layout

\begin_layout Plain Layout


\backslash
input{ensembles}
\end_layout

\begin_layout Plain Layout


\backslash
input{forces}
\end_layout

\begin_layout Plain Layout


\backslash
input{interface}
\end_layout

\begin_layout Plain Layout


\backslash
input{cell}
\end_layout

\begin_layout Plain Layout


\backslash
input{beads}
\end_layout

\begin_layout Plain Layout


\backslash
input{atoms}
\end_layout

\begin_layout Plain Layout


\backslash
input{barostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{thermostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{prng}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "mybib"
options "/home/joshuamore/Downloads/elsarticle/model1-num-names"

\end_inset


\end_layout

\end_body
\end_document
