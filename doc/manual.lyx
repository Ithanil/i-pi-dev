#LyX 2.0 created this file. For more info see http://www.lyx.org/
\lyxformat 413
\begin_document
\begin_header
\textclass report
\begin_preamble
\@ifundefined{definecolor} {\usepackage{color}}{}
\usepackage{multicol}\makeindex
\usepackage{xspace}
\usepackage[numbers]{natbib}
\end_preamble
\options fleqn
\use_default_options false
\maintain_unincluded_children false
\language english
\language_package default
\inputencoding auto
\fontencoding global
\font_roman default
\font_sans default
\font_typewriter default
\font_default_family default
\use_non_tex_fonts false
\font_sc false
\font_osf false
\font_sf_scale 100
\font_tt_scale 100

\graphics default
\default_output_format default
\output_sync 0
\bibtex_command default
\index_command default
\paperfontsize 12
\spacing single
\use_hyperref true
\pdf_bookmarks true
\pdf_bookmarksnumbered false
\pdf_bookmarksopen false
\pdf_bookmarksopenlevel 1
\pdf_breaklinks false
\pdf_pdfborder false
\pdf_colorlinks false
\pdf_backref section
\pdf_pdfusetitle true
\papersize default
\use_geometry false
\use_amsmath 2
\use_esint 1
\use_mhchem 1
\use_mathdots 1
\cite_engine basic
\use_bibtopic false
\use_indices false
\paperorientation portrait
\suppress_date false
\use_refstyle 0
\index Index
\shortcut idx
\color #008000
\end_index
\secnumdepth 3
\tocdepth 3
\paragraph_separation indent
\paragraph_indentation default
\quotes_language english
\papercolumns 1
\papersides 1
\paperpagestyle default
\tracking_changes false
\output_changes false
\html_math_output 0
\html_css_as_file 0
\html_be_strict false
\end_header

\begin_body

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
dd}{
\backslash
; 
\backslash
mathrm{d}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Tr}{
\backslash
mathrm{Tr}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
bra}{< 
\backslash
! 
\backslash
!} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
ket}{
\backslash
! 
\backslash
! >} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
betan}{
\backslash
beta_N} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
logn}{
\backslash
mathrm{ln}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
expon}{
\backslash
mathrm{exp}} 
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
Imag}{
\backslash
mathrm{Im}}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
wrappi}{{
\backslash
sc wrap-PI}
\backslash
xspace}
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
DFT}{Quantum Espresso, CP2K, CPMD and FHI-AIMS }
\end_layout

\begin_layout Plain Layout


\backslash
newcommand{
\backslash
empirical}{LAMMPS}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{titlepage}
\end_layout

\end_inset

 
\end_layout

\begin_layout Standard
\align center
\begin_inset VSpace 5.5cm*
\end_inset


\end_layout

\begin_layout Standard
\align center

\size largest
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\align center
A Python wrapper for Path Integral Molecular Dynamics
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
end{titlepage}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{roman}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset toc
LatexCommand tableofcontents

\end_inset


\begin_inset FloatList figure

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Newpage newpage
\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
pagenumbering{arabic}
\end_layout

\end_inset


\end_layout

\begin_layout Chapter
Introduction
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{intro}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is a path integral molecular dynamics (PIMD) wrapper code written in Python
 for use with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 density functional theory (DFT).
 It currently works with the DFT codes 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
DFT
\end_layout

\end_inset

 and the classical code 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
empirical
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
It is designed to separate the calculation of the potential energy, forces
 and virial of a system from the algorithmic steps that propagate the dynamics.
 The rationale behind this is that for 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 PIMD the force calculation generally takes much more time than the propagation
 steps, and so there is no reason to optimize the running of the latter.
 Instead we have attempted to provide a simple but powerful interface that
 allows the use of the PIMD framework without the need for expert knowledge
 on the subject.
\end_layout

\begin_layout Standard
This manual will be structured as follows: 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{intro}
\end_layout

\end_inset

 we discuss some of the background information for the wrapper and define
 the terms to be used throughout the manual.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{commpro}
\end_layout

\end_inset

 we will discuss how the communication between the driver and wrapper codes
 are implemented.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{install}
\end_layout

\end_inset

 we will discuss how to install the code and test that it is working.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{run}
\end_layout

\end_inset

 we explain the procedure for running simulations, and the form of the input
 and output files.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{overview}
\end_layout

\end_inset

 we explain some of the features of the wrapper code.
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{dev}
\end_layout

\end_inset

 we discuss what is needed to modify the code.
 
\end_layout

\begin_layout Itemize
In chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

 
\backslash
ref{hierarchy}
\end_layout

\end_inset

 a full list of the major classes used in the code is given, along with
 the appropriate tag names and a brief description of all the fields that
 can be specified in the xml input file.
\end_layout

\begin_layout Section
Shell variables
\end_layout

\begin_layout Standard
In all that follows, we will make use of the following definitions of shell
 variables:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{tabular}{|l|p{10cm}|}
\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout

Name & Definition 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

src
\backslash
_dir & The directory in which the wrapper code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dir & The directory in which the NumPy code has been installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_dd
\backslash
_dir & The directory in which the NumPy tar file has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

driver
\backslash
_dir & The directory in which the driver code has been downloaded 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

np
\backslash
_vers & The version of NumPy installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

py
\backslash
_vers & The version of Python installed 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_dd
\backslash
_dir & The directory in which the Quantum Espresso code has been downloaded
 
\backslash

\backslash
 
\backslash
hline
\end_layout

\begin_layout Plain Layout

esp
\backslash
_vers & The version of Quantum Espresso installed 
\backslash

\backslash

\end_layout

\begin_layout Plain Layout


\backslash
hline
\end_layout

\begin_layout Plain Layout


\backslash
end{tabular}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Driver compatibility
\end_layout

\begin_layout Standard
There are currently patches available for Quantum Espresso version 4.3.2 and
 CP2K version 2.2.
 The patch for Quantum Espresso also works with version 5.0 with minor modificati
ons.
\end_layout

\begin_layout Standard
These codes do not come as part of the 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 package, and must be downloaded separately.
 See chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{install}
\end_layout

\end_inset

 for more details of how to do this.
 
\end_layout

\begin_layout Section
Online resources
\end_layout

\begin_layout Standard
For more information about 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 and to download the source code go to [appropriate wrappi website].
\end_layout

\begin_layout Standard
Parameters to run Path Integral with Generalized Langevin Equation thermostat
 (PI+GLE) calculations can be found on the website:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://gle4md.berlios.de/ 
\end_layout

\end_inset


\end_layout

\begin_layout Section
Credits
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 has been developed by Michele Ceriotti and Joshua More.
 
\end_layout

\begin_layout Section
Citing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Section
License
\end_layout

\begin_layout Chapter
Communication protocol
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{commpro}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Sockets
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is only a wrapper code, it must interface with a driver code in order to
 run any simulations.
 The overarching design principle of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 is that these two codes should be as independent as possible, and so the
 only communication between them is done through a socket.
 A socket is a data transfer device that is designed for internet communication,
 so supports both multiple client connections to the same server and two
 way communication.
 This makes sockets ideal for use in 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, where each calculation may require multiple driver codes.
 
\end_layout

\begin_layout Standard
Sockets are described by an IP address and a port number, and can either
 be an internet socket, capable of inter-computer communication, or a unix
 socket, which is optimized for local communication.
 The IP address is input by the user in the 
\begin_inset Quotes eld
\end_inset

address
\begin_inset Quotes erd
\end_inset

 tag, and can be specified in two ways.
 Firstly, every network has a unique numeric code of the form 123.45.678.901.
 Secondly, most networks are named, so the name of the network on which
 the wrapper code is running can be used as an alias for the IP address.
 A specific case of this is 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

, which is the generic name for the local network used by unix sockets.
\end_layout

\begin_layout Standard
The port number is specified in the code by the 
\begin_inset Quotes eld
\end_inset

port
\begin_inset Quotes erd
\end_inset

 tag.
 It is an integer between 1 and 65535 used to distinguish between all the
 different communication processes a particular computer is running.
 As many of the lower numbers are protected for use in important system
 processes or internet communication, it is generally advisable to only
 use numbers in the range 1025-65535 for simulations.
\end_layout

\begin_layout Standard
A unix or internet socket is specified by the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

socket
\begin_inset Quotes erd
\end_inset

 tag.
 While they are faster than internet sockets, unix sockets should only be
 used if a simple empirical potential is being run.
 If complicated empirical potentials or 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 potentials are used the force calculation becomes the bottleneck in the
 code, so the advantage of using unix sockets is lost.
 
\end_layout

\begin_layout Standard
Internet sockets have two main advantages that make them much more useful
 in general.
 Firstly, the driver code does not need to be run on the same computer as
 the wrapper code.
 In particular, if the driver codes are being run on a cluster this means
 that you do not need to waste computing resources running the wrapper,
 which is idle most of the time.
 Secondly, the port number is not used for unix sockets, so if more than
 one calculation is being run concurrently internet sockets must be used,
 so that the driver codes connect to the correct wrapper code.
\end_layout

\begin_layout Standard
There are a two other input parameters that may be used to specify how the
 server socket looks for driver codes to connect to.
 
\begin_inset Quotes eld
\end_inset

latency
\begin_inset Quotes erd
\end_inset

 specifies the length of time between each check to see if any new driver
 codes have connected, and 
\begin_inset Quotes eld
\end_inset

slots
\begin_inset Quotes erd
\end_inset

 specifies how many driver codes can queue between checks.
 Neither is likely to be important in getting the code to run, but may be
 used to optimize the connection time if required.
\end_layout

\begin_layout Section
Data transfer
\end_layout

\begin_layout Standard
Once at least one driver code has connected to the server socket, the force
 calculation can start.
 For this to happen the driver code needs the system configuration, and
 likewise the wrapper needs the force and potential data to be returned
 so that it can continue propagating the dynamics.
\end_layout

\begin_layout Standard
To make sure that the connection is good, a simple query-response data transfer
 protocol is used.
 Before any data is sent through the socket a header string of 12 characters
 is sent to verify which stage of the calculation the wrapper is at.
 Once the driver sends the appropriate response header string, the data
 is transferred.
 If no response is given, the wrapper will either wait and try again, or
 disconnect the driver code and reassign its job to another, depending on
 the severity of the problem.
 The wrapper assumes that 4-bit integers, 8-bit floats and 1-bit characters
 are used.
 A typical step is of the form:
\end_layout

\begin_layout Enumerate
A header string of 
\begin_inset Quotes eld
\end_inset


\series bold
STATUS
\series default

\begin_inset Quotes erd
\end_inset

 is sent by the server socket.
\end_layout

\begin_layout Enumerate
A header string is then returned, giving the status of the driver code.
 Recognized options are:
\end_layout

\begin_deeper
\begin_layout Description
\begin_inset Quotes eld
\end_inset

NEEDINIT
\begin_inset Quotes erd
\end_inset

: If the driver code needs any initialising data, it can be sent here.
 The server code will then send a header string 
\begin_inset Quotes eld
\end_inset

INIT
\begin_inset Quotes erd
\end_inset

, followed by an integer giving the number of bits in the initialization
 string, then the initialization string itself.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

READY
\begin_inset Quotes erd
\end_inset

: Sent if the driver code is ready to calculate the forces.
 The server socket will then send a string 
\begin_inset Quotes eld
\end_inset

POSDATA
\begin_inset Quotes erd
\end_inset

, then nine floats the cell vector matrix, then another nine floats for
 the inverse matrix, (which need to be transposed if the driver code is
 written in fortran).
 The server socket will then send one integer giving the number of atoms,
 then the position data as 3 floats for each atom giving the 3 cartesian
 components of the bead position.
\end_layout

\begin_layout Description
\begin_inset Quotes eld
\end_inset

HAVEDATA
\begin_inset Quotes erd
\end_inset

: This is sent if the driver has calculated the potential and forces.
 The server socket then sends a string 
\begin_inset Quotes eld
\end_inset

GETFORCE
\begin_inset Quotes erd
\end_inset

, and the client socket returns 
\begin_inset Quotes eld
\end_inset

FORCEREADY
\begin_inset Quotes erd
\end_inset

.
 The potential is then returned as a float, the number of atoms as an integer,
 then the force data as 3 floats per atom in the same way as the positions,
 and the virial as 9 floats in the same way as the cell vector matrix.
\end_layout

\end_deeper
\begin_layout Enumerate
The server socket waits until the force data for each replica of the system
 has been calculated and returned, upon which the job is finished and the
 molecular dynamics loop starts.
\end_layout

\begin_layout Section
Parallelization
\end_layout

\begin_layout Standard
As mentioned before, one of the primary advantages of using this type of
 data transfer is that it allows multiple driver codes to connect to one
 wrapper code, so that different replicas of the system can be assigned
 to different driver codes and their forces computed in parallel.
 In fact it is trivially parallel, in the sense that no communication between
 the driver codes is necessary.
\end_layout

\begin_layout Standard
In the case that there are as many driver codes as replicas of the system
 this is very simple, as each replica will be assigned its own driver code.
 In subsequent steps, the interface will attempt to assign a particular
 replica of the system to the driver code which calculated the forces for
 it the last step.
 This reduces the change in the particle positions between calculations
 for a particular driver code, so the next step is done more efficiently.
 In the case where there are fewer driver codes than beads, the socket interface
 will assign spare jobs to the first driver code that finishes running,
 after matching all possible jobs to the same driver code that calculated
 it last time step.
\end_layout

\begin_layout Standard
This flexibility is especially useful when the calculations are being run
 on a cluster, as in this case the driver codes will connect whenever they
 reach the front of the queue.
 More driver codes can connect at any time, and if there is a problem and
 any driver code dies it is simply disconnected from the server socket and
 any job it was running reassigned.
\end_layout

\begin_layout Standard
Finally, note that many driver codes can be parallelized themselves, using
 MPI or other similar protocols.
 This is fully compatible with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, as it does not matter how the driver does the calculation since only the
 forces, potential and virial are sent to the wrapper.
 Information on how to run MPI processes can usually be found on the website
 of the code provider if the driver can be parallelized in this way.
\end_layout

\begin_layout Section
ssh tunnelling
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{ssh_sockets}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
One problem that can often crop up when trying to run a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 calculation is that there is a firewall around the network, especially
 when the wrapper code is being run on a cluster.
 This will often result in error messages such as 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection timed out
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

Error connecting: Connection refused
\begin_inset Quotes erd
\end_inset

.
\end_layout

\begin_layout Standard
Let us suppose that the wrapper code is running on a host network wrapper.net,
 and that you are using port 12345.
 However, when you try to connect to this port from a computer, let us call
 this driver.net, then you get error messages like the ones above, due to
 a firewall on wrapper.net blocking port 12345.
\end_layout

\begin_layout Standard
However, assuming that you can create an ssh connection between the two
 computers, then you can use this to forward one of the ports on driver.net
 to connect to the necessary port on wrapper.net.
 This can be done with the following shell command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N wrapper.net -L 23451:wrapper.net:12345
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The flags -f and -N just put the ssh process in the background.
 Then comes the ssh server, which in this case is the computer on which
 the wrapper code is running.
 The -L flag sets up the ssh tunnel itself.
 The above code will forward the port 23451 on driver.net to the port 12345
 on wrapper.net, as required.
\end_layout

\begin_layout Standard
Once this is done, then any data sent to port on 23451 on driver.net will
 be forwarded through the ssh tunnel to port 12345 on wrapper.net.
 By connecting to port 23451 on driver.net (or localhost, an alias for the
 host the code is running on) with the driver the code should now run.
\end_layout

\begin_layout Standard
If the ssh connection fails, with an error message 
\begin_inset Quotes eld
\end_inset

ssh: connect to host wrapper.net port 22: Connection timed out
\begin_inset Quotes erd
\end_inset

, then the wrapper.net server has also been set up with a firewall around
 the standard ssh port, port 22.
 In this case you can change which port is used to one that is open using
 the -p flag, for example:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh -f -N wrapper.net -L 23451:wrapper.net:12345 -p 99
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Using a script to create a ssh connection
\end_layout

\begin_layout Standard
Now let us suppose that driver.net is a cluster, and we wish to submit the
 driver jobs to the queue.
 The above code as it is will not work, since ssh requires a password.
 However, you can set up ssh such that no password is needed.
 
\end_layout

\begin_layout Standard
Firstly, on driver.net, we need to set up an ssh key.
 This can be done using the command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> ssh-keygen -t rsa
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
It will then prompt you for a passphrase twice.
 Since we wish to have use this in a job script where we will not be able
 to enter a password, just hit enter twice.
 Note that this will mean that someone with temporary access to your account
 could feasibly take a copy of the ssh key and then be able to use it, so
 this should be used with caution.
\end_layout

\begin_layout Standard
This should now have created two files in the directory ~/.ssh, id_rsa and
 id_rsa.pub.
 These should be readable only by you, so use the following code to set
 up the correct file permissions:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> chmod 600 ~/.ssh/id_rsa ~/.ssh/id_rsa.pub
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Finally, copy the contents of the file id_rsa.pub and append them to the
 file authorized_keys in the directory ~/.ssh of wrapper.net.
 It should now be possible to ssh from driver.net to wrapper.net without using
 a password.
 We can now run the ssh command from a script, and so we can set up a ssh
 tunnel from a cluster node.
 Note that the cluster nodes will have a different IP address to the head
 node, so use 
\begin_inset Quotes eld
\end_inset

localhost
\begin_inset Quotes erd
\end_inset

 rather than 
\begin_inset Quotes eld
\end_inset

driver.net
\begin_inset Quotes erd
\end_inset

 in the input file of the driver code.
\end_layout

\begin_layout Chapter
Installing 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{install}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset Note Comment
status collapsed

\begin_layout Section
Background and nomenclature
\end_layout

\begin_layout Subsection
Molecular dynamics
\end_layout

\begin_layout Plain Layout
Molecular dynamics is a way of sampling the possible states of a system
 by propagating the positions and momenta of the particles in the system
 in discrete time steps according to a set of physical rules.
\end_layout

\begin_layout Plain Layout
By choosing the algorithm used to propagate the momenta correctly, the probabili
ty of the system being in a particular state will be the same as that of
 a physically realistic system, such as a system in contact with an external
 heat bath.
\end_layout

\begin_layout Plain Layout
We will call the complete set of possible states of the system an ensemble
 of states.
 The relevant ensembles we will be interested in are: 
\end_layout

\begin_layout Description
NVE ensemble This gives constant particle number, volume and energy, and
 corresponds to an isolated physical system.
 
\end_layout

\begin_layout Description
NVT ensemble This gives constant particle number, volume and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath.
 
\end_layout

\begin_layout Description
NPT ensemble This gives constant particle number, pressure and temperature,
 and corresponds to a physical system in thermal equilibrium with a heat
 bath and in equilibrium with a pressure bath.
 
\end_layout

\begin_layout Plain Layout
We will call the total number of possible states of a system for any given
 set of external variables the partition function of that system.
\end_layout

\begin_layout Plain Layout
In any practical simulation, the number of atoms has to be far fewer than
 the typical number present in the physical system of interest, for reasons
 of computational difficulty.
 This means that a high proportion of the particles in the simulation are
 likely to be on the edge of the simulation box.
 To prevent this having a large effect on the properties of the system,
 all of the driver codes implement what is known as periodic boundary conditions.
 This***********************************************88 
\end_layout

\begin_layout Subsection
Path integral generalization
\end_layout

\begin_layout Plain Layout
In the path integral generalization of classical mechanics, we use the following
 isomorphism between the quantum partition function of a system and a classical
 partition function in a higher phase space: 
\begin_inset Formula 
\begin{equation}
Q=\Tr(e^{-\hat{H}\beta})
\end{equation}

\end_inset

 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\left(\frac{2\pi m}{h^{2}\betan}\right)^{\frac{3}{2}}e^{-\hat{U}_{N}\betan}\dd\textbf{r}_{i}\right]\\
 & \hat{U}_{N}=\sum_{i=1}^{N}\left[\frac{m}{2\betan^{2}\hbar^{2}}(\textbf{r}_{i}-\textbf{r}_{i-1})^{2}+\hat{V}_{i}\right]\\
 & \betan=\frac{\beta}{N}\nonumber 
\end{align}

\end_inset

 Where 
\begin_inset Formula \ensuremath{\hat{H}}

\end_inset

 is the quantum Hamiltonian of the system, which is the operator corresponding
 to the observable energy, 
\begin_inset Formula \ensuremath{\hat{V}_{i}}

\end_inset

 is the potential of the replica of the system corresponding to the label
 
\begin_inset Formula \ensuremath{i}

\end_inset

, and 
\begin_inset Formula \ensuremath{\hat{U}_{N}}

\end_inset

 is a classical configurational Hamiltonian in the extended phase space,
 which only depends on particle coordinates.
\end_layout

\begin_layout Plain Layout
In practice we do not need to go to the limit of infinite 
\begin_inset Formula \ensuremath{N}

\end_inset

, as convergence can often be achieved with a small increase of phase space.
 Note that this classical Hamiltonian is equivalent to that of a 
\begin_inset Formula \ensuremath{N}

\end_inset

 replicas of the original system, with a harmonic potential between adjacent
 replicas.
 We will call this set of replicas of each atom a ring polymer, and the
 component particles of this ring polymer beads.
\end_layout

\begin_layout Plain Layout
The last thing we must do to make the connection with molecular dynamics
 is to add fictitious ring polymer momenta to allow us to sample the phase
 space more effectively.
 In our code we make the choice corresponding to assigning each bead the
 mass of the corresponding atom: 
\begin_inset Formula 
\begin{align}
 & Q=\lim_{N\to\infty}\prod_{i=1}^{N}\left[\int_{-\infty}^{\infty}\int_{-\infty}^{\infty}\left(\frac{1}{2\pi\hbar}\right)^{3}e^{-\hat{H}_{N}\betan}\dd\textbf{r}_{i}\dd\textbf{p}_{i}\right]\\
 & \hat{H}_{N}=\hat{U}_{N}+\sum_{i=1}^{N}\frac{\textbf{p}_{i}^{2}}{2m}
\end{align}

\end_inset


\end_layout

\begin_layout Plain Layout
This is then the partition function corresponding to the NVE ensemble for
 the quantum system, and as it has a purely classical Hamiltonian the algorithms
 used in classical dynamics and the generalizations used to sample other
 ensembles can be applied to this system in exactly the same way as for
 a classical system.
 
\end_layout

\begin_layout Subsection
Ab initio potentials
\end_layout

\begin_layout Plain Layout
An ab initio potential is one that does not require any experimentally derived
 parameters in its calculation.
 Under the strictest sense of the term many of the most popular DFT algorithms
 are not ab initio as they do use experimentally determined parameters,
 but as prior simulations are not necessary for the formulation of a DFT
 potential, we will define DFT as such for the purposes of this manual.
\end_layout

\begin_layout Plain Layout
DFT calculations are done by minimising an energy with respect to the one
 electron probability density, rather than the wavefunction as is common
 in most other ab initio potentials.
 The energy is given in terms of that of a fictitious system without electron
 interaction, for which the energy can be found exactly, plus an energy
 term due to electron correlation.
 This is the quantity of fundamental importance in DFT calculations, and
 while no analytic form for it exists several useful approximations to it
 have been created.
 We will call these correlation functionals.
\end_layout

\begin_layout Plain Layout
DFT calculations are done via an iterative procedure where a guess for the
 one electron wavefunctions are made so that the energy can be calculated,
 and a new set of one electron wavefunctions are then calculated by minimising
 this energy.
 The new wavefunctions are then put back into the first step and the procedure
 repeated until the initial and final density matrices are consistent.
\end_layout

\begin_layout Plain Layout
In what is known as Car-Parrinello molecular dynamics, the converged wavefunctio
ns of one step are then used as the starting point for the next step, drasticall
y accelerating the convergence.
\end_layout

\begin_layout Plain Layout
Another important consideration is the basis set used for the 
\end_layout

\end_inset


\end_layout

\begin_layout Section
System requirements
\end_layout

\begin_layout Standard
To install and run 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

, you will need to have:
\end_layout

\begin_layout Itemize
A modern C compiler
\end_layout

\begin_layout Itemize
Python version 2.4 or later
\end_layout

\begin_layout Itemize
The Python array library NumPy
\end_layout

\begin_layout Standard
Additionally, most driver codes will have their own software requirements.
 Many of them, including the test driver codes given in the 
\begin_inset Quotes eld
\end_inset

forces
\begin_inset Quotes erd
\end_inset

 directory, will need a modern Fortran compiler.
 Most will also need to be linked with some mathematical libraries, such
 as BLAS, FFTW and LAPACK.
 Installation instructions should be provided as part of the code distribution
 and on the appropriate website.
\end_layout

\begin_layout Section
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 download
\end_layout

\begin_layout Standard
A tar file can be downloaded from the website [appropriate wrap-pi website].
 To install this you need to input the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> tar xf [wrapper_tar_file.tar]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You can also download the git repository at [github repository name] using
 the commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $src_dir
\end_layout

\begin_layout Plain Layout

> git clone [github repository name]
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Section
NumPy download
\end_layout

\begin_layout Standard
NumPy is the standard Python mathematics library, and is used for most of
 the array minipulation and linear algebra in the wrapper code.
 How difficult it is to install NumPy depends on whether you have root access
 or not, and on the version of Python you are using.
\end_layout

\begin_layout Standard
In any case you must first obtain the NumPy code.
 The NumPy library can be downloaded as a tar file from 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://sourceforge.net/projects/numpy/files/NumPy/
\end_layout

\end_inset

 This must then be extracted using the following commands:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $np_dd_dir
\end_layout

\begin_layout Plain Layout

> tar czf $np_vers.tar.gz
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Before installing this code it first needs to be configured correctly.
 Note that this requires the distutils package that comes with the python-dev
 package.
 Assuming that the required software is installed, the NumPy package is
 built using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py build
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The next step is to install the package.
 By default the download is to the directory /usr/local.
 If you have root access, and so can write to /usr, then all that needs
 to be done to finish the install is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If you do not have root access, then the next step depends on which version
 of Python is beind used.
 With versions 2.6 or later there is a simple command to automatically download
 into the directory $HOME/local:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --user
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
With Python 2.4/2.5 the process is a little more involved.
 First you must explicitly install the package in the directory of choice
 with the following command:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python setup.py install --prefix=$np_dir
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Next, you must tell python where to find this library, by appending to the
 linux environment variable 
\series bold
PYTHONPATH
\series default
:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> export PYTHONPATH=$PYTHONPATH:$np_dir/lib64/$py_vers/site-packages
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
You may have to replace lib64 with lib depending on whether you are installing
 to a 64-bit or 32-bit architecture.
\end_layout

\begin_layout Section
Driver installation and compilation
\end_layout

\begin_layout Subsection
Quantum Espresso
\end_layout

\begin_layout Standard
You can download the source code for Quantum Espresso at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espresso.org/
\end_layout

\end_inset


\end_layout

\begin_layout Standard
For Quantum Espresso version 4.3.2, there is a patch file to allow it to be
 used as a driver code with 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 in the directory $src_dir/patches/pwscf.
 This can be applied to the Quantum Espresso source code using:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> cd $esp_dd_dir
\end_layout

\begin_layout Plain Layout

> tar zxvf $esp_vers.tar.gz
\end_layout

\begin_layout Plain Layout

> cd $esp_vers
\end_layout

\begin_layout Plain Layout

> patch -p1 < $src_dir/patches/pwscf/pw-driver.patch
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
After this, continue the download as per the instructions at:
\end_layout

\begin_layout Standard
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

www.quantum-espress.org/
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
CP2K 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout

%I still don't even have this code, so can't write this bit...
\end_layout

\end_inset


\end_layout

\begin_layout Section
Testing
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{tests}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Several test cases are distributed with the code to ensure that your distributio
n is working correctly.
 There are also simple tests to see if the driver codes are working correctly.
\end_layout

\begin_layout Standard
All the input files are contained in the directory test, which is subdivided
 into the following directories:
\end_layout

\begin_layout Description
lj: This gives a simple classical Lennard-Jones simulation of Ne.
 The state points are given by (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.35, 1.62), (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.75, 1.069) and (N, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
rho
\backslash
)
\end_layout

\end_inset

, T) = (864, 0.88, 1.095) in reduced Lennard-Jones units, so that the results
 can be compared to those in the paper 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{lverlet67pr}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
ph2: This simulates para-hydrogen using the isotropic Silvera-Goldman pair
 potential.
 There are three directories, 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

, 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

RPMD
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

 have tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mill-mano05jcp}
\end_layout

\end_inset

, and 
\begin_inset Quotes eld
\end_inset

Tuckerman
\begin_inset Quotes erd
\end_inset

 has tests which can be compared to the results of 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
cite{mart+99jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Description
pwscf: This has two simple examples to test to see if the Quantum-Espresso
 driver is functioning correctly.
 There is one simple 4-atom lithium test, and a test using a single water
 molecule.
\end_layout

\begin_layout Chapter
Running 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{run}
\end_layout

\end_inset


\end_layout

\begin_layout Section
How to run the wrapper
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 simulations are run using the top level script found in the src directory.
 If the xml-formatted input file is called input_file.xml, then the command
 to run a 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 simulation is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> python $src_dir/i-pi input_file.xml
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code will then have to wait until at least one driver code has connected
 before running any dynamics.
 At this point the code is essentially idle, and the only process that it
 runs is to periodically poll the socket for connections.
\end_layout

\begin_layout Section
How to run the driver
\end_layout

\begin_layout Subsection
CP2K
\end_layout

\begin_layout Standard
To run CP2K with the wrapper, an additional file named 
\begin_inset Quotes eld
\end_inset

serverfile
\begin_inset Quotes erd
\end_inset

 must be kept in the same directory that CP2K is being run from.
 It should contain a string a single line long, of the format 
\begin_inset Quotes eld
\end_inset

mode:host:port_number
\begin_inset Quotes erd
\end_inset

.
 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 should either be 
\begin_inset Quotes eld
\end_inset

INET
\begin_inset Quotes erd
\end_inset

 or 
\begin_inset Quotes eld
\end_inset

UNIX
\begin_inset Quotes erd
\end_inset

, representing an internet or unix socket respectively.
 The rest of the input file is the same as for a standard CP2K calculation.
\end_layout

\begin_layout Subsection
Quantum-Espresso
\end_layout

\begin_layout Standard
Suppose we want to run Quantum-Espresso as the driver code, and we have
 compiled it as given above, and have an input file which will give the
 correct forces and potential for the system of interest.
 If we want to connect to a socket on the host address host_address and
 on the port number port, then we would add the following lines to the input
 file:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
If we wanted to run on a UNIX port instead of an INET port, we would instead
 write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

&CONTROL
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

   calculation=`driver'
\end_layout

\begin_layout Plain Layout

   srvaddress=`UNIX:host_address:port'
\end_layout

\begin_layout Plain Layout

   ...
\end_layout

\begin_layout Plain Layout

/
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The rest of the input file should be the same as for a standard Quantum
 Espresso calculation.
\end_layout

\begin_layout Section
Running simulations
\end_layout

\begin_layout Subsection
Running a simulation
\end_layout

\begin_layout Standard
There are two parts to any 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 simulation.
 First the wrapper is run, which starts the dynamics loop until the forces
 are required.
 Once the server socket has been opened, it then waits for connections from
 driver codes.
 
\end_layout

\begin_layout Standard
For a small simulation, with a simple classical potential, it may be preferable
 to run both halves of the simulation on the same computer, especially as
 this allows us to use the faster unix domain sockets.
 If we assume that the driver code is run by the command 
\begin_inset Quotes eld
\end_inset

driver_comm
\begin_inset Quotes erd
\end_inset

, the following code will run the wrapper, redirect the wrapper's standard
 output to a file 
\begin_inset Quotes eld
\end_inset

log
\begin_inset Quotes erd
\end_inset

, run four driver codes and then background the result:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> bash -c "python $src_dir/main.py input_file.xml &> log &"
\end_layout

\begin_layout Plain Layout

> for a in `seq 1 4`
\end_layout

\begin_layout Plain Layout

>    do bash -c "driver_comm &> 
\backslash
dev
\backslash
null &"
\end_layout

\begin_layout Plain Layout

> done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
However, for most simulations, especially those running with expensive 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{ab initio}
\end_layout

\end_inset

 forces and potentials, we will want to run the driver codes on a computational
 cluster.
 Here we run the wrapper code elsewhere, and simply use an internet socket
 for the communication.
 For information on how to do this, see section 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ref{ssh_sockets}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
To run the driver on a cluster computer, two major changes must be implemented.
 Firstly, the input file for the driver code should be changed so that it
 connects to host network the wrapper is running on.
 Secondly, to run the driver on a cluster a queueing program such as qsub
 will need to be used.
 These usually require a script file which can be executed on the cluster
 computers to be submitted to a queue.
 If we have a script file 
\begin_inset Quotes eld
\end_inset

driver.sh
\begin_inset Quotes erd
\end_inset

, which is set up to run 
\begin_inset Quotes eld
\end_inset

driver_comm
\begin_inset Quotes erd
\end_inset

, then the appropriate command would be:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

for a in `seq 1 4`
\end_layout

\begin_layout Plain Layout

   do qsub driver.sh
\end_layout

\begin_layout Plain Layout

done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Depending on which cluster is used, additional commands to set parameters
 such as the walltime, number of nodes and number of cores can be used.
 Check the qsub man page for the cluster you are running the code on for
 more details.
\end_layout

\begin_layout Subsection
Running multiple simulations
\end_layout

\begin_layout Standard
To set up multiple concurrent 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 simulations each host socket has to be distinguishable, so that the driver
 codes appropriate to each simulation connect only to the correct wrapper
 code.
 This can be done by adjusting the port number of each simulation, which
 then acts as a unique identifier for each host socket.
 This is very easy to write a shell script to do, if for example we assume
 the simulations will be run in directories called sim_1, sim_2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

, then we can write:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

> i=0
\end_layout

\begin_layout Plain Layout

> for a in sim_*
\end_layout

\begin_layout Plain Layout

> do cd $a
\end_layout

\begin_layout Plain Layout

>   ((i++))
\end_layout

\begin_layout Plain Layout

>   port=((10000+$i))
\end_layout

\begin_layout Plain Layout

>   sed s/XXX/$port/g input.template > $a/input_file.xml
\end_layout

\begin_layout Plain Layout

>   cd ..
\end_layout

\begin_layout Plain Layout

> done
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This will replace a string 
\begin_inset Quotes eld
\end_inset

XXX
\begin_inset Quotes erd
\end_inset

 in a template file with a port number unique to each simulation.
 If the same thing is done for the driver input files then this gives us
 an easy way to specify which driver codes connect to which wrapper codes.
 However, note that this will only work if you are using inet sockets, as
 the port number is silently ignored for unix sockets.
\end_layout

\begin_layout Section
Input files
\end_layout

\begin_layout Subsection
xml file
\end_layout

\begin_layout Standard
This is the main input file from which the simulation parameters are initialized.
 An xml file consists of a set of hierarchially nested tags.
 There are three parts to an xml tag.
 Each tag is identified by a tag name, which specifies the class or variable
 that is being initialized.
 Between the opening and closing tags there may be some data, which may
 or may not contain other tags.
 This will specify the contents of a class, or the value of a variable.
 Finally, any tag can have attributes, which in the code are used for variables
 which specify the state or type of class that will be created.
 A xml tag has the following syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag_name attribute_name=`attribute_data'>tag_data</tag_name>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The syntax for the different types of tag data is given below:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="2">
<features tabularvalignment="middle">
<column alignment="center" valignment="top" width="0">
<column alignment="center" valignment="top" width="0">
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Data type
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Syntax
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Boolean
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>True</tag> or <tag>False</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Float
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>11.111</tag> or <tag>1.1111e+1</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Integer
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>12345</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Dictionary
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>{name1: data1, name2: data2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 }</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
String
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag>string_data</tag>
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Tuple
\end_layout

\end_inset
</cell>
<cell alignment="center" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
<tag> (int1, int2, 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

 )</tag>
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
Also, for arrays, which have the `shape' attribute, we have the syntax
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<tag shape=`array_shape'>[entry1, entry2, ...
 ]</tag>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
where each entry has the same data type, which will be either float, int,
 boolean or string, and `array_shape' is a tuple that gives the shape of
 the generated array.
 If the shape is not specified, then a 1D array will be assumed.
\end_layout

\begin_layout Standard
The code uses this hierarchial structure to help read the data; if a particular
 object is held within a parent object in the code, then the tag for that
 object will be within the appropriate parent tags.
 This is used to make the structure of the simulation clear.
 For example the system that is being studied is partly defined by the thermodyn
amic ensemble that should be sampled, which in turn may be partly defined
 by the temperature, and so on.
 In the input file this would be specified by having a 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

 tag, containing an 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag, which itself contains a 
\begin_inset Quotes eld
\end_inset

temperature
\begin_inset Quotes erd
\end_inset

 tag, which will contain a float value corresponding to the temperature.
 In the code itself this will correspond to a simulation object, which will
 contain an ensemble object, which will contain a temperature variable.
 In this manner, the simulation class structure can be constructed iteratively.
\end_layout

\begin_layout Standard
To help detect any user error the acceptable tag names, type of data and
 possible default values are all specified in the code, in a specialized
 input class for each class of object.
 More information on how the xml file is read can be found in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{dev}
\end_layout

\end_inset

, and a full list of all the available tags and a brief description of their
 function is given in chapter
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{hierarchy}
\end_layout

\end_inset

.
\end_layout

\begin_layout Subsection
Configuration file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{configfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The initial configuration data can be initialized both through the xml file,
 and through a separate configuration file.
 The configuration file is specified within the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag name in the xml file, with the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute as the file format.
 The currently accepted file formats are:
\end_layout

\begin_layout Itemize
pdb
\end_layout

\begin_layout Itemize
xyz
\end_layout

\begin_layout Standard
These files can be used to specify the initial atom positions, labels and
 masses (based on atomic symbol) and, depending on the format, the cell
 parameters as well.
 It can either be held within a 
\begin_inset Quotes eld
\end_inset

file
\begin_inset Quotes erd
\end_inset

 tag, in which case all applicable information will be initialized, or 
\begin_inset Quotes eld
\end_inset

positions
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

masses
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

labels
\begin_inset Quotes erd
\end_inset

/
\begin_inset Quotes erd
\end_inset

cell
\begin_inset Quotes erd
\end_inset

, in which case only the specified property will be initialized.
\end_layout

\begin_layout Subsection
Units
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{units}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
wrappi
\end_layout

\end_inset

 uses the following set of internal units:
\end_layout

\begin_layout Standard
\begin_inset Tabular
<lyxtabular version="3" rows="7" columns="3">
<features tabularvalignment="middle">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<column alignment="left" valignment="top" width="0">
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Unit
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Name
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
S.I.
 Value
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Length
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Bohr radius
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
5.2917721e-11 m
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Time
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.4188843e-17 s
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Electron mass
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
9.1093819e-31 kg
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Temperature
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
kelvin
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
1 K
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Energy
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Hartree
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
4.3597438e-18 J
\end_layout

\end_inset
</cell>
</row>
<row>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
Pressure
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
N.A.
\end_layout

\end_inset
</cell>
<cell alignment="left" valignment="top" topline="true" bottomline="true" leftline="true" rightline="true" usebox="none">
\begin_inset Text

\begin_layout Plain Layout
2.9421912e13 Pa
\end_layout

\end_inset
</cell>
</row>
</lyxtabular>

\end_inset


\end_layout

\begin_layout Standard
However, these units can be overriden in the input file by using the 
\begin_inset Quotes eld
\end_inset

units
\begin_inset Quotes erd
\end_inset

 attribute.
 For example, if you wanted to specify the cell parameters in units of angstrom
 rather than bohr radii then in the input file you would specify:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<cell units=`angstrom'> ...
 </cell>
\backslash
end{verbatim}
\end_layout

\end_inset

 
\end_layout

\begin_layout Section
Output files
\end_layout

\begin_layout Standard
All output files are specified within the tag name 
\begin_inset Quotes eld
\end_inset

output
\begin_inset Quotes erd
\end_inset

 in the xml file.
 Each tag held here specifies a particular output file, with data specifying
 the file name, the data to be output and the number of steps between each
 write, plus other relevant data.
\end_layout

\begin_layout Subsection
Property file
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{propertyfile}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
This is the output file for for all the system and simulation level properties,
 such as the total energy and the overall time taken.
 The properties that are output are determined by the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag in the xml input file.
 The format of this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<properties stride=`' filename=`' flush=`' shape=`'>
\end_layout

\begin_layout Plain Layout

   [ prop1name{units}(arg1;...), prop2name{...}(...), ...
  ]
\end_layout

\begin_layout Plain Layout

</properties>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The attributes have the following meanings:
\end_layout

\begin_layout Description
stride The number of steps between each output to file
\end_layout

\begin_layout Description
filename The name of the output file
\end_layout

\begin_layout Description
flush The number of steps between flushing the buffer
\end_layout

\begin_layout Standard
This tag data is an array of strings, each of which containing three different
 parts:
\end_layout

\begin_layout Itemize
First, the property name, which describes which type of property is to be
 output.
 This is a mandatory part of the string.
\end_layout

\begin_layout Itemize
Secondly, you can specify the units that the property will be output in.
 This is specified between curly brackets, as shown above.
 If this is not specified, then the property will be output in atomic units.
\end_layout

\begin_layout Itemize
Thirdly, the arguments to be passed to the function can be specified between
 standard brackets, with each argument separated by a semi-colon.
 These may or may not be mandatory depending on the property.
 The arguments can be specified by either of two different syntaxes, (name1=arg1
;
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

) or (arg1;
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
ldots
\end_layout

\end_inset

).
 The first explicitly assigns the argument with the name 
\begin_inset Quotes eld
\end_inset

name1
\begin_inset Quotes erd
\end_inset

 the value 
\begin_inset Quotes eld
\end_inset

arg1
\begin_inset Quotes erd
\end_inset

, whereas the second relies on the arguments being specified in the correct
 order.
 The two syntaxes may be mixed, but positional arguments must be specified
 first otherwise undefined behaviour will result.
 If this is not specified, then the defaults as defined in the properties.py
 module will be used.
\end_layout

\begin_layout Standard
The different available property names are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{property_list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The format of the file is given by a comment line per property giving the
 name of the properties and which columns of the input file will be used
 to print it, followed by their values in the appropriate units at regular
 intervals given by the 
\begin_inset Quotes eld
\end_inset

stride
\begin_inset Quotes erd
\end_inset

 list of the input file.
 The file is fixed formatted, with two blank characters at the start of
 each row, then the data in the same order as the header row.
 Each column is 16 characters wide and every float is written in exponential
 format with 8 digits after the decimal point.
\end_layout

\begin_layout Subsection
Trajectory files
\end_layout

\begin_layout Standard
These are the output file for atomic or bead level properties, such as the
 bead positions.
 Each trajectory that should be output is specified by the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 tag in the input file.
 These tags have the format:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<trajectory stride=`' filename=`' format=`' cell_units=`'
 flush=`' bead=`'>
\end_layout

\begin_layout Plain Layout

   traj_name{units}(arg1;...)
\end_layout

\begin_layout Plain Layout

</trajectory>
\backslash
end{verbatim}
\end_layout

\end_inset

This is very similar to the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tag, but it has the additional tags 
\begin_inset Quotes eld
\end_inset

format
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

cell_units
\begin_inset Quotes erd
\end_inset

, and only one trajectory can be specified.
 `format' specifies the format of the output file, and `cell_units' specifies
 the units in which the cell dimensions are output.
 Depending on the chosen trajectory to output, it will either print a file
 per bead or per atom.
 If the trajectory is output per bead then the output files will be 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

 with the bead index appended, so as to distinguish between the trajectories
 of each bead.
 In this case it is also possible to only output one trajectory by specifying
 the 
\begin_inset Quotes eld
\end_inset

bead
\begin_inset Quotes erd
\end_inset

 attribute.
 The possible choices of output properties are:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{trajectory_list}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The allowable file formats for the trajectory output files are the same
 as for the configuration input files, given in
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{configfile}
\end_layout

\end_inset

.
\end_layout

\begin_layout Section
Restart mechanism
\end_layout

\begin_layout Subsection
Checkpoint files
\end_layout

\begin_layout Standard
As well as the above output files, the state of the system at a particular
 time step can also be saved to file.
 These checkpoint files can be used as valid input files, with all the informati
on required to restore the state of the system to the point at which the
 file was created.
 The syntax for this tag is:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'>
\end_layout

\begin_layout Plain Layout

   step
\end_layout

\begin_layout Plain Layout

</checkpoint>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Again, this is similar to the 
\begin_inset Quotes eld
\end_inset

trajectory
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 tags, but instead of having a value which specifies what to output, the
 value simply gives a number to identify which checkpoint is which.
 There is also one additional attribute 
\begin_inset Quotes eld
\end_inset

overwrite
\begin_inset Quotes erd
\end_inset

, which specifies whether each new checkpoint file overwrites the old one,
 or whether all checkpoint files are kept.
 If they are kept, they will be written not to the file 
\begin_inset Quotes eld
\end_inset

filename
\begin_inset Quotes erd
\end_inset

, but instead an index will be appended to it to distinguish between different
 files.
\end_layout

\begin_layout Standard
If the `step' parameter is not specified, the following syntax can also
 be used:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}<checkpoint stride=`' filename=`' overwrite=`'/>
\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Subsection
Restart file
\end_layout

\begin_layout Standard
As well as checkpoint files during a simulation run, wrappi also creates
 a file to restart from automatically at the end of the simulation, with
 file name 
\begin_inset Quotes eld
\end_inset

RESTART
\begin_inset Quotes erd
\end_inset

.
 In the same way as the checkpoint files generated above, it contains the
 state of the system is created by the wrapper, but it doesn't need to be
 asked for by the user in the input file.
 Its purpose is that if the user decides that insufficient steps where used
 in an already completed simulation, then this file can be used to continue
 from where it ended.
\end_layout

\begin_layout Subsection
Soft exit
\end_layout

\begin_layout Standard
To stop the program in such a way that it makes sure to save the data generated
 in a restart file, simply create a file 
\begin_inset Quotes eld
\end_inset

EXIT
\begin_inset Quotes erd
\end_inset

 in the directory in which the code is running.
 The thread handler will automatically detect this and safely shut down
 the program, outputting the restart file as detailed above.
 
\end_layout

\begin_layout Standard
An important point to note is that since each time step is split into several
 parts, it is only at the beginning of each step that all the variables
 are consistent with each other in such a way that the simulation can be
 restarted from them without changing the dynamics.
 Thus if a soft exit call is made during a step, then the restart file that
 is created must correspond to the state of the system at the start of the
 step.
 To this end, the state of the system is saved at the start of every step.
\end_layout

\begin_layout Subsection
Initialization from RESTART
\end_layout

\begin_layout Standard
As well as being a valid input file, the RESTART file can be used as a starting
 point for simulations in two other ways.
 Firstly, in the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag, there is a 
\begin_inset Quotes eld
\end_inset

chk
\begin_inset Quotes erd
\end_inset

 option for the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of all the initializable properties.
 This will use the restart file as a basis for initializing the specified
 bits of data.
\end_layout

\begin_layout Standard
Secondly, there is a particular ensemble type, 
\begin_inset Quotes eld
\end_inset

replay_file
\begin_inset Quotes erd
\end_inset

, which takes a configuration file with multiple frames or a checkpoint
 file with one frame and reruns it without doing dynamics, by simply setting
 the configuration to match that given by the input file at each frame.
 
\end_layout

\begin_layout Chapter
Feature overview
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{overview}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Ring polymer contraction
\end_layout

\begin_layout Standard
Often, we will want to take a description of the system in terms of a certain
 number of beads and instead represent it with a different number of beads.
 In the wrapper this is done using a ring polymer contraction scheme
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{mark-mano08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
This works by matching the normal mode amplitudes of the old ring polymer
 with those of the new ring polymer.
 The normal modes are matched in ascending frequency order, until either
 all the ring polymer normal modes of the new ring polymer have been assigned
 a frequency, or all the original ring polymer normal modes have been used.
 Any remaining normal mode amplitudes are set to zero.
\end_layout

\begin_layout Standard
This is used in two different cases:
\end_layout

\begin_layout Itemize
Initializing a simulation from a previous one with a different number of
 beads.
\end_layout

\begin_layout Itemize
Calculating long range interactions with a reduced number of beads.
\end_layout

\begin_layout Standard
The first of these points is fairly self-explanatory.
 To specify the number of beads that the system should be initialized to,
 the 
\begin_inset Quotes eld
\end_inset

nbeads
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

initialize
\begin_inset Quotes erd
\end_inset

 tag simply needs to be set to the appropriate value in the input file.
 This will take whatever configuration is specified in the initilialization
 and use the above transformation to give a new configuration with the correct
 number of beads.
 
\end_layout

\begin_layout Standard
The second of these uses is more complicated.
 To understand this, consider an empirical potential model that can be split
 into a short-ranged potential and a long-ranged potential, where the long-range
d part of the potential is slowly varying in space.
 This means that the long-ranged part of the potential will require fewer
 beads to converge the calculated potential energy than the short-ranged
 part, as it only varies slightly over the ring polymer length scale.
 
\end_layout

\begin_layout Standard
Also, let us suppose that the calculation of the long-range terms is the
 computational bottleneck, as they are more numerous than the short-range
 terms.
 In this case calculating the long-range part of the potential on a contracted
 ring polymer will have a large effect on the simulation time, even if the
 short-range part is calculated on the full ring polymer.
 Therefore this technique allows us to speed up the simulation without sacrifici
ng accuracy.
\end_layout

\begin_layout Standard
Once the force, potential and virial have been calculated using the reduced
 ring polymer, the resulting force and virial vectors are transformed back
 to the appropriate size for the full ring polymer phase space, before being
 used to propagate the trajectory.
\end_layout

\begin_layout Standard
For a given 
\begin_inset Quotes eld
\end_inset

socket
\begin_inset Quotes erd
\end_inset

 tag, this can be specified in the input file by setting the 
\begin_inset Quotes eld
\end_inset

nbeads
\begin_inset Quotes erd
\end_inset

 attribute.
 This value will dictate how many beads will be used to calculate that part
 of the force, and if it is not equal to the number of beads in the system
 then ring polymer contraction will be used.
\end_layout

\begin_layout Section
Constant temperature simulations
\end_layout

\begin_layout Standard
There are a variety of different stochastic thermostats implemented within
 the wrapper.
 All the algorithms that are used in the wrapper are based on either the
 Langevin equation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{plangevin1908cras}
\end_layout

\end_inset


\begin_inset ERT
status open

\begin_layout Plain Layout

%perhaps a more relevant citation required here as well?
\end_layout

\end_inset

 or stochastic velocity rescaling
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{buss-parr08cpc}
\end_layout

\end_inset

.
 
\end_layout

\begin_layout Standard
The Langevin thermostat is a local thermostat, so couples to each degree
 of freedom, whereas the stochastic velocity rescaling is a global algorithm,
 so is only coupled to the total kinetic energy.
 Global thermostats are less disruptive to the dynamics, so are much better
 for calculation of properties that require reorganisation of the structure,
 such as dielectric constants
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+10jcp}
\end_layout

\end_inset

.
 However, they tend be less efficient for local properties such as the total
 energy.
\end_layout

\begin_layout Standard
The path integral Langevin equation (PILE) thermostat
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+10jcp}
\end_layout

\end_inset

 adapts these algorithms for PIMD simulations, and may be either local or
 global.
 It uses 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
emph{a priori}
\end_layout

\end_inset

 estimates for the friction coefficients of the thermostats coupled to the
 internal ring polymer normal modes, so this is much more effective for
 path integral calculations than standard stochastic thermostats.
\end_layout

\begin_layout Standard
Constant temperature simulations can be run by setting the 
\begin_inset Quotes eld
\end_inset

type
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag to 
\begin_inset Quotes eld
\end_inset

nvt
\begin_inset Quotes erd
\end_inset

, and the 
\begin_inset Quotes eld
\end_inset

thermostat
\begin_inset Quotes erd
\end_inset

 tag specifies how the thermostat is defined.
\end_layout

\begin_layout Subsection
Generalized Langevin equation thermostats
\end_layout

\begin_layout Standard
The Langevin equation can be generalized to include non-Markovian effects,
 so that the stochastic step of the algorithm requires information from
 previous timesteps.
 This is however very difficult to implement in practice.
\end_layout

\begin_layout Standard
However, this can be shown to be mathematically equivalent to a Markovian
 algorithm in an extended momentum phase space
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+09jctc}
\end_layout

\end_inset

.
 This is much simpler to implement, but still maintains the increased power
 and flexibility of the non-Markovian formulation.
 In particular, this has two main advantages over standard Langevin equation
 dynamics.
\end_layout

\begin_layout Standard
Firstly, there are a large number of adjustable parameters, so the thermostat
 can be fine-tuned to efficiently sample all the vibrational frequencies
 present in the system rather than just a small range of frequencies.
\end_layout

\begin_layout Standard
Secondly, the algorithm does not need to obey the fluctuation-dissipation
 theorem, so the ensemble that is sampled can be adjusted manually.
 For example, using information from the harmonic limit this thermostat
 can attempt to enforce the appropriate quantum ensemble during a low bead
 PIMD simulation
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{ceri+11jcp}
\end_layout

\end_inset

, increasing the rate of convergence with respect to the number of beads
 used.
\end_layout

\begin_layout Section
Constant pressure simulations
\end_layout

\begin_layout Standard
Constant pressure simulations are also possible within the wrapper.
 There is one barostat currently implemented
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{buss+09jcp}
\end_layout

\end_inset

, which is designed to be used in combination with stochastic thermostating,
 so is only suitable for simulations where both the pressure and temperature
 are held constant.
 Note that these algorithms allow the system box size to fluctuate, which
 can cause problems for some driver codes if variable cell dynamics have
 not been implemented.
\end_layout

\begin_layout Standard
Constant pressure simulations can be run by setting the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

ensemble
\begin_inset Quotes erd
\end_inset

 tag to 
\begin_inset Quotes eld
\end_inset

npt
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

barostat
\begin_inset Quotes erd
\end_inset

 tag specifies how the barostat is defined.
\end_layout

\begin_layout Section
Dynamical property calculations
\end_layout

\begin_layout Standard
As well as calculating the static properties shown in section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{propertyfile}
\end_layout

\end_inset

, the wrapper code is capable of calculating approximations to dynamical
 properties such as correlation functions.
 Currently, two different techniques have been implemented for this, ring
 polymer molecular dynamics (RPMD)
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{crai-mano04jcp}
\end_layout

\end_inset

 and partially adiabatic centroid molecular dynamics (PA-CMD)
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
cite{habe+08jcp}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
RPMD uses the trajectories generated during a PIMD run to calculate correlation
 functions, so is straightforward to use.
 The largest difference between RPMD and PIMD is that local thermostats
 usually disrupt the particle motion too much to be used in the calculation
 of dynamical properties, so often a constant energy ensemble must be sampled
 instead.
 An example of one way to run an RPMD simulation is given in one of the
 test directories, as explained in section
\begin_inset ERT
status open

\begin_layout Plain Layout

~
\backslash
ref{tests}
\end_layout

\end_inset

.
\end_layout

\begin_layout Standard
PA-CMD uses different dynamics to calculate correlation functions.
 In particular, the ring polymer bead masses are scaled, shifting the ring
 polymer normal mode frequencies.
 This is particularly useful where non-zero frequency components of the
 correlation functions are important, as the ring polymer normal mode frequencie
s can contaminate the spectrum.
 PA-CMD avoids this by shifting these frequencies out of the frequency range
 of interest.
\end_layout

\begin_layout Standard
PA-CMD dynamics can be used by adjusting the 
\begin_inset Quotes eld
\end_inset

mode
\begin_inset Quotes erd
\end_inset

 attribute of the 
\begin_inset Quotes eld
\end_inset

normal_modes
\begin_inset Quotes erd
\end_inset

 tag.
 
\begin_inset Quotes eld
\end_inset

normal modes
\begin_inset Quotes erd
\end_inset

 takes an array argument, which can be used to specify how the ring polymer
 normal mode frequencies are defined.
\end_layout

\begin_layout Chapter
Developer's tips
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{dev}
\end_layout

\end_inset


\end_layout

\begin_layout Section
Directory structure
\end_layout

\begin_layout Standard
The code is separated into the following directory structure: 
\end_layout

\begin_layout Description
forces: Contains a few short fortran driver files for running simple tests.
 
\end_layout

\begin_layout Description
doc: Contains the documentation, including this manual.
 
\end_layout

\begin_layout Description
src: Contains the source code for the wrapper.
 This is further subdivided into: 
\end_layout

\begin_deeper
\begin_layout Description
engine: Holds the modules containing the internally used objects and algorithms
 
\end_layout

\begin_layout Description
driver: Holds the modules containing the objects that deal with the driver
 communication and data transfer.
 
\end_layout

\begin_layout Description
utils: Holds the modules containing the utility functions used in the other
 modules.
 
\end_layout

\begin_layout Description
inputs: Holds the modules containing the classes that read the input files.
\end_layout

\end_deeper
\begin_layout Description
patches: Contains the patch files that must be applied to allow the driver
 codes to interact with the wrapper.
 
\end_layout

\begin_layout Description
test: Contains examples that can be used to make sure the build has been
 successful, show the correct form of the input files, and show some of
 the capabilities of the wrapper.
 
\end_layout

\begin_layout Section
Dependency detection and automatic property caching
\end_layout

\begin_layout Subsection
Rationale
\end_layout

\begin_layout Standard
One of the utility classes that is defined in the code, from which most
 of the classes in the code inherit, is the dobject class.
 Similarly, many of the variables contained in these classes are depend
 objects.
\end_layout

\begin_layout Standard
The depend object class has been designed so that every time it is accessed
 it checks all of the other depend objects on which it is dependent to see
 if they have changed, and if so recalculates its value.
 The dobject class overrides the mechanism by which you can access the members
 of an instance of it, so that they are accessed via the dependency detection
 functions.
\end_layout

\begin_layout Standard
These classes have been defined so that, instead of cluttering up the code
 with functions to recalculate the various parameters of the simulation,
 we simply have to define the function by which to recalculate them and
 the other objects which they depend upon when they are created, and then
 they will automatically be updated when required.
\end_layout

\begin_layout Standard
As an example, take the total kinetic energy for one replica of the system.
 This is a property of the total momentum vector and the mass vector of
 the different atoms.
 Therefore, we would create a 
\begin_inset Quotes eld
\end_inset

kin
\begin_inset Quotes erd
\end_inset

 object in the atoms class that has dependencies 
\begin_inset Quotes eld
\end_inset

mass
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

momentum
\begin_inset Quotes erd
\end_inset

, and a recalculation function that calculated 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
(
\backslash
frac{
\backslash
bf{p}^2}{2
\backslash
bf{m}}
\backslash
)
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Having done this, any time we access atoms.kin, the code will check to see
 if either the mass vector or momentum vector has changed.
 If it has will recalculate the kinetic energy before returning it, otherwise
 it will simply return the cached value.
\end_layout

\begin_layout Subsection
Synchronized objects
\end_layout

\begin_layout Standard
As well as checking for dependencies, the same infrastructure can also be
 used to synchronize two objects which are different representations of
 the same data.
 A good example of this is the bead coordinates in the cartesian and normal
 mode representations.
 Both of these represent the same data, but have different numerical values.
\end_layout

\begin_layout Standard
In this case we can use a synchronize object, which holds a dictionary of
 functions to transform one representation to another.
 In the case of the normal mode and cartesian representations of position,
 the transformation can be done either by multiplying the position vector
 by a transformation matrix, or via a Fourier transform.
\end_layout

\begin_layout Standard
Using this class, whenever we make a change to one of the representations,
 the others are automatically recalculated by reapplying the transformation
 function the next time they are accessed.
\end_layout

\begin_layout Section
Properties
\end_layout

\begin_layout Standard
While many of the simple properties of interest can be output directly to
 the properties output file, and many others can be obtained by post-processing
 the available data, it may be that some property you wish to calculate
 is not explicitly available for output.
\end_layout

\begin_layout Standard
In this case, you may wish to modify the code so that this property can
 be output.
 All the code to do this is found in the 
\begin_inset Quotes eld
\end_inset

properties.py
\begin_inset Quotes erd
\end_inset

 module in the 
\begin_inset Quotes eld
\end_inset

engine
\begin_inset Quotes erd
\end_inset

 directory.
 To add a new property to the existing list, you must first define a function
 that calculates this property.
\end_layout

\begin_layout Standard
In standard Python notation, we must define a new function inside the 
\begin_inset Quotes eld
\end_inset

Properties
\begin_inset Quotes erd
\end_inset

 class.
 This is written by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

def new_func(self):
\end_layout

\begin_layout Plain Layout

   ...code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We can now use this function to calculate the property of interest.
 If the name of this property is 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

, we can add this to the dictionary of named properties by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict["new_prop"] = new_func
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
We now simply need to add the name 
\begin_inset Quotes eld
\end_inset

new_prop
\begin_inset Quotes erd
\end_inset

 in the 
\begin_inset Quotes eld
\end_inset

properties
\begin_inset Quotes erd
\end_inset

 list in the xml input file, and the property will be written to the properties
 output file when appropriate.
\end_layout

\begin_layout Standard
If you need a function with arguments, then the code we need is given by:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

self.property_dict["new_arg_prop"] = new_arg_func
\end_layout

\begin_layout Plain Layout

...code here...
\end_layout

\begin_layout Plain Layout

def new_arg_func(self, arg1, arg2, ...
 ):
\end_layout

\begin_layout Plain Layout

   ...more code here...
\end_layout

\begin_layout Plain Layout

   return value
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Now in the property list you must put:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

<properties>
\end_layout

\begin_layout Plain Layout

   [ new_arg_prop(arg1; arg2; ...
 ), ...
 ]
\end_layout

\begin_layout Plain Layout

</properties>
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The code will now automatically call the function with the arguments defined
 in the properties list.
\end_layout

\begin_layout Section
Creating a new class
\end_layout

\begin_layout Standard
While creating a new property may be possible by using existing objects,
 it may be that you wish to calculate something in a way that is not implemented
 by the code.
 In this case, it may be necessary to create a new class to do the calculation.
 To do this efficiently, you must be understand some of the more advanced
 features of the code.
\end_layout

\begin_layout Subsection
Depend objects
\end_layout

\begin_layout Standard
Many of the new objects created inside a class may depend on other objects
 in the code for their value.
 As discussed in Chapter 3, the calculation of such variables is facilitated
 by the use of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 classes defined in the 
\begin_inset Quotes eld
\end_inset

utils
\begin_inset Quotes erd
\end_inset

 directory.
\end_layout

\begin_layout Standard
Since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overwrites the standard way of getting and setting functions, so
 there is a special syntax for creating them.
 To create a depend object 
\begin_inset Quotes eld
\end_inset

value
\begin_inset Quotes erd
\end_inset

 with name 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 inside an object 
\begin_inset Quotes eld
\end_inset

object
\begin_inset Quotes erd
\end_inset

, you need to use the syntax: 
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

dset(object, name, value)
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The arguments that are important for creating 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects are:
\end_layout

\begin_layout Description
name: A string giving the name of the depend object.
\end_layout

\begin_layout Description
value: 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 only.
 Defines the memory the object references.
\end_layout

\begin_layout Description
synchro: An optional 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This keeps track of different views on the same data.
\end_layout

\begin_layout Description
func: An optional function to recalculate the object when one of its dependencie
s are updated.
\end_layout

\begin_layout Description
dependencies: An optional list of the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects which are required to recalculate the new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object.
 Essentially a list of all the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects that appear in 
\series bold
func
\series default
.
\end_layout

\begin_layout Standard
There are two different classes of 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, 
\begin_inset Quotes eld
\end_inset

depend_value
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

.
 The 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class is a specialist class for NumPy arrays, to deal with the slicing
 mechanism.
 This means that for the 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 class there is a second method of creating new 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects, you can take a slice of an old one.
 
\end_layout

\begin_layout Standard
This will return a slice with the same dependencies and synchro objects,
 and a reference to the correct slice of the base array of the parent 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object, so that the automatic updating keeps all the data consistent.
 Note that it is therefore incorrect to create a new 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object that is a slice of an old one using the 
\series bold
dset
\series default
 function, as it will not copy the dependencies correctly.
\end_layout

\begin_layout Standard
There is also a method for dealing with separate objects that are different
 views on the same data; the 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 object.
 This object is shared with all of the different views to the same data,
 and deals with keeping all of them consistent with each other.
\end_layout

\begin_layout Standard
Also, the 
\series bold
func
\series default
 initialization argument must be a dictionary of functions that transform
 from the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object being created to the other synchronized objects, using the syntax:
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

func = {synchro1: func1, synchro2: func2, ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
Where 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 is the 
\begin_inset Quotes eld
\end_inset

name
\begin_inset Quotes erd
\end_inset

 of the Nth synchro object, and 
\begin_inset Quotes eld
\end_inset

funcN
\begin_inset Quotes erd
\end_inset

 transforms from the 
\begin_inset Quotes eld
\end_inset

synchroN
\begin_inset Quotes erd
\end_inset

 object to the one being created.
 Note that we have to make sure that we do not mix the two forms of 
\series bold
func
\series default
, synchonized objects can only depend on the other synchronized objects,
 and not on any other depend objects.
\end_layout

\begin_layout Standard
Finally, there are several utility functions that help to manipulate 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 objects:
\end_layout

\begin_layout Description
dget: Gets a specified 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed since the 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class overrides the standard Python method of getting attributes, so you
 need a way to get the 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object and not just its value.
\end_layout

\begin_layout Description
dset: Creates a 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object inside a 
\begin_inset Quotes eld
\end_inset

dobject
\begin_inset Quotes erd
\end_inset

 class.
 Needed for the same reason as 
\series bold
dget
\series default
.
\end_layout

\begin_layout Description
depstrip: Takes a 
\begin_inset Quotes eld
\end_inset

depend_array
\begin_inset Quotes erd
\end_inset

 object and returns the base array.
 Useful in algorithms where the array is used as a read-only variable, as
 it removes the dependancy network from the object, and so speeds up the
 calculation.
\end_layout

\begin_layout Description
depcopy: Copies the 
\begin_inset Quotes eld
\end_inset

dependencies
\begin_inset Quotes erd
\end_inset

 and 
\begin_inset Quotes eld
\end_inset

synchronizer
\begin_inset Quotes erd
\end_inset

 objects from one 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object to another.
\end_layout

\begin_layout Description
deppipe: Gives one 
\begin_inset Quotes eld
\end_inset

depend
\begin_inset Quotes erd
\end_inset

 object the same value as another, and adds a dependency such that this
 remains the case.
\end_layout

\begin_layout Subsection
Input class
\end_layout

\begin_layout Standard
To be able to use the xml input file to create an instance of this new class,
 and to write the file to the restart file, you must create a new input
 class, or modify an old one to recognize the new class.
\end_layout

\begin_layout Standard
Each input class must have the following class attributes:
\end_layout

\begin_layout Description
fields: This is a dictionary giving the tag names for the objects that can
 be specified in the xml input file within the tags of your class.
 Every object that can be given a value by the user should be a keyword
 of this dictionary, or of the 
\series bold
attributes 
\series default
dictionary.
 Within the dictionary, you must specify the particular class of input object
 that will be created and arguments to initialize it.
 The format of the dictionary is: 
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
begin{verbatim}
\end_layout

\begin_layout Plain Layout

{tag_name1 :
\end_layout

\begin_layout Plain Layout

   (InputClass, 
\end_layout

\begin_layout Plain Layout

      {default: default value,
\end_layout

\begin_layout Plain Layout

       help: help string, 
\end_layout

\begin_layout Plain Layout

       dtype: data type,
\end_layout

\begin_layout Plain Layout

       options: [option1, option2, ...
 ],
\end_layout

\begin_layout Plain Layout

       dimension: dimensionality of the data}), 
\end_layout

\begin_layout Plain Layout

tag_name2: ...
 }
\end_layout

\begin_layout Plain Layout


\backslash
end{verbatim}
\end_layout

\end_inset


\end_layout

\begin_layout Description
attribs: This is a dictionary of the same form as 
\series bold
fields
\series default
, but for the tag attribute data instead.
 These should always be simple data classes InputValue or InputArray, as
 their value must be specified by the user.
\end_layout

\begin_layout Description
default_help: This is the help string that will be given to help explain
 the new class to others if no other help string is given.
 It will also be the help string seen in the section in the latex file for
 the new class.
\end_layout

\begin_layout Description
default_label: This is the label used to identify the appropriate section
 in the latex help file so that different sections can cross-reference with
 the others.
\end_layout

\begin_layout Standard
The class can have the following functions:
\end_layout

\begin_layout Description
fetch: This takes the InputClass object and creates a new object of your
 class from it.
 You must make sure to call the base class fetch function using the standard
 Python function super.
\end_layout

\begin_layout Description
store: This takes an object of your class, and stores the relevant information
 needed to reinitialize it in an InputClass object.
 You must make sure to call the base class store function using the standard
 Python function super.
\end_layout

\begin_layout Description
check: This is an optional function that will check to see if the data specified
 in the input file will create a valid instance of your class, and possibly
 raise an exception otherwise.
 You must make sure to call the base class check function using the standard
 Python function super.
\end_layout

\begin_layout Description
write: This is a function that you can use to override the base class write
 function, so that you can tailor what is printed to the restart file.
\end_layout

\begin_layout Standard
The last thing that you must do to be able to use your class is to create
 an appropriate fields tag in the parent input class where you want the
 instance of your class to be held, with InputClass set to the name of your
 input class, and alter the check, store and fetch functions of the input
 class of the parent class.
\end_layout

\begin_layout Section
Submitting improvements
\end_layout

\begin_layout Standard
This code is still in developement, and any submissions to improve the code
 are welcome.
 However, to be considered as a candidate for inclusion in the main version
 of the code additions must adhere to the standards described in this section.
\end_layout

\begin_layout Subsection
Testing
\end_layout

\begin_layout Standard
Any new code should be tested for bugs before being submitted.
 At the very least the modified code should reproduce the properties in
 the test directory, and be shown to give the expected new results.
 Preferably, new results found with wrap-PI should also be compared with
 other published results, and a suitable test case added to the test directory.
\end_layout

\begin_layout Standard
It should also be tested for user input error, especially if a new input
 class has been created, so that such errors can be detected before the
 simulation is run.
 For example, if a parameter cannot be negative then this should be tested
 in the code, so that a sensible error message is given if the user inputs
 a negative value.
\end_layout

\begin_layout Subsection
Documentation
\end_layout

\begin_layout Standard
We have taken great care to make sure that all the code is well documented,
 and as such any submissions should be documented to the same standard.
 We have used the Google Python Style Guide, 
\begin_inset Flex URL
status collapsed

\begin_layout Plain Layout

http://google-styleguide.googlecode.com/svn/trunk/pyguide.html
\end_layout

\end_inset

, as a template for the documentation.
\end_layout

\begin_layout Standard
For each module we require the following documentation:
\end_layout

\begin_layout Itemize
Each new module must be added to the __init__.py and README files of the
 directory in which it is found.
\end_layout

\begin_layout Itemize
At the head of each new module, you must give a string with a summary and
 a brief description of the module with all the classes and functions that
 it defines, and an __all__ object giving the same classes and functions
 as above.
\end_layout

\begin_layout Itemize
Each class must have a docstring giving a summary, a brief description of
 its purpose and the variables it contains, including a separate section
 for any depend objects defined, and what their dependencies are.
 Input classes must also have a help string defined for all its tags, and
 an appropriate default tag.
\end_layout

\begin_layout Itemize
Each function must have a docstring giving a summary, a brief description
 of its purpose, any arguments it uses, any exceptions it can raise and
 what is returned by the function, if not None.
 
\end_layout

\begin_layout Itemize
Any new class must have its input class added to the create_man.py and help.py
 files in the doc directory, so that the automatic manual creation will
 work correctly.
\end_layout

\begin_layout Standard
If new modules are being submitted, then all of the above documentation
 should be done.
 If only a new class or function is being added, then only parts of the
 above will be necessary.
\end_layout

\begin_layout Chapter
Input class hierarchy
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
label{hierarchy}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
The following chapter gives a complete list of the tags that can be specified
 in the xml input file, along with the hierarchy of objects.
 Note that every xml input file must start with the root tag 
\begin_inset Quotes eld
\end_inset

simulation
\begin_inset Quotes erd
\end_inset

.
 
\end_layout

\begin_layout Standard
See the accompanying 
\begin_inset Quotes eld
\end_inset

help.xml
\begin_inset Quotes erd
\end_inset

 file in the 
\begin_inset Quotes eld
\end_inset

doc
\begin_inset Quotes erd
\end_inset

 directory to see the recommended input file structure.
\end_layout

\begin_layout Standard
\begin_inset ERT
status open

\begin_layout Plain Layout


\backslash
input{simulation}
\end_layout

\begin_layout Plain Layout


\backslash
input{initializer}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_file}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_pos}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_mom}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_vel}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_lab}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_mass}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_cell}
\end_layout

\begin_layout Plain Layout


\backslash
input{init_therm}
\end_layout

\begin_layout Plain Layout


\backslash
input{ensembles}
\end_layout

\begin_layout Plain Layout


\backslash
input{forces}
\end_layout

\begin_layout Plain Layout


\backslash
input{socket}
\end_layout

\begin_layout Plain Layout


\backslash
input{cell}
\end_layout

\begin_layout Plain Layout


\backslash
input{beads}
\end_layout

\begin_layout Plain Layout


\backslash
input{atoms}
\end_layout

\begin_layout Plain Layout


\backslash
input{normal_modes}
\end_layout

\begin_layout Plain Layout


\backslash
input{barostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{thermostats}
\end_layout

\begin_layout Plain Layout


\backslash
input{prng}
\end_layout

\begin_layout Plain Layout


\backslash
input{output}
\end_layout

\begin_layout Plain Layout


\backslash
input{checkpoint}
\end_layout

\begin_layout Plain Layout


\backslash
input{properties}
\end_layout

\begin_layout Plain Layout


\backslash
input{trajectory}
\end_layout

\end_inset


\end_layout

\begin_layout Standard
\begin_inset CommandInset bibtex
LatexCommand bibtex
bibfiles "mybib"
options "elsart-num-names"

\end_inset


\end_layout

\end_body
\end_document
